//
// Copyright 2023 Signal Messenger, LLC
// SPDX-License-Identifier: AGPL-3.0-only
//

// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: Backup.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

//
// Copyright 2014 Signal Messenger, LLC
// SPDX-License-Identifier: AGPL-3.0-only

/// iOS - since we use a modern proto-compiler, we must specify
/// the legacy proto format.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

enum BackupProtos_GroupV2AccessLevel: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case unknown // = 0
  case any // = 1
  case member // = 2
  case administrator // = 3
  case unsatisfiable // = 4

  init() {
    self = .unknown
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknown
    case 1: self = .any
    case 2: self = .member
    case 3: self = .administrator
    case 4: self = .unsatisfiable
    default: return nil
    }
  }

  var rawValue: Int {
    switch self {
    case .unknown: return 0
    case .any: return 1
    case .member: return 2
    case .administrator: return 3
    case .unsatisfiable: return 4
    }
  }

}

#if swift(>=4.2)

extension BackupProtos_GroupV2AccessLevel: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

struct BackupProtos_BackupInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// @required
  var version: UInt64 {
    get {return _version ?? 0}
    set {_version = newValue}
  }
  /// Returns true if `version` has been explicitly set.
  var hasVersion: Bool {return self._version != nil}
  /// Clears the value of `version`. Subsequent reads from it will return its default value.
  mutating func clearVersion() {self._version = nil}

  /// @required
  var backupTimeMs: UInt64 {
    get {return _backupTimeMs ?? 0}
    set {_backupTimeMs = newValue}
  }
  /// Returns true if `backupTimeMs` has been explicitly set.
  var hasBackupTimeMs: Bool {return self._backupTimeMs != nil}
  /// Clears the value of `backupTimeMs`. Subsequent reads from it will return its default value.
  mutating func clearBackupTimeMs() {self._backupTimeMs = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _version: UInt64? = nil
  fileprivate var _backupTimeMs: UInt64? = nil
}

struct BackupProtos_Frame {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// oneof item {
  var account: BackupProtos_AccountData {
    get {return _storage._account ?? BackupProtos_AccountData()}
    set {_uniqueStorage()._account = newValue}
  }
  /// Returns true if `account` has been explicitly set.
  var hasAccount: Bool {return _storage._account != nil}
  /// Clears the value of `account`. Subsequent reads from it will return its default value.
  mutating func clearAccount() {_uniqueStorage()._account = nil}

  var recipient: BackupProtos_Recipient {
    get {return _storage._recipient ?? BackupProtos_Recipient()}
    set {_uniqueStorage()._recipient = newValue}
  }
  /// Returns true if `recipient` has been explicitly set.
  var hasRecipient: Bool {return _storage._recipient != nil}
  /// Clears the value of `recipient`. Subsequent reads from it will return its default value.
  mutating func clearRecipient() {_uniqueStorage()._recipient = nil}

  var chat: BackupProtos_Chat {
    get {return _storage._chat ?? BackupProtos_Chat()}
    set {_uniqueStorage()._chat = newValue}
  }
  /// Returns true if `chat` has been explicitly set.
  var hasChat: Bool {return _storage._chat != nil}
  /// Clears the value of `chat`. Subsequent reads from it will return its default value.
  mutating func clearChat() {_uniqueStorage()._chat = nil}

  var chatItem: BackupProtos_ChatItem {
    get {return _storage._chatItem ?? BackupProtos_ChatItem()}
    set {_uniqueStorage()._chatItem = newValue}
  }
  /// Returns true if `chatItem` has been explicitly set.
  var hasChatItem: Bool {return _storage._chatItem != nil}
  /// Clears the value of `chatItem`. Subsequent reads from it will return its default value.
  mutating func clearChatItem() {_uniqueStorage()._chatItem = nil}

  var call: BackupProtos_Call {
    get {return _storage._call ?? BackupProtos_Call()}
    set {_uniqueStorage()._call = newValue}
  }
  /// Returns true if `call` has been explicitly set.
  var hasCall: Bool {return _storage._call != nil}
  /// Clears the value of `call`. Subsequent reads from it will return its default value.
  mutating func clearCall() {_uniqueStorage()._call = nil}

  /// }
  var stickerPack: BackupProtos_StickerPack {
    get {return _storage._stickerPack ?? BackupProtos_StickerPack()}
    set {_uniqueStorage()._stickerPack = newValue}
  }
  /// Returns true if `stickerPack` has been explicitly set.
  var hasStickerPack: Bool {return _storage._stickerPack != nil}
  /// Clears the value of `stickerPack`. Subsequent reads from it will return its default value.
  mutating func clearStickerPack() {_uniqueStorage()._stickerPack = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct BackupProtos_AccountData {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// @required
  var profileKey: Data {
    get {return _profileKey ?? Data()}
    set {_profileKey = newValue}
  }
  /// Returns true if `profileKey` has been explicitly set.
  var hasProfileKey: Bool {return self._profileKey != nil}
  /// Clears the value of `profileKey`. Subsequent reads from it will return its default value.
  mutating func clearProfileKey() {self._profileKey = nil}

  var username: String {
    get {return _username ?? String()}
    set {_username = newValue}
  }
  /// Returns true if `username` has been explicitly set.
  var hasUsername: Bool {return self._username != nil}
  /// Clears the value of `username`. Subsequent reads from it will return its default value.
  mutating func clearUsername() {self._username = nil}

  /// @required
  var usernameLink: BackupProtos_AccountData.UsernameLink {
    get {return _usernameLink ?? BackupProtos_AccountData.UsernameLink()}
    set {_usernameLink = newValue}
  }
  /// Returns true if `usernameLink` has been explicitly set.
  var hasUsernameLink: Bool {return self._usernameLink != nil}
  /// Clears the value of `usernameLink`. Subsequent reads from it will return its default value.
  mutating func clearUsernameLink() {self._usernameLink = nil}

  /// @required
  var givenName: String {
    get {return _givenName ?? String()}
    set {_givenName = newValue}
  }
  /// Returns true if `givenName` has been explicitly set.
  var hasGivenName: Bool {return self._givenName != nil}
  /// Clears the value of `givenName`. Subsequent reads from it will return its default value.
  mutating func clearGivenName() {self._givenName = nil}

  /// @required
  var familyName: String {
    get {return _familyName ?? String()}
    set {_familyName = newValue}
  }
  /// Returns true if `familyName` has been explicitly set.
  var hasFamilyName: Bool {return self._familyName != nil}
  /// Clears the value of `familyName`. Subsequent reads from it will return its default value.
  mutating func clearFamilyName() {self._familyName = nil}

  /// @required
  var avatarPath: String {
    get {return _avatarPath ?? String()}
    set {_avatarPath = newValue}
  }
  /// Returns true if `avatarPath` has been explicitly set.
  var hasAvatarPath: Bool {return self._avatarPath != nil}
  /// Clears the value of `avatarPath`. Subsequent reads from it will return its default value.
  mutating func clearAvatarPath() {self._avatarPath = nil}

  /// @required
  var subscriberID: Data {
    get {return _subscriberID ?? Data()}
    set {_subscriberID = newValue}
  }
  /// Returns true if `subscriberID` has been explicitly set.
  var hasSubscriberID: Bool {return self._subscriberID != nil}
  /// Clears the value of `subscriberID`. Subsequent reads from it will return its default value.
  mutating func clearSubscriberID() {self._subscriberID = nil}

  /// @required
  var subscriberCurrencyCode: String {
    get {return _subscriberCurrencyCode ?? String()}
    set {_subscriberCurrencyCode = newValue}
  }
  /// Returns true if `subscriberCurrencyCode` has been explicitly set.
  var hasSubscriberCurrencyCode: Bool {return self._subscriberCurrencyCode != nil}
  /// Clears the value of `subscriberCurrencyCode`. Subsequent reads from it will return its default value.
  mutating func clearSubscriberCurrencyCode() {self._subscriberCurrencyCode = nil}

  /// @required
  var subscriptionManuallyCancelled: Bool {
    get {return _subscriptionManuallyCancelled ?? false}
    set {_subscriptionManuallyCancelled = newValue}
  }
  /// Returns true if `subscriptionManuallyCancelled` has been explicitly set.
  var hasSubscriptionManuallyCancelled: Bool {return self._subscriptionManuallyCancelled != nil}
  /// Clears the value of `subscriptionManuallyCancelled`. Subsequent reads from it will return its default value.
  mutating func clearSubscriptionManuallyCancelled() {self._subscriptionManuallyCancelled = nil}

  /// @required
  var accountSettings: BackupProtos_AccountData.AccountSettings {
    get {return _accountSettings ?? BackupProtos_AccountData.AccountSettings()}
    set {_accountSettings = newValue}
  }
  /// Returns true if `accountSettings` has been explicitly set.
  var hasAccountSettings: Bool {return self._accountSettings != nil}
  /// Clears the value of `accountSettings`. Subsequent reads from it will return its default value.
  mutating func clearAccountSettings() {self._accountSettings = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum PhoneNumberSharingMode: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case unknown // = 0
    case everybody // = 1
    case nobody // = 2

    init() {
      self = .unknown
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknown
      case 1: self = .everybody
      case 2: self = .nobody
      default: return nil
      }
    }

    var rawValue: Int {
      switch self {
      case .unknown: return 0
      case .everybody: return 1
      case .nobody: return 2
      }
    }

  }

  struct UsernameLink {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// @required
    var entropy: Data {
      get {return _entropy ?? Data()}
      set {_entropy = newValue}
    }
    /// Returns true if `entropy` has been explicitly set.
    var hasEntropy: Bool {return self._entropy != nil}
    /// Clears the value of `entropy`. Subsequent reads from it will return its default value.
    mutating func clearEntropy() {self._entropy = nil}

    /// @required
    var serverID: Data {
      get {return _serverID ?? Data()}
      set {_serverID = newValue}
    }
    /// Returns true if `serverID` has been explicitly set.
    var hasServerID: Bool {return self._serverID != nil}
    /// Clears the value of `serverID`. Subsequent reads from it will return its default value.
    mutating func clearServerID() {self._serverID = nil}

    var color: BackupProtos_AccountData.UsernameLink.Color {
      get {return _color ?? .unknown}
      set {_color = newValue}
    }
    /// Returns true if `color` has been explicitly set.
    var hasColor: Bool {return self._color != nil}
    /// Clears the value of `color`. Subsequent reads from it will return its default value.
    mutating func clearColor() {self._color = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum Color: SwiftProtobuf.Enum {
      typealias RawValue = Int
      case unknown // = 0
      case blue // = 1
      case white // = 2
      case grey // = 3
      case olive // = 4
      case green // = 5
      case orange // = 6
      case pink // = 7
      case purple // = 8

      init() {
        self = .unknown
      }

      init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .unknown
        case 1: self = .blue
        case 2: self = .white
        case 3: self = .grey
        case 4: self = .olive
        case 5: self = .green
        case 6: self = .orange
        case 7: self = .pink
        case 8: self = .purple
        default: return nil
        }
      }

      var rawValue: Int {
        switch self {
        case .unknown: return 0
        case .blue: return 1
        case .white: return 2
        case .grey: return 3
        case .olive: return 4
        case .green: return 5
        case .orange: return 6
        case .pink: return 7
        case .purple: return 8
        }
      }

    }

    init() {}

    fileprivate var _entropy: Data? = nil
    fileprivate var _serverID: Data? = nil
    fileprivate var _color: BackupProtos_AccountData.UsernameLink.Color? = nil
  }

  struct AccountSettings {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// @required
    var readReceipts: Bool {
      get {return _storage._readReceipts ?? false}
      set {_uniqueStorage()._readReceipts = newValue}
    }
    /// Returns true if `readReceipts` has been explicitly set.
    var hasReadReceipts: Bool {return _storage._readReceipts != nil}
    /// Clears the value of `readReceipts`. Subsequent reads from it will return its default value.
    mutating func clearReadReceipts() {_uniqueStorage()._readReceipts = nil}

    /// @required
    var sealedSenderIndicators: Bool {
      get {return _storage._sealedSenderIndicators ?? false}
      set {_uniqueStorage()._sealedSenderIndicators = newValue}
    }
    /// Returns true if `sealedSenderIndicators` has been explicitly set.
    var hasSealedSenderIndicators: Bool {return _storage._sealedSenderIndicators != nil}
    /// Clears the value of `sealedSenderIndicators`. Subsequent reads from it will return its default value.
    mutating func clearSealedSenderIndicators() {_uniqueStorage()._sealedSenderIndicators = nil}

    /// @required
    var typingIndicators: Bool {
      get {return _storage._typingIndicators ?? false}
      set {_uniqueStorage()._typingIndicators = newValue}
    }
    /// Returns true if `typingIndicators` has been explicitly set.
    var hasTypingIndicators: Bool {return _storage._typingIndicators != nil}
    /// Clears the value of `typingIndicators`. Subsequent reads from it will return its default value.
    mutating func clearTypingIndicators() {_uniqueStorage()._typingIndicators = nil}

    /// @required
    var noteToSelfMarkedUnread: Bool {
      get {return _storage._noteToSelfMarkedUnread ?? false}
      set {_uniqueStorage()._noteToSelfMarkedUnread = newValue}
    }
    /// Returns true if `noteToSelfMarkedUnread` has been explicitly set.
    var hasNoteToSelfMarkedUnread: Bool {return _storage._noteToSelfMarkedUnread != nil}
    /// Clears the value of `noteToSelfMarkedUnread`. Subsequent reads from it will return its default value.
    mutating func clearNoteToSelfMarkedUnread() {_uniqueStorage()._noteToSelfMarkedUnread = nil}

    /// @required
    var linkPreviews: Bool {
      get {return _storage._linkPreviews ?? false}
      set {_uniqueStorage()._linkPreviews = newValue}
    }
    /// Returns true if `linkPreviews` has been explicitly set.
    var hasLinkPreviews: Bool {return _storage._linkPreviews != nil}
    /// Clears the value of `linkPreviews`. Subsequent reads from it will return its default value.
    mutating func clearLinkPreviews() {_uniqueStorage()._linkPreviews = nil}

    /// @required
    var notDiscoverableByPhoneNumber: Bool {
      get {return _storage._notDiscoverableByPhoneNumber ?? false}
      set {_uniqueStorage()._notDiscoverableByPhoneNumber = newValue}
    }
    /// Returns true if `notDiscoverableByPhoneNumber` has been explicitly set.
    var hasNotDiscoverableByPhoneNumber: Bool {return _storage._notDiscoverableByPhoneNumber != nil}
    /// Clears the value of `notDiscoverableByPhoneNumber`. Subsequent reads from it will return its default value.
    mutating func clearNotDiscoverableByPhoneNumber() {_uniqueStorage()._notDiscoverableByPhoneNumber = nil}

    /// @required
    var preferContactAvatars: Bool {
      get {return _storage._preferContactAvatars ?? false}
      set {_uniqueStorage()._preferContactAvatars = newValue}
    }
    /// Returns true if `preferContactAvatars` has been explicitly set.
    var hasPreferContactAvatars: Bool {return _storage._preferContactAvatars != nil}
    /// Clears the value of `preferContactAvatars`. Subsequent reads from it will return its default value.
    mutating func clearPreferContactAvatars() {_uniqueStorage()._preferContactAvatars = nil}

    /// @required
    var universalExpireTimer: UInt32 {
      get {return _storage._universalExpireTimer ?? 0}
      set {_uniqueStorage()._universalExpireTimer = newValue}
    }
    /// Returns true if `universalExpireTimer` has been explicitly set.
    var hasUniversalExpireTimer: Bool {return _storage._universalExpireTimer != nil}
    /// Clears the value of `universalExpireTimer`. Subsequent reads from it will return its default value.
    mutating func clearUniversalExpireTimer() {_uniqueStorage()._universalExpireTimer = nil}

    var preferredReactionEmoji: [String] {
      get {return _storage._preferredReactionEmoji}
      set {_uniqueStorage()._preferredReactionEmoji = newValue}
    }

    /// @required
    var displayBadgesOnProfile: Bool {
      get {return _storage._displayBadgesOnProfile ?? false}
      set {_uniqueStorage()._displayBadgesOnProfile = newValue}
    }
    /// Returns true if `displayBadgesOnProfile` has been explicitly set.
    var hasDisplayBadgesOnProfile: Bool {return _storage._displayBadgesOnProfile != nil}
    /// Clears the value of `displayBadgesOnProfile`. Subsequent reads from it will return its default value.
    mutating func clearDisplayBadgesOnProfile() {_uniqueStorage()._displayBadgesOnProfile = nil}

    /// @required
    var keepMutedChatsArchived: Bool {
      get {return _storage._keepMutedChatsArchived ?? false}
      set {_uniqueStorage()._keepMutedChatsArchived = newValue}
    }
    /// Returns true if `keepMutedChatsArchived` has been explicitly set.
    var hasKeepMutedChatsArchived: Bool {return _storage._keepMutedChatsArchived != nil}
    /// Clears the value of `keepMutedChatsArchived`. Subsequent reads from it will return its default value.
    mutating func clearKeepMutedChatsArchived() {_uniqueStorage()._keepMutedChatsArchived = nil}

    /// @required
    var myStoriesPrivacyHasBeenSet: Bool {
      get {return _storage._myStoriesPrivacyHasBeenSet ?? false}
      set {_uniqueStorage()._myStoriesPrivacyHasBeenSet = newValue}
    }
    /// Returns true if `myStoriesPrivacyHasBeenSet` has been explicitly set.
    var hasMyStoriesPrivacyHasBeenSet: Bool {return _storage._myStoriesPrivacyHasBeenSet != nil}
    /// Clears the value of `myStoriesPrivacyHasBeenSet`. Subsequent reads from it will return its default value.
    mutating func clearMyStoriesPrivacyHasBeenSet() {_uniqueStorage()._myStoriesPrivacyHasBeenSet = nil}

    /// @required
    var onboardingStoryHasBeenViewed: Bool {
      get {return _storage._onboardingStoryHasBeenViewed ?? false}
      set {_uniqueStorage()._onboardingStoryHasBeenViewed = newValue}
    }
    /// Returns true if `onboardingStoryHasBeenViewed` has been explicitly set.
    var hasOnboardingStoryHasBeenViewed: Bool {return _storage._onboardingStoryHasBeenViewed != nil}
    /// Clears the value of `onboardingStoryHasBeenViewed`. Subsequent reads from it will return its default value.
    mutating func clearOnboardingStoryHasBeenViewed() {_uniqueStorage()._onboardingStoryHasBeenViewed = nil}

    /// @required
    var storiesDisabled: Bool {
      get {return _storage._storiesDisabled ?? false}
      set {_uniqueStorage()._storiesDisabled = newValue}
    }
    /// Returns true if `storiesDisabled` has been explicitly set.
    var hasStoriesDisabled: Bool {return _storage._storiesDisabled != nil}
    /// Clears the value of `storiesDisabled`. Subsequent reads from it will return its default value.
    mutating func clearStoriesDisabled() {_uniqueStorage()._storiesDisabled = nil}

    var storyViewReceiptsEnabled: Bool {
      get {return _storage._storyViewReceiptsEnabled ?? false}
      set {_uniqueStorage()._storyViewReceiptsEnabled = newValue}
    }
    /// Returns true if `storyViewReceiptsEnabled` has been explicitly set.
    var hasStoryViewReceiptsEnabled: Bool {return _storage._storyViewReceiptsEnabled != nil}
    /// Clears the value of `storyViewReceiptsEnabled`. Subsequent reads from it will return its default value.
    mutating func clearStoryViewReceiptsEnabled() {_uniqueStorage()._storyViewReceiptsEnabled = nil}

    /// @required
    var groupStoryEducationSheetHasBeenSeen: Bool {
      get {return _storage._groupStoryEducationSheetHasBeenSeen ?? false}
      set {_uniqueStorage()._groupStoryEducationSheetHasBeenSeen = newValue}
    }
    /// Returns true if `groupStoryEducationSheetHasBeenSeen` has been explicitly set.
    var hasGroupStoryEducationSheetHasBeenSeen: Bool {return _storage._groupStoryEducationSheetHasBeenSeen != nil}
    /// Clears the value of `groupStoryEducationSheetHasBeenSeen`. Subsequent reads from it will return its default value.
    mutating func clearGroupStoryEducationSheetHasBeenSeen() {_uniqueStorage()._groupStoryEducationSheetHasBeenSeen = nil}

    /// @required
    var usernameOnboardingHasBeenCompleted: Bool {
      get {return _storage._usernameOnboardingHasBeenCompleted ?? false}
      set {_uniqueStorage()._usernameOnboardingHasBeenCompleted = newValue}
    }
    /// Returns true if `usernameOnboardingHasBeenCompleted` has been explicitly set.
    var hasUsernameOnboardingHasBeenCompleted: Bool {return _storage._usernameOnboardingHasBeenCompleted != nil}
    /// Clears the value of `usernameOnboardingHasBeenCompleted`. Subsequent reads from it will return its default value.
    mutating func clearUsernameOnboardingHasBeenCompleted() {_uniqueStorage()._usernameOnboardingHasBeenCompleted = nil}

    var phoneNumberSharingMode: BackupProtos_AccountData.PhoneNumberSharingMode {
      get {return _storage._phoneNumberSharingMode ?? .unknown}
      set {_uniqueStorage()._phoneNumberSharingMode = newValue}
    }
    /// Returns true if `phoneNumberSharingMode` has been explicitly set.
    var hasPhoneNumberSharingMode: Bool {return _storage._phoneNumberSharingMode != nil}
    /// Clears the value of `phoneNumberSharingMode`. Subsequent reads from it will return its default value.
    mutating func clearPhoneNumberSharingMode() {_uniqueStorage()._phoneNumberSharingMode = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  init() {}

  fileprivate var _profileKey: Data? = nil
  fileprivate var _username: String? = nil
  fileprivate var _usernameLink: BackupProtos_AccountData.UsernameLink? = nil
  fileprivate var _givenName: String? = nil
  fileprivate var _familyName: String? = nil
  fileprivate var _avatarPath: String? = nil
  fileprivate var _subscriberID: Data? = nil
  fileprivate var _subscriberCurrencyCode: String? = nil
  fileprivate var _subscriptionManuallyCancelled: Bool? = nil
  fileprivate var _accountSettings: BackupProtos_AccountData.AccountSettings? = nil
}

#if swift(>=4.2)

extension BackupProtos_AccountData.PhoneNumberSharingMode: CaseIterable {
  // Support synthesized by the compiler.
}

extension BackupProtos_AccountData.UsernameLink.Color: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

struct BackupProtos_Recipient {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// @required
  var id: UInt64 {
    get {return _storage._id ?? 0}
    set {_uniqueStorage()._id = newValue}
  }
  /// Returns true if `id` has been explicitly set.
  var hasID: Bool {return _storage._id != nil}
  /// Clears the value of `id`. Subsequent reads from it will return its default value.
  mutating func clearID() {_uniqueStorage()._id = nil}

  /// oneof destination {
  var contact: BackupProtos_Contact {
    get {return _storage._contact ?? BackupProtos_Contact()}
    set {_uniqueStorage()._contact = newValue}
  }
  /// Returns true if `contact` has been explicitly set.
  var hasContact: Bool {return _storage._contact != nil}
  /// Clears the value of `contact`. Subsequent reads from it will return its default value.
  mutating func clearContact() {_uniqueStorage()._contact = nil}

  var group: BackupProtos_Group {
    get {return _storage._group ?? BackupProtos_Group()}
    set {_uniqueStorage()._group = newValue}
  }
  /// Returns true if `group` has been explicitly set.
  var hasGroup: Bool {return _storage._group != nil}
  /// Clears the value of `group`. Subsequent reads from it will return its default value.
  mutating func clearGroup() {_uniqueStorage()._group = nil}

  var distributionList: BackupProtos_DistributionList {
    get {return _storage._distributionList ?? BackupProtos_DistributionList()}
    set {_uniqueStorage()._distributionList = newValue}
  }
  /// Returns true if `distributionList` has been explicitly set.
  var hasDistributionList: Bool {return _storage._distributionList != nil}
  /// Clears the value of `distributionList`. Subsequent reads from it will return its default value.
  mutating func clearDistributionList() {_uniqueStorage()._distributionList = nil}

  var selfRecipient: BackupProtos_SelfRecipient {
    get {return _storage._selfRecipient ?? BackupProtos_SelfRecipient()}
    set {_uniqueStorage()._selfRecipient = newValue}
  }
  /// Returns true if `selfRecipient` has been explicitly set.
  var hasSelfRecipient: Bool {return _storage._selfRecipient != nil}
  /// Clears the value of `selfRecipient`. Subsequent reads from it will return its default value.
  mutating func clearSelfRecipient() {_uniqueStorage()._selfRecipient = nil}

  /// }
  var releaseNotes: BackupProtos_ReleaseNotes {
    get {return _storage._releaseNotes ?? BackupProtos_ReleaseNotes()}
    set {_uniqueStorage()._releaseNotes = newValue}
  }
  /// Returns true if `releaseNotes` has been explicitly set.
  var hasReleaseNotes: Bool {return _storage._releaseNotes != nil}
  /// Clears the value of `releaseNotes`. Subsequent reads from it will return its default value.
  mutating func clearReleaseNotes() {_uniqueStorage()._releaseNotes = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct BackupProtos_Contact {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// should be 16 bytes
  var aci: Data {
    get {return _aci ?? Data()}
    set {_aci = newValue}
  }
  /// Returns true if `aci` has been explicitly set.
  var hasAci: Bool {return self._aci != nil}
  /// Clears the value of `aci`. Subsequent reads from it will return its default value.
  mutating func clearAci() {self._aci = nil}

  /// should be 16 bytes
  var pni: Data {
    get {return _pni ?? Data()}
    set {_pni = newValue}
  }
  /// Returns true if `pni` has been explicitly set.
  var hasPni: Bool {return self._pni != nil}
  /// Clears the value of `pni`. Subsequent reads from it will return its default value.
  mutating func clearPni() {self._pni = nil}

  var username: String {
    get {return _username ?? String()}
    set {_username = newValue}
  }
  /// Returns true if `username` has been explicitly set.
  var hasUsername: Bool {return self._username != nil}
  /// Clears the value of `username`. Subsequent reads from it will return its default value.
  mutating func clearUsername() {self._username = nil}

  var e164: UInt64 {
    get {return _e164 ?? 0}
    set {_e164 = newValue}
  }
  /// Returns true if `e164` has been explicitly set.
  var hasE164: Bool {return self._e164 != nil}
  /// Clears the value of `e164`. Subsequent reads from it will return its default value.
  mutating func clearE164() {self._e164 = nil}

  /// @required
  var blocked: Bool {
    get {return _blocked ?? false}
    set {_blocked = newValue}
  }
  /// Returns true if `blocked` has been explicitly set.
  var hasBlocked: Bool {return self._blocked != nil}
  /// Clears the value of `blocked`. Subsequent reads from it will return its default value.
  mutating func clearBlocked() {self._blocked = nil}

  /// @required
  var hidden: Bool {
    get {return _hidden ?? false}
    set {_hidden = newValue}
  }
  /// Returns true if `hidden` has been explicitly set.
  var hasHidden: Bool {return self._hidden != nil}
  /// Clears the value of `hidden`. Subsequent reads from it will return its default value.
  mutating func clearHidden() {self._hidden = nil}

  var registered: BackupProtos_Contact.Registered {
    get {return _registered ?? .unknown}
    set {_registered = newValue}
  }
  /// Returns true if `registered` has been explicitly set.
  var hasRegistered: Bool {return self._registered != nil}
  /// Clears the value of `registered`. Subsequent reads from it will return its default value.
  mutating func clearRegistered() {self._registered = nil}

  /// @required
  var unregisteredTimestamp: UInt64 {
    get {return _unregisteredTimestamp ?? 0}
    set {_unregisteredTimestamp = newValue}
  }
  /// Returns true if `unregisteredTimestamp` has been explicitly set.
  var hasUnregisteredTimestamp: Bool {return self._unregisteredTimestamp != nil}
  /// Clears the value of `unregisteredTimestamp`. Subsequent reads from it will return its default value.
  mutating func clearUnregisteredTimestamp() {self._unregisteredTimestamp = nil}

  var profileKey: Data {
    get {return _profileKey ?? Data()}
    set {_profileKey = newValue}
  }
  /// Returns true if `profileKey` has been explicitly set.
  var hasProfileKey: Bool {return self._profileKey != nil}
  /// Clears the value of `profileKey`. Subsequent reads from it will return its default value.
  mutating func clearProfileKey() {self._profileKey = nil}

  /// @required
  var profileSharing: Bool {
    get {return _profileSharing ?? false}
    set {_profileSharing = newValue}
  }
  /// Returns true if `profileSharing` has been explicitly set.
  var hasProfileSharing: Bool {return self._profileSharing != nil}
  /// Clears the value of `profileSharing`. Subsequent reads from it will return its default value.
  mutating func clearProfileSharing() {self._profileSharing = nil}

  var profileGivenName: String {
    get {return _profileGivenName ?? String()}
    set {_profileGivenName = newValue}
  }
  /// Returns true if `profileGivenName` has been explicitly set.
  var hasProfileGivenName: Bool {return self._profileGivenName != nil}
  /// Clears the value of `profileGivenName`. Subsequent reads from it will return its default value.
  mutating func clearProfileGivenName() {self._profileGivenName = nil}

  var profileFamilyName: String {
    get {return _profileFamilyName ?? String()}
    set {_profileFamilyName = newValue}
  }
  /// Returns true if `profileFamilyName` has been explicitly set.
  var hasProfileFamilyName: Bool {return self._profileFamilyName != nil}
  /// Clears the value of `profileFamilyName`. Subsequent reads from it will return its default value.
  mutating func clearProfileFamilyName() {self._profileFamilyName = nil}

  /// @required
  var hideStory: Bool {
    get {return _hideStory ?? false}
    set {_hideStory = newValue}
  }
  /// Returns true if `hideStory` has been explicitly set.
  var hasHideStory: Bool {return self._hideStory != nil}
  /// Clears the value of `hideStory`. Subsequent reads from it will return its default value.
  mutating func clearHideStory() {self._hideStory = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum Registered: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case unknown // = 0
    case registered // = 1
    case notRegistered // = 2

    init() {
      self = .unknown
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknown
      case 1: self = .registered
      case 2: self = .notRegistered
      default: return nil
      }
    }

    var rawValue: Int {
      switch self {
      case .unknown: return 0
      case .registered: return 1
      case .notRegistered: return 2
      }
    }

  }

  init() {}

  fileprivate var _aci: Data? = nil
  fileprivate var _pni: Data? = nil
  fileprivate var _username: String? = nil
  fileprivate var _e164: UInt64? = nil
  fileprivate var _blocked: Bool? = nil
  fileprivate var _hidden: Bool? = nil
  fileprivate var _registered: BackupProtos_Contact.Registered? = nil
  fileprivate var _unregisteredTimestamp: UInt64? = nil
  fileprivate var _profileKey: Data? = nil
  fileprivate var _profileSharing: Bool? = nil
  fileprivate var _profileGivenName: String? = nil
  fileprivate var _profileFamilyName: String? = nil
  fileprivate var _hideStory: Bool? = nil
}

#if swift(>=4.2)

extension BackupProtos_Contact.Registered: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

struct BackupProtos_Group {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// @required
  var masterKey: Data {
    get {return _masterKey ?? Data()}
    set {_masterKey = newValue}
  }
  /// Returns true if `masterKey` has been explicitly set.
  var hasMasterKey: Bool {return self._masterKey != nil}
  /// Clears the value of `masterKey`. Subsequent reads from it will return its default value.
  mutating func clearMasterKey() {self._masterKey = nil}

  /// @required
  var whitelisted: Bool {
    get {return _whitelisted ?? false}
    set {_whitelisted = newValue}
  }
  /// Returns true if `whitelisted` has been explicitly set.
  var hasWhitelisted: Bool {return self._whitelisted != nil}
  /// Clears the value of `whitelisted`. Subsequent reads from it will return its default value.
  mutating func clearWhitelisted() {self._whitelisted = nil}

  /// @required
  var hideStory: Bool {
    get {return _hideStory ?? false}
    set {_hideStory = newValue}
  }
  /// Returns true if `hideStory` has been explicitly set.
  var hasHideStory: Bool {return self._hideStory != nil}
  /// Clears the value of `hideStory`. Subsequent reads from it will return its default value.
  mutating func clearHideStory() {self._hideStory = nil}

  var storySendMode: BackupProtos_Group.StorySendMode {
    get {return _storySendMode ?? .default}
    set {_storySendMode = newValue}
  }
  /// Returns true if `storySendMode` has been explicitly set.
  var hasStorySendMode: Bool {return self._storySendMode != nil}
  /// Clears the value of `storySendMode`. Subsequent reads from it will return its default value.
  mutating func clearStorySendMode() {self._storySendMode = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum StorySendMode: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case `default` // = 0
    case disabled // = 1
    case enabled // = 2

    init() {
      self = .default
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .default
      case 1: self = .disabled
      case 2: self = .enabled
      default: return nil
      }
    }

    var rawValue: Int {
      switch self {
      case .default: return 0
      case .disabled: return 1
      case .enabled: return 2
      }
    }

  }

  init() {}

  fileprivate var _masterKey: Data? = nil
  fileprivate var _whitelisted: Bool? = nil
  fileprivate var _hideStory: Bool? = nil
  fileprivate var _storySendMode: BackupProtos_Group.StorySendMode? = nil
}

#if swift(>=4.2)

extension BackupProtos_Group.StorySendMode: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

struct BackupProtos_SelfRecipient {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct BackupProtos_ReleaseNotes {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct BackupProtos_Chat {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// @required
  var id: UInt64 {
    get {return _id ?? 0}
    set {_id = newValue}
  }
  /// Returns true if `id` has been explicitly set.
  var hasID: Bool {return self._id != nil}
  /// Clears the value of `id`. Subsequent reads from it will return its default value.
  mutating func clearID() {self._id = nil}

  /// @required
  var recipientID: UInt64 {
    get {return _recipientID ?? 0}
    set {_recipientID = newValue}
  }
  /// Returns true if `recipientID` has been explicitly set.
  var hasRecipientID: Bool {return self._recipientID != nil}
  /// Clears the value of `recipientID`. Subsequent reads from it will return its default value.
  mutating func clearRecipientID() {self._recipientID = nil}

  /// @required
  var archived: Bool {
    get {return _archived ?? false}
    set {_archived = newValue}
  }
  /// Returns true if `archived` has been explicitly set.
  var hasArchived: Bool {return self._archived != nil}
  /// Clears the value of `archived`. Subsequent reads from it will return its default value.
  mutating func clearArchived() {self._archived = nil}

  /// @required
  var pinnedOrder: UInt32 {
    get {return _pinnedOrder ?? 0}
    set {_pinnedOrder = newValue}
  }
  /// Returns true if `pinnedOrder` has been explicitly set.
  var hasPinnedOrder: Bool {return self._pinnedOrder != nil}
  /// Clears the value of `pinnedOrder`. Subsequent reads from it will return its default value.
  mutating func clearPinnedOrder() {self._pinnedOrder = nil}

  /// @required
  var expirationTimerMs: UInt64 {
    get {return _expirationTimerMs ?? 0}
    set {_expirationTimerMs = newValue}
  }
  /// Returns true if `expirationTimerMs` has been explicitly set.
  var hasExpirationTimerMs: Bool {return self._expirationTimerMs != nil}
  /// Clears the value of `expirationTimerMs`. Subsequent reads from it will return its default value.
  mutating func clearExpirationTimerMs() {self._expirationTimerMs = nil}

  /// @required
  var muteUntilMs: UInt64 {
    get {return _muteUntilMs ?? 0}
    set {_muteUntilMs = newValue}
  }
  /// Returns true if `muteUntilMs` has been explicitly set.
  var hasMuteUntilMs: Bool {return self._muteUntilMs != nil}
  /// Clears the value of `muteUntilMs`. Subsequent reads from it will return its default value.
  mutating func clearMuteUntilMs() {self._muteUntilMs = nil}

  /// @required
  var markedUnread: Bool {
    get {return _markedUnread ?? false}
    set {_markedUnread = newValue}
  }
  /// Returns true if `markedUnread` has been explicitly set.
  var hasMarkedUnread: Bool {return self._markedUnread != nil}
  /// Clears the value of `markedUnread`. Subsequent reads from it will return its default value.
  mutating func clearMarkedUnread() {self._markedUnread = nil}

  /// @required
  var dontNotifyForMentionsIfMuted: Bool {
    get {return _dontNotifyForMentionsIfMuted ?? false}
    set {_dontNotifyForMentionsIfMuted = newValue}
  }
  /// Returns true if `dontNotifyForMentionsIfMuted` has been explicitly set.
  var hasDontNotifyForMentionsIfMuted: Bool {return self._dontNotifyForMentionsIfMuted != nil}
  /// Clears the value of `dontNotifyForMentionsIfMuted`. Subsequent reads from it will return its default value.
  mutating func clearDontNotifyForMentionsIfMuted() {self._dontNotifyForMentionsIfMuted = nil}

  var wallpaper: BackupProtos_FilePointer {
    get {return _wallpaper ?? BackupProtos_FilePointer()}
    set {_wallpaper = newValue}
  }
  /// Returns true if `wallpaper` has been explicitly set.
  var hasWallpaper: Bool {return self._wallpaper != nil}
  /// Clears the value of `wallpaper`. Subsequent reads from it will return its default value.
  mutating func clearWallpaper() {self._wallpaper = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _id: UInt64? = nil
  fileprivate var _recipientID: UInt64? = nil
  fileprivate var _archived: Bool? = nil
  fileprivate var _pinnedOrder: UInt32? = nil
  fileprivate var _expirationTimerMs: UInt64? = nil
  fileprivate var _muteUntilMs: UInt64? = nil
  fileprivate var _markedUnread: Bool? = nil
  fileprivate var _dontNotifyForMentionsIfMuted: Bool? = nil
  fileprivate var _wallpaper: BackupProtos_FilePointer? = nil
}

struct BackupProtos_DistributionList {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// @required
  var name: String {
    get {return _name ?? String()}
    set {_name = newValue}
  }
  /// Returns true if `name` has been explicitly set.
  var hasName: Bool {return self._name != nil}
  /// Clears the value of `name`. Subsequent reads from it will return its default value.
  mutating func clearName() {self._name = nil}

  /// @required
  var distributionID: Data {
    get {return _distributionID ?? Data()}
    set {_distributionID = newValue}
  }
  /// Returns true if `distributionID` has been explicitly set.
  var hasDistributionID: Bool {return self._distributionID != nil}
  /// Clears the value of `distributionID`. Subsequent reads from it will return its default value.
  mutating func clearDistributionID() {self._distributionID = nil}

  /// @required
  var allowReplies: Bool {
    get {return _allowReplies ?? false}
    set {_allowReplies = newValue}
  }
  /// Returns true if `allowReplies` has been explicitly set.
  var hasAllowReplies: Bool {return self._allowReplies != nil}
  /// Clears the value of `allowReplies`. Subsequent reads from it will return its default value.
  mutating func clearAllowReplies() {self._allowReplies = nil}

  /// @required
  var deletionTimestamp: UInt64 {
    get {return _deletionTimestamp ?? 0}
    set {_deletionTimestamp = newValue}
  }
  /// Returns true if `deletionTimestamp` has been explicitly set.
  var hasDeletionTimestamp: Bool {return self._deletionTimestamp != nil}
  /// Clears the value of `deletionTimestamp`. Subsequent reads from it will return its default value.
  mutating func clearDeletionTimestamp() {self._deletionTimestamp = nil}

  var privacyMode: BackupProtos_DistributionList.PrivacyMode {
    get {return _privacyMode ?? .unknown}
    set {_privacyMode = newValue}
  }
  /// Returns true if `privacyMode` has been explicitly set.
  var hasPrivacyMode: Bool {return self._privacyMode != nil}
  /// Clears the value of `privacyMode`. Subsequent reads from it will return its default value.
  mutating func clearPrivacyMode() {self._privacyMode = nil}

  /// generated recipient id
  var memberRecipientIds: [UInt64] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum PrivacyMode: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case unknown // = 0
    case onlyWith // = 1
    case allExcept // = 2
    case all // = 3

    init() {
      self = .unknown
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknown
      case 1: self = .onlyWith
      case 2: self = .allExcept
      case 3: self = .all
      default: return nil
      }
    }

    var rawValue: Int {
      switch self {
      case .unknown: return 0
      case .onlyWith: return 1
      case .allExcept: return 2
      case .all: return 3
      }
    }

  }

  init() {}

  fileprivate var _name: String? = nil
  fileprivate var _distributionID: Data? = nil
  fileprivate var _allowReplies: Bool? = nil
  fileprivate var _deletionTimestamp: UInt64? = nil
  fileprivate var _privacyMode: BackupProtos_DistributionList.PrivacyMode? = nil
}

#if swift(>=4.2)

extension BackupProtos_DistributionList.PrivacyMode: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

struct BackupProtos_Identity {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// @required
  var serviceID: Data {
    get {return _serviceID ?? Data()}
    set {_serviceID = newValue}
  }
  /// Returns true if `serviceID` has been explicitly set.
  var hasServiceID: Bool {return self._serviceID != nil}
  /// Clears the value of `serviceID`. Subsequent reads from it will return its default value.
  mutating func clearServiceID() {self._serviceID = nil}

  /// @required
  var identityKey: Data {
    get {return _identityKey ?? Data()}
    set {_identityKey = newValue}
  }
  /// Returns true if `identityKey` has been explicitly set.
  var hasIdentityKey: Bool {return self._identityKey != nil}
  /// Clears the value of `identityKey`. Subsequent reads from it will return its default value.
  mutating func clearIdentityKey() {self._identityKey = nil}

  /// @required
  var timestamp: UInt64 {
    get {return _timestamp ?? 0}
    set {_timestamp = newValue}
  }
  /// Returns true if `timestamp` has been explicitly set.
  var hasTimestamp: Bool {return self._timestamp != nil}
  /// Clears the value of `timestamp`. Subsequent reads from it will return its default value.
  mutating func clearTimestamp() {self._timestamp = nil}

  /// @required
  var firstUse: Bool {
    get {return _firstUse ?? false}
    set {_firstUse = newValue}
  }
  /// Returns true if `firstUse` has been explicitly set.
  var hasFirstUse: Bool {return self._firstUse != nil}
  /// Clears the value of `firstUse`. Subsequent reads from it will return its default value.
  mutating func clearFirstUse() {self._firstUse = nil}

  /// @required
  var verified: Bool {
    get {return _verified ?? false}
    set {_verified = newValue}
  }
  /// Returns true if `verified` has been explicitly set.
  var hasVerified: Bool {return self._verified != nil}
  /// Clears the value of `verified`. Subsequent reads from it will return its default value.
  mutating func clearVerified() {self._verified = nil}

  /// @required
  var nonblockingApproval: Bool {
    get {return _nonblockingApproval ?? false}
    set {_nonblockingApproval = newValue}
  }
  /// Returns true if `nonblockingApproval` has been explicitly set.
  var hasNonblockingApproval: Bool {return self._nonblockingApproval != nil}
  /// Clears the value of `nonblockingApproval`. Subsequent reads from it will return its default value.
  mutating func clearNonblockingApproval() {self._nonblockingApproval = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _serviceID: Data? = nil
  fileprivate var _identityKey: Data? = nil
  fileprivate var _timestamp: UInt64? = nil
  fileprivate var _firstUse: Bool? = nil
  fileprivate var _verified: Bool? = nil
  fileprivate var _nonblockingApproval: Bool? = nil
}

struct BackupProtos_Call {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// @required
  var callID: UInt64 {
    get {return _callID ?? 0}
    set {_callID = newValue}
  }
  /// Returns true if `callID` has been explicitly set.
  var hasCallID: Bool {return self._callID != nil}
  /// Clears the value of `callID`. Subsequent reads from it will return its default value.
  mutating func clearCallID() {self._callID = nil}

  /// @required
  var conversationRecipientID: UInt64 {
    get {return _conversationRecipientID ?? 0}
    set {_conversationRecipientID = newValue}
  }
  /// Returns true if `conversationRecipientID` has been explicitly set.
  var hasConversationRecipientID: Bool {return self._conversationRecipientID != nil}
  /// Clears the value of `conversationRecipientID`. Subsequent reads from it will return its default value.
  mutating func clearConversationRecipientID() {self._conversationRecipientID = nil}

  var type: BackupProtos_Call.TypeEnum {
    get {return _type ?? .unknownType}
    set {_type = newValue}
  }
  /// Returns true if `type` has been explicitly set.
  var hasType: Bool {return self._type != nil}
  /// Clears the value of `type`. Subsequent reads from it will return its default value.
  mutating func clearType() {self._type = nil}

  /// @required
  var outgoing: Bool {
    get {return _outgoing ?? false}
    set {_outgoing = newValue}
  }
  /// Returns true if `outgoing` has been explicitly set.
  var hasOutgoing: Bool {return self._outgoing != nil}
  /// Clears the value of `outgoing`. Subsequent reads from it will return its default value.
  mutating func clearOutgoing() {self._outgoing = nil}

  /// @required
  var timestamp: UInt64 {
    get {return _timestamp ?? 0}
    set {_timestamp = newValue}
  }
  /// Returns true if `timestamp` has been explicitly set.
  var hasTimestamp: Bool {return self._timestamp != nil}
  /// Clears the value of `timestamp`. Subsequent reads from it will return its default value.
  mutating func clearTimestamp() {self._timestamp = nil}

  var ringerRecipientID: UInt64 {
    get {return _ringerRecipientID ?? 0}
    set {_ringerRecipientID = newValue}
  }
  /// Returns true if `ringerRecipientID` has been explicitly set.
  var hasRingerRecipientID: Bool {return self._ringerRecipientID != nil}
  /// Clears the value of `ringerRecipientID`. Subsequent reads from it will return its default value.
  mutating func clearRingerRecipientID() {self._ringerRecipientID = nil}

  var event: BackupProtos_Call.Event {
    get {return _event ?? .unknownEvent}
    set {_event = newValue}
  }
  /// Returns true if `event` has been explicitly set.
  var hasEvent: Bool {return self._event != nil}
  /// Clears the value of `event`. Subsequent reads from it will return its default value.
  mutating func clearEvent() {self._event = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum TypeEnum: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case unknownType // = 0
    case audioCall // = 1
    case videoCall // = 2
    case groupCall // = 3
    case adHocCall // = 4

    init() {
      self = .unknownType
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknownType
      case 1: self = .audioCall
      case 2: self = .videoCall
      case 3: self = .groupCall
      case 4: self = .adHocCall
      default: return nil
      }
    }

    var rawValue: Int {
      switch self {
      case .unknownType: return 0
      case .audioCall: return 1
      case .videoCall: return 2
      case .groupCall: return 3
      case .adHocCall: return 4
      }
    }

  }

  enum Event: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case unknownEvent // = 0

    /// 1:1 calls only
    case outgoing // = 1

    /// 1:1 and group calls. Group calls: You accepted a ring.
    case accepted // = 2

    /// 1:1 calls only,
    case notAccepted // = 3

    /// 1:1 and group. Group calls: The remote ring has expired or was cancelled by the ringer.
    case missed // = 4

    /// 1:1 and Group/Ad-Hoc Calls.
    case delete // = 5

    /// Group/Ad-Hoc Calls only. Initial state
    case genericGroupCall // = 6

    /// Group Calls: User has joined the group call.
    case joined // = 7

    /// Group Calls: If you declined a ring.
    case declined // = 8

    /// Group Calls: If you are ringing a group.
    case outgoingRing // = 9

    init() {
      self = .unknownEvent
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknownEvent
      case 1: self = .outgoing
      case 2: self = .accepted
      case 3: self = .notAccepted
      case 4: self = .missed
      case 5: self = .delete
      case 6: self = .genericGroupCall
      case 7: self = .joined
      case 8: self = .declined
      case 9: self = .outgoingRing
      default: return nil
      }
    }

    var rawValue: Int {
      switch self {
      case .unknownEvent: return 0
      case .outgoing: return 1
      case .accepted: return 2
      case .notAccepted: return 3
      case .missed: return 4
      case .delete: return 5
      case .genericGroupCall: return 6
      case .joined: return 7
      case .declined: return 8
      case .outgoingRing: return 9
      }
    }

  }

  init() {}

  fileprivate var _callID: UInt64? = nil
  fileprivate var _conversationRecipientID: UInt64? = nil
  fileprivate var _type: BackupProtos_Call.TypeEnum? = nil
  fileprivate var _outgoing: Bool? = nil
  fileprivate var _timestamp: UInt64? = nil
  fileprivate var _ringerRecipientID: UInt64? = nil
  fileprivate var _event: BackupProtos_Call.Event? = nil
}

#if swift(>=4.2)

extension BackupProtos_Call.TypeEnum: CaseIterable {
  // Support synthesized by the compiler.
}

extension BackupProtos_Call.Event: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

struct BackupProtos_ChatItem {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// @required
  var chatID: UInt64 {
    get {return _storage._chatID ?? 0}
    set {_uniqueStorage()._chatID = newValue}
  }
  /// Returns true if `chatID` has been explicitly set.
  var hasChatID: Bool {return _storage._chatID != nil}
  /// Clears the value of `chatID`. Subsequent reads from it will return its default value.
  mutating func clearChatID() {_uniqueStorage()._chatID = nil}

  /// @required
  var authorID: UInt64 {
    get {return _storage._authorID ?? 0}
    set {_uniqueStorage()._authorID = newValue}
  }
  /// Returns true if `authorID` has been explicitly set.
  var hasAuthorID: Bool {return _storage._authorID != nil}
  /// Clears the value of `authorID`. Subsequent reads from it will return its default value.
  mutating func clearAuthorID() {_uniqueStorage()._authorID = nil}

  /// @required
  var dateSent: UInt64 {
    get {return _storage._dateSent ?? 0}
    set {_uniqueStorage()._dateSent = newValue}
  }
  /// Returns true if `dateSent` has been explicitly set.
  var hasDateSent: Bool {return _storage._dateSent != nil}
  /// Clears the value of `dateSent`. Subsequent reads from it will return its default value.
  mutating func clearDateSent() {_uniqueStorage()._dateSent = nil}

  /// @required
  var sealedSender: Bool {
    get {return _storage._sealedSender ?? false}
    set {_uniqueStorage()._sealedSender = newValue}
  }
  /// Returns true if `sealedSender` has been explicitly set.
  var hasSealedSender: Bool {return _storage._sealedSender != nil}
  /// Clears the value of `sealedSender`. Subsequent reads from it will return its default value.
  mutating func clearSealedSender() {_uniqueStorage()._sealedSender = nil}

  /// timestamp of when expiration timer started ticking down
  var expireStartDate: UInt64 {
    get {return _storage._expireStartDate ?? 0}
    set {_uniqueStorage()._expireStartDate = newValue}
  }
  /// Returns true if `expireStartDate` has been explicitly set.
  var hasExpireStartDate: Bool {return _storage._expireStartDate != nil}
  /// Clears the value of `expireStartDate`. Subsequent reads from it will return its default value.
  mutating func clearExpireStartDate() {_uniqueStorage()._expireStartDate = nil}

  /// how long timer of message is (ms)
  var expiresInMs: UInt64 {
    get {return _storage._expiresInMs ?? 0}
    set {_uniqueStorage()._expiresInMs = newValue}
  }
  /// Returns true if `expiresInMs` has been explicitly set.
  var hasExpiresInMs: Bool {return _storage._expiresInMs != nil}
  /// Clears the value of `expiresInMs`. Subsequent reads from it will return its default value.
  mutating func clearExpiresInMs() {_uniqueStorage()._expiresInMs = nil}

  /// ordered from oldest to newest
  var revisions: [BackupProtos_ChatItem] {
    get {return _storage._revisions}
    set {_uniqueStorage()._revisions = newValue}
  }

  /// @required
  var sms: Bool {
    get {return _storage._sms ?? false}
    set {_uniqueStorage()._sms = newValue}
  }
  /// Returns true if `sms` has been explicitly set.
  var hasSms: Bool {return _storage._sms != nil}
  /// Clears the value of `sms`. Subsequent reads from it will return its default value.
  mutating func clearSms() {_uniqueStorage()._sms = nil}

  /// oneof directionalDetails {
  var incoming: BackupProtos_ChatItem.IncomingMessageDetails {
    get {return _storage._incoming ?? BackupProtos_ChatItem.IncomingMessageDetails()}
    set {_uniqueStorage()._incoming = newValue}
  }
  /// Returns true if `incoming` has been explicitly set.
  var hasIncoming: Bool {return _storage._incoming != nil}
  /// Clears the value of `incoming`. Subsequent reads from it will return its default value.
  mutating func clearIncoming() {_uniqueStorage()._incoming = nil}

  var outgoing: BackupProtos_ChatItem.OutgoingMessageDetails {
    get {return _storage._outgoing ?? BackupProtos_ChatItem.OutgoingMessageDetails()}
    set {_uniqueStorage()._outgoing = newValue}
  }
  /// Returns true if `outgoing` has been explicitly set.
  var hasOutgoing: Bool {return _storage._outgoing != nil}
  /// Clears the value of `outgoing`. Subsequent reads from it will return its default value.
  mutating func clearOutgoing() {_uniqueStorage()._outgoing = nil}

  /// }
  var directionless: BackupProtos_ChatItem.DirectionlessMessageDetails {
    get {return _storage._directionless ?? BackupProtos_ChatItem.DirectionlessMessageDetails()}
    set {_uniqueStorage()._directionless = newValue}
  }
  /// Returns true if `directionless` has been explicitly set.
  var hasDirectionless: Bool {return _storage._directionless != nil}
  /// Clears the value of `directionless`. Subsequent reads from it will return its default value.
  mutating func clearDirectionless() {_uniqueStorage()._directionless = nil}

  /// oneof item {
  var standardMessage: BackupProtos_StandardMessage {
    get {return _storage._standardMessage ?? BackupProtos_StandardMessage()}
    set {_uniqueStorage()._standardMessage = newValue}
  }
  /// Returns true if `standardMessage` has been explicitly set.
  var hasStandardMessage: Bool {return _storage._standardMessage != nil}
  /// Clears the value of `standardMessage`. Subsequent reads from it will return its default value.
  mutating func clearStandardMessage() {_uniqueStorage()._standardMessage = nil}

  var contactMessage: BackupProtos_ContactMessage {
    get {return _storage._contactMessage ?? BackupProtos_ContactMessage()}
    set {_uniqueStorage()._contactMessage = newValue}
  }
  /// Returns true if `contactMessage` has been explicitly set.
  var hasContactMessage: Bool {return _storage._contactMessage != nil}
  /// Clears the value of `contactMessage`. Subsequent reads from it will return its default value.
  mutating func clearContactMessage() {_uniqueStorage()._contactMessage = nil}

  var voiceMessage: BackupProtos_VoiceMessage {
    get {return _storage._voiceMessage ?? BackupProtos_VoiceMessage()}
    set {_uniqueStorage()._voiceMessage = newValue}
  }
  /// Returns true if `voiceMessage` has been explicitly set.
  var hasVoiceMessage: Bool {return _storage._voiceMessage != nil}
  /// Clears the value of `voiceMessage`. Subsequent reads from it will return its default value.
  mutating func clearVoiceMessage() {_uniqueStorage()._voiceMessage = nil}

  var stickerMessage: BackupProtos_StickerMessage {
    get {return _storage._stickerMessage ?? BackupProtos_StickerMessage()}
    set {_uniqueStorage()._stickerMessage = newValue}
  }
  /// Returns true if `stickerMessage` has been explicitly set.
  var hasStickerMessage: Bool {return _storage._stickerMessage != nil}
  /// Clears the value of `stickerMessage`. Subsequent reads from it will return its default value.
  mutating func clearStickerMessage() {_uniqueStorage()._stickerMessage = nil}

  var remoteDeletedMessage: BackupProtos_RemoteDeletedMessage {
    get {return _storage._remoteDeletedMessage ?? BackupProtos_RemoteDeletedMessage()}
    set {_uniqueStorage()._remoteDeletedMessage = newValue}
  }
  /// Returns true if `remoteDeletedMessage` has been explicitly set.
  var hasRemoteDeletedMessage: Bool {return _storage._remoteDeletedMessage != nil}
  /// Clears the value of `remoteDeletedMessage`. Subsequent reads from it will return its default value.
  mutating func clearRemoteDeletedMessage() {_uniqueStorage()._remoteDeletedMessage = nil}

  /// }
  var updateMessage: BackupProtos_ChatUpdateMessage {
    get {return _storage._updateMessage ?? BackupProtos_ChatUpdateMessage()}
    set {_uniqueStorage()._updateMessage = newValue}
  }
  /// Returns true if `updateMessage` has been explicitly set.
  var hasUpdateMessage: Bool {return _storage._updateMessage != nil}
  /// Clears the value of `updateMessage`. Subsequent reads from it will return its default value.
  mutating func clearUpdateMessage() {_uniqueStorage()._updateMessage = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct IncomingMessageDetails {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// @required
    var dateReceived: UInt64 {
      get {return _dateReceived ?? 0}
      set {_dateReceived = newValue}
    }
    /// Returns true if `dateReceived` has been explicitly set.
    var hasDateReceived: Bool {return self._dateReceived != nil}
    /// Clears the value of `dateReceived`. Subsequent reads from it will return its default value.
    mutating func clearDateReceived() {self._dateReceived = nil}

    /// @required
    var dateServerSent: UInt64 {
      get {return _dateServerSent ?? 0}
      set {_dateServerSent = newValue}
    }
    /// Returns true if `dateServerSent` has been explicitly set.
    var hasDateServerSent: Bool {return self._dateServerSent != nil}
    /// Clears the value of `dateServerSent`. Subsequent reads from it will return its default value.
    mutating func clearDateServerSent() {self._dateServerSent = nil}

    /// @required
    var read: Bool {
      get {return _read ?? false}
      set {_read = newValue}
    }
    /// Returns true if `read` has been explicitly set.
    var hasRead: Bool {return self._read != nil}
    /// Clears the value of `read`. Subsequent reads from it will return its default value.
    mutating func clearRead() {self._read = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _dateReceived: UInt64? = nil
    fileprivate var _dateServerSent: UInt64? = nil
    fileprivate var _read: Bool? = nil
  }

  struct OutgoingMessageDetails {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var sendStatus: [BackupProtos_SendStatus] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct DirectionlessMessageDetails {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct BackupProtos_SendStatus {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// @required
  var recipientID: UInt64 {
    get {return _recipientID ?? 0}
    set {_recipientID = newValue}
  }
  /// Returns true if `recipientID` has been explicitly set.
  var hasRecipientID: Bool {return self._recipientID != nil}
  /// Clears the value of `recipientID`. Subsequent reads from it will return its default value.
  mutating func clearRecipientID() {self._recipientID = nil}

  var deliveryStatus: BackupProtos_SendStatus.Status {
    get {return _deliveryStatus ?? .unknown}
    set {_deliveryStatus = newValue}
  }
  /// Returns true if `deliveryStatus` has been explicitly set.
  var hasDeliveryStatus: Bool {return self._deliveryStatus != nil}
  /// Clears the value of `deliveryStatus`. Subsequent reads from it will return its default value.
  mutating func clearDeliveryStatus() {self._deliveryStatus = nil}

  /// @required
  var networkFailure: Bool {
    get {return _networkFailure ?? false}
    set {_networkFailure = newValue}
  }
  /// Returns true if `networkFailure` has been explicitly set.
  var hasNetworkFailure: Bool {return self._networkFailure != nil}
  /// Clears the value of `networkFailure`. Subsequent reads from it will return its default value.
  mutating func clearNetworkFailure() {self._networkFailure = nil}

  /// @required
  var identityKeyMismatch: Bool {
    get {return _identityKeyMismatch ?? false}
    set {_identityKeyMismatch = newValue}
  }
  /// Returns true if `identityKeyMismatch` has been explicitly set.
  var hasIdentityKeyMismatch: Bool {return self._identityKeyMismatch != nil}
  /// Clears the value of `identityKeyMismatch`. Subsequent reads from it will return its default value.
  mutating func clearIdentityKeyMismatch() {self._identityKeyMismatch = nil}

  /// @required
  var sealedSender: Bool {
    get {return _sealedSender ?? false}
    set {_sealedSender = newValue}
  }
  /// Returns true if `sealedSender` has been explicitly set.
  var hasSealedSender: Bool {return self._sealedSender != nil}
  /// Clears the value of `sealedSender`. Subsequent reads from it will return its default value.
  mutating func clearSealedSender() {self._sealedSender = nil}

  /// @required
  var lastStatusUpdateTimestamp: UInt64 {
    get {return _lastStatusUpdateTimestamp ?? 0}
    set {_lastStatusUpdateTimestamp = newValue}
  }
  /// Returns true if `lastStatusUpdateTimestamp` has been explicitly set.
  var hasLastStatusUpdateTimestamp: Bool {return self._lastStatusUpdateTimestamp != nil}
  /// Clears the value of `lastStatusUpdateTimestamp`. Subsequent reads from it will return its default value.
  mutating func clearLastStatusUpdateTimestamp() {self._lastStatusUpdateTimestamp = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum Status: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case unknown // = 0
    case failed // = 1
    case pending // = 2
    case sent // = 3
    case delivered // = 4
    case read // = 5
    case viewed // = 6

    /// e.g. user in group was blocked, so we skipped sending to them
    case skipped // = 7

    init() {
      self = .unknown
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknown
      case 1: self = .failed
      case 2: self = .pending
      case 3: self = .sent
      case 4: self = .delivered
      case 5: self = .read
      case 6: self = .viewed
      case 7: self = .skipped
      default: return nil
      }
    }

    var rawValue: Int {
      switch self {
      case .unknown: return 0
      case .failed: return 1
      case .pending: return 2
      case .sent: return 3
      case .delivered: return 4
      case .read: return 5
      case .viewed: return 6
      case .skipped: return 7
      }
    }

  }

  init() {}

  fileprivate var _recipientID: UInt64? = nil
  fileprivate var _deliveryStatus: BackupProtos_SendStatus.Status? = nil
  fileprivate var _networkFailure: Bool? = nil
  fileprivate var _identityKeyMismatch: Bool? = nil
  fileprivate var _sealedSender: Bool? = nil
  fileprivate var _lastStatusUpdateTimestamp: UInt64? = nil
}

#if swift(>=4.2)

extension BackupProtos_SendStatus.Status: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

struct BackupProtos_Text {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// @required
  var body: String {
    get {return _body ?? String()}
    set {_body = newValue}
  }
  /// Returns true if `body` has been explicitly set.
  var hasBody: Bool {return self._body != nil}
  /// Clears the value of `body`. Subsequent reads from it will return its default value.
  mutating func clearBody() {self._body = nil}

  var bodyRanges: [BackupProtos_BodyRange] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _body: String? = nil
}

struct BackupProtos_StandardMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var quote: BackupProtos_Quote {
    get {return _quote ?? BackupProtos_Quote()}
    set {_quote = newValue}
  }
  /// Returns true if `quote` has been explicitly set.
  var hasQuote: Bool {return self._quote != nil}
  /// Clears the value of `quote`. Subsequent reads from it will return its default value.
  mutating func clearQuote() {self._quote = nil}

  var text: BackupProtos_Text {
    get {return _text ?? BackupProtos_Text()}
    set {_text = newValue}
  }
  /// Returns true if `text` has been explicitly set.
  var hasText: Bool {return self._text != nil}
  /// Clears the value of `text`. Subsequent reads from it will return its default value.
  mutating func clearText() {self._text = nil}

  var attachments: [BackupProtos_FilePointer] = []

  var linkPreview: [BackupProtos_LinkPreview] = []

  var longText: BackupProtos_FilePointer {
    get {return _longText ?? BackupProtos_FilePointer()}
    set {_longText = newValue}
  }
  /// Returns true if `longText` has been explicitly set.
  var hasLongText: Bool {return self._longText != nil}
  /// Clears the value of `longText`. Subsequent reads from it will return its default value.
  mutating func clearLongText() {self._longText = nil}

  var reactions: [BackupProtos_Reaction] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _quote: BackupProtos_Quote? = nil
  fileprivate var _text: BackupProtos_Text? = nil
  fileprivate var _longText: BackupProtos_FilePointer? = nil
}

struct BackupProtos_ContactMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var contact: [BackupProtos_ContactAttachment] = []

  var reactions: [BackupProtos_Reaction] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct BackupProtos_ContactAttachment {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var name: BackupProtos_ContactAttachment.Name {
    get {return _name ?? BackupProtos_ContactAttachment.Name()}
    set {_name = newValue}
  }
  /// Returns true if `name` has been explicitly set.
  var hasName: Bool {return self._name != nil}
  /// Clears the value of `name`. Subsequent reads from it will return its default value.
  mutating func clearName() {self._name = nil}

  var number: [BackupProtos_ContactAttachment.Phone] = []

  var email: [BackupProtos_ContactAttachment.Email] = []

  var address: [BackupProtos_ContactAttachment.PostalAddress] = []

  var avatar: BackupProtos_ContactAttachment.Avatar {
    get {return _avatar ?? BackupProtos_ContactAttachment.Avatar()}
    set {_avatar = newValue}
  }
  /// Returns true if `avatar` has been explicitly set.
  var hasAvatar: Bool {return self._avatar != nil}
  /// Clears the value of `avatar`. Subsequent reads from it will return its default value.
  mutating func clearAvatar() {self._avatar = nil}

  var organization: String {
    get {return _organization ?? String()}
    set {_organization = newValue}
  }
  /// Returns true if `organization` has been explicitly set.
  var hasOrganization: Bool {return self._organization != nil}
  /// Clears the value of `organization`. Subsequent reads from it will return its default value.
  mutating func clearOrganization() {self._organization = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct Name {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var givenName: String {
      get {return _givenName ?? String()}
      set {_givenName = newValue}
    }
    /// Returns true if `givenName` has been explicitly set.
    var hasGivenName: Bool {return self._givenName != nil}
    /// Clears the value of `givenName`. Subsequent reads from it will return its default value.
    mutating func clearGivenName() {self._givenName = nil}

    var familyName: String {
      get {return _familyName ?? String()}
      set {_familyName = newValue}
    }
    /// Returns true if `familyName` has been explicitly set.
    var hasFamilyName: Bool {return self._familyName != nil}
    /// Clears the value of `familyName`. Subsequent reads from it will return its default value.
    mutating func clearFamilyName() {self._familyName = nil}

    var prefix: String {
      get {return _prefix ?? String()}
      set {_prefix = newValue}
    }
    /// Returns true if `prefix` has been explicitly set.
    var hasPrefix: Bool {return self._prefix != nil}
    /// Clears the value of `prefix`. Subsequent reads from it will return its default value.
    mutating func clearPrefix() {self._prefix = nil}

    var suffix: String {
      get {return _suffix ?? String()}
      set {_suffix = newValue}
    }
    /// Returns true if `suffix` has been explicitly set.
    var hasSuffix: Bool {return self._suffix != nil}
    /// Clears the value of `suffix`. Subsequent reads from it will return its default value.
    mutating func clearSuffix() {self._suffix = nil}

    var middleName: String {
      get {return _middleName ?? String()}
      set {_middleName = newValue}
    }
    /// Returns true if `middleName` has been explicitly set.
    var hasMiddleName: Bool {return self._middleName != nil}
    /// Clears the value of `middleName`. Subsequent reads from it will return its default value.
    mutating func clearMiddleName() {self._middleName = nil}

    var displayName: String {
      get {return _displayName ?? String()}
      set {_displayName = newValue}
    }
    /// Returns true if `displayName` has been explicitly set.
    var hasDisplayName: Bool {return self._displayName != nil}
    /// Clears the value of `displayName`. Subsequent reads from it will return its default value.
    mutating func clearDisplayName() {self._displayName = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _givenName: String? = nil
    fileprivate var _familyName: String? = nil
    fileprivate var _prefix: String? = nil
    fileprivate var _suffix: String? = nil
    fileprivate var _middleName: String? = nil
    fileprivate var _displayName: String? = nil
  }

  struct Phone {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var value: String {
      get {return _value ?? String()}
      set {_value = newValue}
    }
    /// Returns true if `value` has been explicitly set.
    var hasValue: Bool {return self._value != nil}
    /// Clears the value of `value`. Subsequent reads from it will return its default value.
    mutating func clearValue() {self._value = nil}

    var type: BackupProtos_ContactAttachment.Phone.TypeEnum {
      get {return _type ?? .unknown}
      set {_type = newValue}
    }
    /// Returns true if `type` has been explicitly set.
    var hasType: Bool {return self._type != nil}
    /// Clears the value of `type`. Subsequent reads from it will return its default value.
    mutating func clearType() {self._type = nil}

    var label: String {
      get {return _label ?? String()}
      set {_label = newValue}
    }
    /// Returns true if `label` has been explicitly set.
    var hasLabel: Bool {return self._label != nil}
    /// Clears the value of `label`. Subsequent reads from it will return its default value.
    mutating func clearLabel() {self._label = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum TypeEnum: SwiftProtobuf.Enum {
      typealias RawValue = Int
      case unknown // = 0
      case home // = 1
      case mobile // = 2
      case work // = 3
      case custom // = 4

      init() {
        self = .unknown
      }

      init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .unknown
        case 1: self = .home
        case 2: self = .mobile
        case 3: self = .work
        case 4: self = .custom
        default: return nil
        }
      }

      var rawValue: Int {
        switch self {
        case .unknown: return 0
        case .home: return 1
        case .mobile: return 2
        case .work: return 3
        case .custom: return 4
        }
      }

    }

    init() {}

    fileprivate var _value: String? = nil
    fileprivate var _type: BackupProtos_ContactAttachment.Phone.TypeEnum? = nil
    fileprivate var _label: String? = nil
  }

  struct Email {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var value: String {
      get {return _value ?? String()}
      set {_value = newValue}
    }
    /// Returns true if `value` has been explicitly set.
    var hasValue: Bool {return self._value != nil}
    /// Clears the value of `value`. Subsequent reads from it will return its default value.
    mutating func clearValue() {self._value = nil}

    var type: BackupProtos_ContactAttachment.Email.TypeEnum {
      get {return _type ?? .unknown}
      set {_type = newValue}
    }
    /// Returns true if `type` has been explicitly set.
    var hasType: Bool {return self._type != nil}
    /// Clears the value of `type`. Subsequent reads from it will return its default value.
    mutating func clearType() {self._type = nil}

    var label: String {
      get {return _label ?? String()}
      set {_label = newValue}
    }
    /// Returns true if `label` has been explicitly set.
    var hasLabel: Bool {return self._label != nil}
    /// Clears the value of `label`. Subsequent reads from it will return its default value.
    mutating func clearLabel() {self._label = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum TypeEnum: SwiftProtobuf.Enum {
      typealias RawValue = Int
      case unknown // = 0
      case home // = 1
      case mobile // = 2
      case work // = 3
      case custom // = 4

      init() {
        self = .unknown
      }

      init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .unknown
        case 1: self = .home
        case 2: self = .mobile
        case 3: self = .work
        case 4: self = .custom
        default: return nil
        }
      }

      var rawValue: Int {
        switch self {
        case .unknown: return 0
        case .home: return 1
        case .mobile: return 2
        case .work: return 3
        case .custom: return 4
        }
      }

    }

    init() {}

    fileprivate var _value: String? = nil
    fileprivate var _type: BackupProtos_ContactAttachment.Email.TypeEnum? = nil
    fileprivate var _label: String? = nil
  }

  struct PostalAddress {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var type: BackupProtos_ContactAttachment.PostalAddress.TypeEnum {
      get {return _type ?? .unknown}
      set {_type = newValue}
    }
    /// Returns true if `type` has been explicitly set.
    var hasType: Bool {return self._type != nil}
    /// Clears the value of `type`. Subsequent reads from it will return its default value.
    mutating func clearType() {self._type = nil}

    var label: String {
      get {return _label ?? String()}
      set {_label = newValue}
    }
    /// Returns true if `label` has been explicitly set.
    var hasLabel: Bool {return self._label != nil}
    /// Clears the value of `label`. Subsequent reads from it will return its default value.
    mutating func clearLabel() {self._label = nil}

    var street: String {
      get {return _street ?? String()}
      set {_street = newValue}
    }
    /// Returns true if `street` has been explicitly set.
    var hasStreet: Bool {return self._street != nil}
    /// Clears the value of `street`. Subsequent reads from it will return its default value.
    mutating func clearStreet() {self._street = nil}

    var pobox: String {
      get {return _pobox ?? String()}
      set {_pobox = newValue}
    }
    /// Returns true if `pobox` has been explicitly set.
    var hasPobox: Bool {return self._pobox != nil}
    /// Clears the value of `pobox`. Subsequent reads from it will return its default value.
    mutating func clearPobox() {self._pobox = nil}

    var neighborhood: String {
      get {return _neighborhood ?? String()}
      set {_neighborhood = newValue}
    }
    /// Returns true if `neighborhood` has been explicitly set.
    var hasNeighborhood: Bool {return self._neighborhood != nil}
    /// Clears the value of `neighborhood`. Subsequent reads from it will return its default value.
    mutating func clearNeighborhood() {self._neighborhood = nil}

    var city: String {
      get {return _city ?? String()}
      set {_city = newValue}
    }
    /// Returns true if `city` has been explicitly set.
    var hasCity: Bool {return self._city != nil}
    /// Clears the value of `city`. Subsequent reads from it will return its default value.
    mutating func clearCity() {self._city = nil}

    var region: String {
      get {return _region ?? String()}
      set {_region = newValue}
    }
    /// Returns true if `region` has been explicitly set.
    var hasRegion: Bool {return self._region != nil}
    /// Clears the value of `region`. Subsequent reads from it will return its default value.
    mutating func clearRegion() {self._region = nil}

    var postcode: String {
      get {return _postcode ?? String()}
      set {_postcode = newValue}
    }
    /// Returns true if `postcode` has been explicitly set.
    var hasPostcode: Bool {return self._postcode != nil}
    /// Clears the value of `postcode`. Subsequent reads from it will return its default value.
    mutating func clearPostcode() {self._postcode = nil}

    var country: String {
      get {return _country ?? String()}
      set {_country = newValue}
    }
    /// Returns true if `country` has been explicitly set.
    var hasCountry: Bool {return self._country != nil}
    /// Clears the value of `country`. Subsequent reads from it will return its default value.
    mutating func clearCountry() {self._country = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum TypeEnum: SwiftProtobuf.Enum {
      typealias RawValue = Int
      case unknown // = 0
      case home // = 1
      case work // = 2
      case custom // = 3

      init() {
        self = .unknown
      }

      init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .unknown
        case 1: self = .home
        case 2: self = .work
        case 3: self = .custom
        default: return nil
        }
      }

      var rawValue: Int {
        switch self {
        case .unknown: return 0
        case .home: return 1
        case .work: return 2
        case .custom: return 3
        }
      }

    }

    init() {}

    fileprivate var _type: BackupProtos_ContactAttachment.PostalAddress.TypeEnum? = nil
    fileprivate var _label: String? = nil
    fileprivate var _street: String? = nil
    fileprivate var _pobox: String? = nil
    fileprivate var _neighborhood: String? = nil
    fileprivate var _city: String? = nil
    fileprivate var _region: String? = nil
    fileprivate var _postcode: String? = nil
    fileprivate var _country: String? = nil
  }

  struct Avatar {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// @required
    var avatar: BackupProtos_FilePointer {
      get {return _avatar ?? BackupProtos_FilePointer()}
      set {_avatar = newValue}
    }
    /// Returns true if `avatar` has been explicitly set.
    var hasAvatar: Bool {return self._avatar != nil}
    /// Clears the value of `avatar`. Subsequent reads from it will return its default value.
    mutating func clearAvatar() {self._avatar = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _avatar: BackupProtos_FilePointer? = nil
  }

  init() {}

  fileprivate var _name: BackupProtos_ContactAttachment.Name? = nil
  fileprivate var _avatar: BackupProtos_ContactAttachment.Avatar? = nil
  fileprivate var _organization: String? = nil
}

#if swift(>=4.2)

extension BackupProtos_ContactAttachment.Phone.TypeEnum: CaseIterable {
  // Support synthesized by the compiler.
}

extension BackupProtos_ContactAttachment.Email.TypeEnum: CaseIterable {
  // Support synthesized by the compiler.
}

extension BackupProtos_ContactAttachment.PostalAddress.TypeEnum: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

struct BackupProtos_DocumentMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// @required
  var text: BackupProtos_Text {
    get {return _text ?? BackupProtos_Text()}
    set {_text = newValue}
  }
  /// Returns true if `text` has been explicitly set.
  var hasText: Bool {return self._text != nil}
  /// Clears the value of `text`. Subsequent reads from it will return its default value.
  mutating func clearText() {self._text = nil}

  /// @required
  var document: BackupProtos_FilePointer {
    get {return _document ?? BackupProtos_FilePointer()}
    set {_document = newValue}
  }
  /// Returns true if `document` has been explicitly set.
  var hasDocument: Bool {return self._document != nil}
  /// Clears the value of `document`. Subsequent reads from it will return its default value.
  mutating func clearDocument() {self._document = nil}

  var reactions: [BackupProtos_Reaction] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _text: BackupProtos_Text? = nil
  fileprivate var _document: BackupProtos_FilePointer? = nil
}

struct BackupProtos_VoiceMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var quote: BackupProtos_Quote {
    get {return _quote ?? BackupProtos_Quote()}
    set {_quote = newValue}
  }
  /// Returns true if `quote` has been explicitly set.
  var hasQuote: Bool {return self._quote != nil}
  /// Clears the value of `quote`. Subsequent reads from it will return its default value.
  mutating func clearQuote() {self._quote = nil}

  /// @required
  var audio: BackupProtos_FilePointer {
    get {return _audio ?? BackupProtos_FilePointer()}
    set {_audio = newValue}
  }
  /// Returns true if `audio` has been explicitly set.
  var hasAudio: Bool {return self._audio != nil}
  /// Clears the value of `audio`. Subsequent reads from it will return its default value.
  mutating func clearAudio() {self._audio = nil}

  var reactions: [BackupProtos_Reaction] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _quote: BackupProtos_Quote? = nil
  fileprivate var _audio: BackupProtos_FilePointer? = nil
}

struct BackupProtos_StickerMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// @required
  var sticker: BackupProtos_Sticker {
    get {return _sticker ?? BackupProtos_Sticker()}
    set {_sticker = newValue}
  }
  /// Returns true if `sticker` has been explicitly set.
  var hasSticker: Bool {return self._sticker != nil}
  /// Clears the value of `sticker`. Subsequent reads from it will return its default value.
  mutating func clearSticker() {self._sticker = nil}

  var reactions: [BackupProtos_Reaction] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _sticker: BackupProtos_Sticker? = nil
}

/// Tombstone for remote delete
struct BackupProtos_RemoteDeletedMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct BackupProtos_Sticker {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// @required
  var packID: Data {
    get {return _packID ?? Data()}
    set {_packID = newValue}
  }
  /// Returns true if `packID` has been explicitly set.
  var hasPackID: Bool {return self._packID != nil}
  /// Clears the value of `packID`. Subsequent reads from it will return its default value.
  mutating func clearPackID() {self._packID = nil}

  /// @required
  var packKey: Data {
    get {return _packKey ?? Data()}
    set {_packKey = newValue}
  }
  /// Returns true if `packKey` has been explicitly set.
  var hasPackKey: Bool {return self._packKey != nil}
  /// Clears the value of `packKey`. Subsequent reads from it will return its default value.
  mutating func clearPackKey() {self._packKey = nil}

  /// @required
  var stickerID: UInt32 {
    get {return _stickerID ?? 0}
    set {_stickerID = newValue}
  }
  /// Returns true if `stickerID` has been explicitly set.
  var hasStickerID: Bool {return self._stickerID != nil}
  /// Clears the value of `stickerID`. Subsequent reads from it will return its default value.
  mutating func clearStickerID() {self._stickerID = nil}

  var emoji: String {
    get {return _emoji ?? String()}
    set {_emoji = newValue}
  }
  /// Returns true if `emoji` has been explicitly set.
  var hasEmoji: Bool {return self._emoji != nil}
  /// Clears the value of `emoji`. Subsequent reads from it will return its default value.
  mutating func clearEmoji() {self._emoji = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _packID: Data? = nil
  fileprivate var _packKey: Data? = nil
  fileprivate var _stickerID: UInt32? = nil
  fileprivate var _emoji: String? = nil
}

struct BackupProtos_LinkPreview {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// @required
  var url: String {
    get {return _url ?? String()}
    set {_url = newValue}
  }
  /// Returns true if `url` has been explicitly set.
  var hasURL: Bool {return self._url != nil}
  /// Clears the value of `url`. Subsequent reads from it will return its default value.
  mutating func clearURL() {self._url = nil}

  var title: String {
    get {return _title ?? String()}
    set {_title = newValue}
  }
  /// Returns true if `title` has been explicitly set.
  var hasTitle: Bool {return self._title != nil}
  /// Clears the value of `title`. Subsequent reads from it will return its default value.
  mutating func clearTitle() {self._title = nil}

  var image: BackupProtos_FilePointer {
    get {return _image ?? BackupProtos_FilePointer()}
    set {_image = newValue}
  }
  /// Returns true if `image` has been explicitly set.
  var hasImage: Bool {return self._image != nil}
  /// Clears the value of `image`. Subsequent reads from it will return its default value.
  mutating func clearImage() {self._image = nil}

  /// 'description' collides with NSObject.description
  var descriptionText: String {
    get {return _descriptionText ?? String()}
    set {_descriptionText = newValue}
  }
  /// Returns true if `descriptionText` has been explicitly set.
  var hasDescriptionText: Bool {return self._descriptionText != nil}
  /// Clears the value of `descriptionText`. Subsequent reads from it will return its default value.
  mutating func clearDescriptionText() {self._descriptionText = nil}

  var date: UInt64 {
    get {return _date ?? 0}
    set {_date = newValue}
  }
  /// Returns true if `date` has been explicitly set.
  var hasDate: Bool {return self._date != nil}
  /// Clears the value of `date`. Subsequent reads from it will return its default value.
  mutating func clearDate() {self._date = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _url: String? = nil
  fileprivate var _title: String? = nil
  fileprivate var _image: BackupProtos_FilePointer? = nil
  fileprivate var _descriptionText: String? = nil
  fileprivate var _date: UInt64? = nil
}

struct BackupProtos_FilePointer {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// oneof locator {
  var backupLocator: BackupProtos_FilePointer.BackupLocator {
    get {return _storage._backupLocator ?? BackupProtos_FilePointer.BackupLocator()}
    set {_uniqueStorage()._backupLocator = newValue}
  }
  /// Returns true if `backupLocator` has been explicitly set.
  var hasBackupLocator: Bool {return _storage._backupLocator != nil}
  /// Clears the value of `backupLocator`. Subsequent reads from it will return its default value.
  mutating func clearBackupLocator() {_uniqueStorage()._backupLocator = nil}

  var attachmentLocator: BackupProtos_FilePointer.AttachmentLocator {
    get {return _storage._attachmentLocator ?? BackupProtos_FilePointer.AttachmentLocator()}
    set {_uniqueStorage()._attachmentLocator = newValue}
  }
  /// Returns true if `attachmentLocator` has been explicitly set.
  var hasAttachmentLocator: Bool {return _storage._attachmentLocator != nil}
  /// Clears the value of `attachmentLocator`. Subsequent reads from it will return its default value.
  mutating func clearAttachmentLocator() {_uniqueStorage()._attachmentLocator = nil}

  var legacyAttachmentLocator: BackupProtos_FilePointer.LegacyAttachmentLocator {
    get {return _storage._legacyAttachmentLocator ?? BackupProtos_FilePointer.LegacyAttachmentLocator()}
    set {_uniqueStorage()._legacyAttachmentLocator = newValue}
  }
  /// Returns true if `legacyAttachmentLocator` has been explicitly set.
  var hasLegacyAttachmentLocator: Bool {return _storage._legacyAttachmentLocator != nil}
  /// Clears the value of `legacyAttachmentLocator`. Subsequent reads from it will return its default value.
  mutating func clearLegacyAttachmentLocator() {_uniqueStorage()._legacyAttachmentLocator = nil}

  /// }
  var undownloadedBackupLocator: BackupProtos_FilePointer.UndownloadedBackupLocator {
    get {return _storage._undownloadedBackupLocator ?? BackupProtos_FilePointer.UndownloadedBackupLocator()}
    set {_uniqueStorage()._undownloadedBackupLocator = newValue}
  }
  /// Returns true if `undownloadedBackupLocator` has been explicitly set.
  var hasUndownloadedBackupLocator: Bool {return _storage._undownloadedBackupLocator != nil}
  /// Clears the value of `undownloadedBackupLocator`. Subsequent reads from it will return its default value.
  mutating func clearUndownloadedBackupLocator() {_uniqueStorage()._undownloadedBackupLocator = nil}

  var key: Data {
    get {return _storage._key ?? Data()}
    set {_uniqueStorage()._key = newValue}
  }
  /// Returns true if `key` has been explicitly set.
  var hasKey: Bool {return _storage._key != nil}
  /// Clears the value of `key`. Subsequent reads from it will return its default value.
  mutating func clearKey() {_uniqueStorage()._key = nil}

  var contentType: String {
    get {return _storage._contentType ?? String()}
    set {_uniqueStorage()._contentType = newValue}
  }
  /// Returns true if `contentType` has been explicitly set.
  var hasContentType: Bool {return _storage._contentType != nil}
  /// Clears the value of `contentType`. Subsequent reads from it will return its default value.
  mutating func clearContentType() {_uniqueStorage()._contentType = nil}

  /// Size of fullsize decrypted media blob in bytes.
  /// Can be ignored if unset/unavailable.
  var size: UInt32 {
    get {return _storage._size ?? 0}
    set {_uniqueStorage()._size = newValue}
  }
  /// Returns true if `size` has been explicitly set.
  var hasSize: Bool {return _storage._size != nil}
  /// Clears the value of `size`. Subsequent reads from it will return its default value.
  mutating func clearSize() {_uniqueStorage()._size = nil}

  var incrementalMac: Data {
    get {return _storage._incrementalMac ?? Data()}
    set {_uniqueStorage()._incrementalMac = newValue}
  }
  /// Returns true if `incrementalMac` has been explicitly set.
  var hasIncrementalMac: Bool {return _storage._incrementalMac != nil}
  /// Clears the value of `incrementalMac`. Subsequent reads from it will return its default value.
  mutating func clearIncrementalMac() {_uniqueStorage()._incrementalMac = nil}

  var incrementalMacChunkSize: Data {
    get {return _storage._incrementalMacChunkSize ?? Data()}
    set {_uniqueStorage()._incrementalMacChunkSize = newValue}
  }
  /// Returns true if `incrementalMacChunkSize` has been explicitly set.
  var hasIncrementalMacChunkSize: Bool {return _storage._incrementalMacChunkSize != nil}
  /// Clears the value of `incrementalMacChunkSize`. Subsequent reads from it will return its default value.
  mutating func clearIncrementalMacChunkSize() {_uniqueStorage()._incrementalMacChunkSize = nil}

  var fileName: String {
    get {return _storage._fileName ?? String()}
    set {_uniqueStorage()._fileName = newValue}
  }
  /// Returns true if `fileName` has been explicitly set.
  var hasFileName: Bool {return _storage._fileName != nil}
  /// Clears the value of `fileName`. Subsequent reads from it will return its default value.
  mutating func clearFileName() {_uniqueStorage()._fileName = nil}

  var flags: UInt32 {
    get {return _storage._flags ?? 0}
    set {_uniqueStorage()._flags = newValue}
  }
  /// Returns true if `flags` has been explicitly set.
  var hasFlags: Bool {return _storage._flags != nil}
  /// Clears the value of `flags`. Subsequent reads from it will return its default value.
  mutating func clearFlags() {_uniqueStorage()._flags = nil}

  var width: UInt32 {
    get {return _storage._width ?? 0}
    set {_uniqueStorage()._width = newValue}
  }
  /// Returns true if `width` has been explicitly set.
  var hasWidth: Bool {return _storage._width != nil}
  /// Clears the value of `width`. Subsequent reads from it will return its default value.
  mutating func clearWidth() {_uniqueStorage()._width = nil}

  var height: UInt32 {
    get {return _storage._height ?? 0}
    set {_uniqueStorage()._height = newValue}
  }
  /// Returns true if `height` has been explicitly set.
  var hasHeight: Bool {return _storage._height != nil}
  /// Clears the value of `height`. Subsequent reads from it will return its default value.
  mutating func clearHeight() {_uniqueStorage()._height = nil}

  var caption: String {
    get {return _storage._caption ?? String()}
    set {_uniqueStorage()._caption = newValue}
  }
  /// Returns true if `caption` has been explicitly set.
  var hasCaption: Bool {return _storage._caption != nil}
  /// Clears the value of `caption`. Subsequent reads from it will return its default value.
  mutating func clearCaption() {_uniqueStorage()._caption = nil}

  var blurHash: String {
    get {return _storage._blurHash ?? String()}
    set {_uniqueStorage()._blurHash = newValue}
  }
  /// Returns true if `blurHash` has been explicitly set.
  var hasBlurHash: Bool {return _storage._blurHash != nil}
  /// Clears the value of `blurHash`. Subsequent reads from it will return its default value.
  mutating func clearBlurHash() {_uniqueStorage()._blurHash = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum Flags: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case voiceMessage // = 0
    case borderless // = 1
    case gif // = 2

    init() {
      self = .voiceMessage
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .voiceMessage
      case 1: self = .borderless
      case 2: self = .gif
      default: return nil
      }
    }

    var rawValue: Int {
      switch self {
      case .voiceMessage: return 0
      case .borderless: return 1
      case .gif: return 2
      }
    }

  }

  struct BackupLocator {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// @required
    var mediaName: String {
      get {return _mediaName ?? String()}
      set {_mediaName = newValue}
    }
    /// Returns true if `mediaName` has been explicitly set.
    var hasMediaName: Bool {return self._mediaName != nil}
    /// Clears the value of `mediaName`. Subsequent reads from it will return its default value.
    mutating func clearMediaName() {self._mediaName = nil}

    /// @required
    var cdnNumber: UInt32 {
      get {return _cdnNumber ?? 0}
      set {_cdnNumber = newValue}
    }
    /// Returns true if `cdnNumber` has been explicitly set.
    var hasCdnNumber: Bool {return self._cdnNumber != nil}
    /// Clears the value of `cdnNumber`. Subsequent reads from it will return its default value.
    mutating func clearCdnNumber() {self._cdnNumber = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _mediaName: String? = nil
    fileprivate var _cdnNumber: UInt32? = nil
  }

  struct AttachmentLocator {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// @required
    var cdnKey: String {
      get {return _cdnKey ?? String()}
      set {_cdnKey = newValue}
    }
    /// Returns true if `cdnKey` has been explicitly set.
    var hasCdnKey: Bool {return self._cdnKey != nil}
    /// Clears the value of `cdnKey`. Subsequent reads from it will return its default value.
    mutating func clearCdnKey() {self._cdnKey = nil}

    /// @required
    var cdnNumber: UInt32 {
      get {return _cdnNumber ?? 0}
      set {_cdnNumber = newValue}
    }
    /// Returns true if `cdnNumber` has been explicitly set.
    var hasCdnNumber: Bool {return self._cdnNumber != nil}
    /// Clears the value of `cdnNumber`. Subsequent reads from it will return its default value.
    mutating func clearCdnNumber() {self._cdnNumber = nil}

    /// @required
    var uploadTimestamp: UInt64 {
      get {return _uploadTimestamp ?? 0}
      set {_uploadTimestamp = newValue}
    }
    /// Returns true if `uploadTimestamp` has been explicitly set.
    var hasUploadTimestamp: Bool {return self._uploadTimestamp != nil}
    /// Clears the value of `uploadTimestamp`. Subsequent reads from it will return its default value.
    mutating func clearUploadTimestamp() {self._uploadTimestamp = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _cdnKey: String? = nil
    fileprivate var _cdnNumber: UInt32? = nil
    fileprivate var _uploadTimestamp: UInt64? = nil
  }

  struct LegacyAttachmentLocator {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// @required
    var cdnID: UInt64 {
      get {return _cdnID ?? 0}
      set {_cdnID = newValue}
    }
    /// Returns true if `cdnID` has been explicitly set.
    var hasCdnID: Bool {return self._cdnID != nil}
    /// Clears the value of `cdnID`. Subsequent reads from it will return its default value.
    mutating func clearCdnID() {self._cdnID = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _cdnID: UInt64? = nil
  }

  /// An attachment that was backed up without being downloaded.
  /// Its MediaName should be generated as {sender_aci}_{cdn_attachment_key},
  /// but should eventually transition to a BackupLocator with mediaName
  /// being the content hash once it is downloaded.
  struct UndownloadedBackupLocator {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// @required
    var senderAci: Data {
      get {return _senderAci ?? Data()}
      set {_senderAci = newValue}
    }
    /// Returns true if `senderAci` has been explicitly set.
    var hasSenderAci: Bool {return self._senderAci != nil}
    /// Clears the value of `senderAci`. Subsequent reads from it will return its default value.
    mutating func clearSenderAci() {self._senderAci = nil}

    /// @required
    var cdnKey: String {
      get {return _cdnKey ?? String()}
      set {_cdnKey = newValue}
    }
    /// Returns true if `cdnKey` has been explicitly set.
    var hasCdnKey: Bool {return self._cdnKey != nil}
    /// Clears the value of `cdnKey`. Subsequent reads from it will return its default value.
    mutating func clearCdnKey() {self._cdnKey = nil}

    /// @required
    var cdnNumber: UInt32 {
      get {return _cdnNumber ?? 0}
      set {_cdnNumber = newValue}
    }
    /// Returns true if `cdnNumber` has been explicitly set.
    var hasCdnNumber: Bool {return self._cdnNumber != nil}
    /// Clears the value of `cdnNumber`. Subsequent reads from it will return its default value.
    mutating func clearCdnNumber() {self._cdnNumber = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _senderAci: Data? = nil
    fileprivate var _cdnKey: String? = nil
    fileprivate var _cdnNumber: UInt32? = nil
  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

#if swift(>=4.2)

extension BackupProtos_FilePointer.Flags: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

struct BackupProtos_Quote {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// null if the target message could not be found at time of quote insert
  var targetSentTimestamp: UInt64 {
    get {return _targetSentTimestamp ?? 0}
    set {_targetSentTimestamp = newValue}
  }
  /// Returns true if `targetSentTimestamp` has been explicitly set.
  var hasTargetSentTimestamp: Bool {return self._targetSentTimestamp != nil}
  /// Clears the value of `targetSentTimestamp`. Subsequent reads from it will return its default value.
  mutating func clearTargetSentTimestamp() {self._targetSentTimestamp = nil}

  /// @required
  var authorID: UInt64 {
    get {return _authorID ?? 0}
    set {_authorID = newValue}
  }
  /// Returns true if `authorID` has been explicitly set.
  var hasAuthorID: Bool {return self._authorID != nil}
  /// Clears the value of `authorID`. Subsequent reads from it will return its default value.
  mutating func clearAuthorID() {self._authorID = nil}

  var text: String {
    get {return _text ?? String()}
    set {_text = newValue}
  }
  /// Returns true if `text` has been explicitly set.
  var hasText: Bool {return self._text != nil}
  /// Clears the value of `text`. Subsequent reads from it will return its default value.
  mutating func clearText() {self._text = nil}

  var attachments: [BackupProtos_Quote.QuotedAttachment] = []

  var bodyRanges: [BackupProtos_BodyRange] = []

  var type: BackupProtos_Quote.TypeEnum {
    get {return _type ?? .unknown}
    set {_type = newValue}
  }
  /// Returns true if `type` has been explicitly set.
  var hasType: Bool {return self._type != nil}
  /// Clears the value of `type`. Subsequent reads from it will return its default value.
  mutating func clearType() {self._type = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum TypeEnum: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case unknown // = 0
    case normal // = 1
    case giftbadge // = 2

    init() {
      self = .unknown
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknown
      case 1: self = .normal
      case 2: self = .giftbadge
      default: return nil
      }
    }

    var rawValue: Int {
      switch self {
      case .unknown: return 0
      case .normal: return 1
      case .giftbadge: return 2
      }
    }

  }

  struct QuotedAttachment {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var contentType: String {
      get {return _contentType ?? String()}
      set {_contentType = newValue}
    }
    /// Returns true if `contentType` has been explicitly set.
    var hasContentType: Bool {return self._contentType != nil}
    /// Clears the value of `contentType`. Subsequent reads from it will return its default value.
    mutating func clearContentType() {self._contentType = nil}

    var fileName: String {
      get {return _fileName ?? String()}
      set {_fileName = newValue}
    }
    /// Returns true if `fileName` has been explicitly set.
    var hasFileName: Bool {return self._fileName != nil}
    /// Clears the value of `fileName`. Subsequent reads from it will return its default value.
    mutating func clearFileName() {self._fileName = nil}

    var thumbnail: BackupProtos_FilePointer {
      get {return _thumbnail ?? BackupProtos_FilePointer()}
      set {_thumbnail = newValue}
    }
    /// Returns true if `thumbnail` has been explicitly set.
    var hasThumbnail: Bool {return self._thumbnail != nil}
    /// Clears the value of `thumbnail`. Subsequent reads from it will return its default value.
    mutating func clearThumbnail() {self._thumbnail = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _contentType: String? = nil
    fileprivate var _fileName: String? = nil
    fileprivate var _thumbnail: BackupProtos_FilePointer? = nil
  }

  init() {}

  fileprivate var _targetSentTimestamp: UInt64? = nil
  fileprivate var _authorID: UInt64? = nil
  fileprivate var _text: String? = nil
  fileprivate var _type: BackupProtos_Quote.TypeEnum? = nil
}

#if swift(>=4.2)

extension BackupProtos_Quote.TypeEnum: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

struct BackupProtos_BodyRange {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var start: UInt32 {
    get {return _start ?? 0}
    set {_start = newValue}
  }
  /// Returns true if `start` has been explicitly set.
  var hasStart: Bool {return self._start != nil}
  /// Clears the value of `start`. Subsequent reads from it will return its default value.
  mutating func clearStart() {self._start = nil}

  var length: UInt32 {
    get {return _length ?? 0}
    set {_length = newValue}
  }
  /// Returns true if `length` has been explicitly set.
  var hasLength: Bool {return self._length != nil}
  /// Clears the value of `length`. Subsequent reads from it will return its default value.
  mutating func clearLength() {self._length = nil}

  /// oneof associatedValue {
  var mentionAci: Data {
    get {return _mentionAci ?? Data()}
    set {_mentionAci = newValue}
  }
  /// Returns true if `mentionAci` has been explicitly set.
  var hasMentionAci: Bool {return self._mentionAci != nil}
  /// Clears the value of `mentionAci`. Subsequent reads from it will return its default value.
  mutating func clearMentionAci() {self._mentionAci = nil}

  /// }
  var style: BackupProtos_BodyRange.Style {
    get {return _style ?? .none}
    set {_style = newValue}
  }
  /// Returns true if `style` has been explicitly set.
  var hasStyle: Bool {return self._style != nil}
  /// Clears the value of `style`. Subsequent reads from it will return its default value.
  mutating func clearStyle() {self._style = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum Style: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case none // = 0
    case bold // = 1
    case italic // = 2
    case spoiler // = 3
    case strikethrough // = 4
    case monospace // = 5

    init() {
      self = .none
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .none
      case 1: self = .bold
      case 2: self = .italic
      case 3: self = .spoiler
      case 4: self = .strikethrough
      case 5: self = .monospace
      default: return nil
      }
    }

    var rawValue: Int {
      switch self {
      case .none: return 0
      case .bold: return 1
      case .italic: return 2
      case .spoiler: return 3
      case .strikethrough: return 4
      case .monospace: return 5
      }
    }

  }

  init() {}

  fileprivate var _start: UInt32? = nil
  fileprivate var _length: UInt32? = nil
  fileprivate var _mentionAci: Data? = nil
  fileprivate var _style: BackupProtos_BodyRange.Style? = nil
}

#if swift(>=4.2)

extension BackupProtos_BodyRange.Style: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

struct BackupProtos_Reaction {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// @required
  var emoji: String {
    get {return _emoji ?? String()}
    set {_emoji = newValue}
  }
  /// Returns true if `emoji` has been explicitly set.
  var hasEmoji: Bool {return self._emoji != nil}
  /// Clears the value of `emoji`. Subsequent reads from it will return its default value.
  mutating func clearEmoji() {self._emoji = nil}

  /// @required
  var authorID: UInt64 {
    get {return _authorID ?? 0}
    set {_authorID = newValue}
  }
  /// Returns true if `authorID` has been explicitly set.
  var hasAuthorID: Bool {return self._authorID != nil}
  /// Clears the value of `authorID`. Subsequent reads from it will return its default value.
  mutating func clearAuthorID() {self._authorID = nil}

  /// @required
  var sentTimestamp: UInt64 {
    get {return _sentTimestamp ?? 0}
    set {_sentTimestamp = newValue}
  }
  /// Returns true if `sentTimestamp` has been explicitly set.
  var hasSentTimestamp: Bool {return self._sentTimestamp != nil}
  /// Clears the value of `sentTimestamp`. Subsequent reads from it will return its default value.
  mutating func clearSentTimestamp() {self._sentTimestamp = nil}

  var receivedTimestamp: UInt64 {
    get {return _receivedTimestamp ?? 0}
    set {_receivedTimestamp = newValue}
  }
  /// Returns true if `receivedTimestamp` has been explicitly set.
  var hasReceivedTimestamp: Bool {return self._receivedTimestamp != nil}
  /// Clears the value of `receivedTimestamp`. Subsequent reads from it will return its default value.
  mutating func clearReceivedTimestamp() {self._receivedTimestamp = nil}

  /// @required
  var sortOrder: UInt64 {
    get {return _sortOrder ?? 0}
    set {_sortOrder = newValue}
  }
  /// Returns true if `sortOrder` has been explicitly set.
  var hasSortOrder: Bool {return self._sortOrder != nil}
  /// Clears the value of `sortOrder`. Subsequent reads from it will return its default value.
  mutating func clearSortOrder() {self._sortOrder = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _emoji: String? = nil
  fileprivate var _authorID: UInt64? = nil
  fileprivate var _sentTimestamp: UInt64? = nil
  fileprivate var _receivedTimestamp: UInt64? = nil
  fileprivate var _sortOrder: UInt64? = nil
}

struct BackupProtos_ChatUpdateMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// oneof update {
  var simpleUpdate: BackupProtos_SimpleChatUpdate {
    get {return _simpleUpdate ?? BackupProtos_SimpleChatUpdate()}
    set {_simpleUpdate = newValue}
  }
  /// Returns true if `simpleUpdate` has been explicitly set.
  var hasSimpleUpdate: Bool {return self._simpleUpdate != nil}
  /// Clears the value of `simpleUpdate`. Subsequent reads from it will return its default value.
  mutating func clearSimpleUpdate() {self._simpleUpdate = nil}

  var groupChange: BackupProtos_GroupChangeChatUpdate {
    get {return _groupChange ?? BackupProtos_GroupChangeChatUpdate()}
    set {_groupChange = newValue}
  }
  /// Returns true if `groupChange` has been explicitly set.
  var hasGroupChange: Bool {return self._groupChange != nil}
  /// Clears the value of `groupChange`. Subsequent reads from it will return its default value.
  mutating func clearGroupChange() {self._groupChange = nil}

  var expirationTimerChange: BackupProtos_ExpirationTimerChatUpdate {
    get {return _expirationTimerChange ?? BackupProtos_ExpirationTimerChatUpdate()}
    set {_expirationTimerChange = newValue}
  }
  /// Returns true if `expirationTimerChange` has been explicitly set.
  var hasExpirationTimerChange: Bool {return self._expirationTimerChange != nil}
  /// Clears the value of `expirationTimerChange`. Subsequent reads from it will return its default value.
  mutating func clearExpirationTimerChange() {self._expirationTimerChange = nil}

  var profileChange: BackupProtos_ProfileChangeChatUpdate {
    get {return _profileChange ?? BackupProtos_ProfileChangeChatUpdate()}
    set {_profileChange = newValue}
  }
  /// Returns true if `profileChange` has been explicitly set.
  var hasProfileChange: Bool {return self._profileChange != nil}
  /// Clears the value of `profileChange`. Subsequent reads from it will return its default value.
  mutating func clearProfileChange() {self._profileChange = nil}

  var threadMerge: BackupProtos_ThreadMergeChatUpdate {
    get {return _threadMerge ?? BackupProtos_ThreadMergeChatUpdate()}
    set {_threadMerge = newValue}
  }
  /// Returns true if `threadMerge` has been explicitly set.
  var hasThreadMerge: Bool {return self._threadMerge != nil}
  /// Clears the value of `threadMerge`. Subsequent reads from it will return its default value.
  mutating func clearThreadMerge() {self._threadMerge = nil}

  var sessionSwitchover: BackupProtos_SessionSwitchoverChatUpdate {
    get {return _sessionSwitchover ?? BackupProtos_SessionSwitchoverChatUpdate()}
    set {_sessionSwitchover = newValue}
  }
  /// Returns true if `sessionSwitchover` has been explicitly set.
  var hasSessionSwitchover: Bool {return self._sessionSwitchover != nil}
  /// Clears the value of `sessionSwitchover`. Subsequent reads from it will return its default value.
  mutating func clearSessionSwitchover() {self._sessionSwitchover = nil}

  /// }
  var callingMessage: BackupProtos_CallChatUpdate {
    get {return _callingMessage ?? BackupProtos_CallChatUpdate()}
    set {_callingMessage = newValue}
  }
  /// Returns true if `callingMessage` has been explicitly set.
  var hasCallingMessage: Bool {return self._callingMessage != nil}
  /// Clears the value of `callingMessage`. Subsequent reads from it will return its default value.
  mutating func clearCallingMessage() {self._callingMessage = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _simpleUpdate: BackupProtos_SimpleChatUpdate? = nil
  fileprivate var _groupChange: BackupProtos_GroupChangeChatUpdate? = nil
  fileprivate var _expirationTimerChange: BackupProtos_ExpirationTimerChatUpdate? = nil
  fileprivate var _profileChange: BackupProtos_ProfileChangeChatUpdate? = nil
  fileprivate var _threadMerge: BackupProtos_ThreadMergeChatUpdate? = nil
  fileprivate var _sessionSwitchover: BackupProtos_SessionSwitchoverChatUpdate? = nil
  fileprivate var _callingMessage: BackupProtos_CallChatUpdate? = nil
}

struct BackupProtos_CallChatUpdate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// oneof call {
  var callID: UInt64 {
    get {return _callID ?? 0}
    set {_callID = newValue}
  }
  /// Returns true if `callID` has been explicitly set.
  var hasCallID: Bool {return self._callID != nil}
  /// Clears the value of `callID`. Subsequent reads from it will return its default value.
  mutating func clearCallID() {self._callID = nil}

  var callMessage: BackupProtos_IndividualCallChatUpdate {
    get {return _callMessage ?? BackupProtos_IndividualCallChatUpdate()}
    set {_callMessage = newValue}
  }
  /// Returns true if `callMessage` has been explicitly set.
  var hasCallMessage: Bool {return self._callMessage != nil}
  /// Clears the value of `callMessage`. Subsequent reads from it will return its default value.
  mutating func clearCallMessage() {self._callMessage = nil}

  /// }
  var groupCall: BackupProtos_GroupCallChatUpdate {
    get {return _groupCall ?? BackupProtos_GroupCallChatUpdate()}
    set {_groupCall = newValue}
  }
  /// Returns true if `groupCall` has been explicitly set.
  var hasGroupCall: Bool {return self._groupCall != nil}
  /// Clears the value of `groupCall`. Subsequent reads from it will return its default value.
  mutating func clearGroupCall() {self._groupCall = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _callID: UInt64? = nil
  fileprivate var _callMessage: BackupProtos_IndividualCallChatUpdate? = nil
  fileprivate var _groupCall: BackupProtos_GroupCallChatUpdate? = nil
}

struct BackupProtos_IndividualCallChatUpdate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum TypeEnum: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case unknown // = 0
    case incomingAudioCall // = 1
    case incomingVideoCall // = 2
    case outgoingAudioCall // = 3
    case outgoingVideoCall // = 4
    case missedAudioCall // = 5
    case missedVideoCall // = 6

    init() {
      self = .unknown
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknown
      case 1: self = .incomingAudioCall
      case 2: self = .incomingVideoCall
      case 3: self = .outgoingAudioCall
      case 4: self = .outgoingVideoCall
      case 5: self = .missedAudioCall
      case 6: self = .missedVideoCall
      default: return nil
      }
    }

    var rawValue: Int {
      switch self {
      case .unknown: return 0
      case .incomingAudioCall: return 1
      case .incomingVideoCall: return 2
      case .outgoingAudioCall: return 3
      case .outgoingVideoCall: return 4
      case .missedAudioCall: return 5
      case .missedVideoCall: return 6
      }
    }

  }

  init() {}
}

#if swift(>=4.2)

extension BackupProtos_IndividualCallChatUpdate.TypeEnum: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

struct BackupProtos_GroupCallChatUpdate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var startedCallAci: Data {
    get {return _startedCallAci ?? Data()}
    set {_startedCallAci = newValue}
  }
  /// Returns true if `startedCallAci` has been explicitly set.
  var hasStartedCallAci: Bool {return self._startedCallAci != nil}
  /// Clears the value of `startedCallAci`. Subsequent reads from it will return its default value.
  mutating func clearStartedCallAci() {self._startedCallAci = nil}

  /// @required
  var startedCallTimestamp: UInt64 {
    get {return _startedCallTimestamp ?? 0}
    set {_startedCallTimestamp = newValue}
  }
  /// Returns true if `startedCallTimestamp` has been explicitly set.
  var hasStartedCallTimestamp: Bool {return self._startedCallTimestamp != nil}
  /// Clears the value of `startedCallTimestamp`. Subsequent reads from it will return its default value.
  mutating func clearStartedCallTimestamp() {self._startedCallTimestamp = nil}

  var inCallAcis: [Data] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _startedCallAci: Data? = nil
  fileprivate var _startedCallTimestamp: UInt64? = nil
}

struct BackupProtos_SimpleChatUpdate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var type: BackupProtos_SimpleChatUpdate.TypeEnum {
    get {return _type ?? .unknown}
    set {_type = newValue}
  }
  /// Returns true if `type` has been explicitly set.
  var hasType: Bool {return self._type != nil}
  /// Clears the value of `type`. Subsequent reads from it will return its default value.
  mutating func clearType() {self._type = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum TypeEnum: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case unknown // = 0
    case joinedSignal // = 1
    case identityUpdate // = 2
    case identityVerified // = 3

    /// marking as unverified
    case identityDefault // = 4
    case changeNumber // = 5
    case boostRequest // = 6
    case endSession // = 7
    case chatSessionRefresh // = 8
    case badDecrypt // = 9
    case paymentsActivated // = 10
    case paymentActivationRequest // = 11

    init() {
      self = .unknown
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknown
      case 1: self = .joinedSignal
      case 2: self = .identityUpdate
      case 3: self = .identityVerified
      case 4: self = .identityDefault
      case 5: self = .changeNumber
      case 6: self = .boostRequest
      case 7: self = .endSession
      case 8: self = .chatSessionRefresh
      case 9: self = .badDecrypt
      case 10: self = .paymentsActivated
      case 11: self = .paymentActivationRequest
      default: return nil
      }
    }

    var rawValue: Int {
      switch self {
      case .unknown: return 0
      case .joinedSignal: return 1
      case .identityUpdate: return 2
      case .identityVerified: return 3
      case .identityDefault: return 4
      case .changeNumber: return 5
      case .boostRequest: return 6
      case .endSession: return 7
      case .chatSessionRefresh: return 8
      case .badDecrypt: return 9
      case .paymentsActivated: return 10
      case .paymentActivationRequest: return 11
      }
    }

  }

  init() {}

  fileprivate var _type: BackupProtos_SimpleChatUpdate.TypeEnum? = nil
}

#if swift(>=4.2)

extension BackupProtos_SimpleChatUpdate.TypeEnum: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

struct BackupProtos_GroupDescriptionChatUpdate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// @required
  var newDescription: String {
    get {return _newDescription ?? String()}
    set {_newDescription = newValue}
  }
  /// Returns true if `newDescription` has been explicitly set.
  var hasNewDescription: Bool {return self._newDescription != nil}
  /// Clears the value of `newDescription`. Subsequent reads from it will return its default value.
  mutating func clearNewDescription() {self._newDescription = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _newDescription: String? = nil
}

/// For 1:1 chat updates only.
/// For group thread updates use GroupExpirationTimerUpdate.
struct BackupProtos_ExpirationTimerChatUpdate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// @required
  var expiresInMs: UInt32 {
    get {return _expiresInMs ?? 0}
    set {_expiresInMs = newValue}
  }
  /// Returns true if `expiresInMs` has been explicitly set.
  var hasExpiresInMs: Bool {return self._expiresInMs != nil}
  /// Clears the value of `expiresInMs`. Subsequent reads from it will return its default value.
  mutating func clearExpiresInMs() {self._expiresInMs = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _expiresInMs: UInt32? = nil
}

struct BackupProtos_ProfileChangeChatUpdate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// @required
  var previousName: String {
    get {return _previousName ?? String()}
    set {_previousName = newValue}
  }
  /// Returns true if `previousName` has been explicitly set.
  var hasPreviousName: Bool {return self._previousName != nil}
  /// Clears the value of `previousName`. Subsequent reads from it will return its default value.
  mutating func clearPreviousName() {self._previousName = nil}

  /// @required
  var newName: String {
    get {return _newName ?? String()}
    set {_newName = newValue}
  }
  /// Returns true if `newName` has been explicitly set.
  var hasNewName: Bool {return self._newName != nil}
  /// Clears the value of `newName`. Subsequent reads from it will return its default value.
  mutating func clearNewName() {self._newName = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _previousName: String? = nil
  fileprivate var _newName: String? = nil
}

struct BackupProtos_ThreadMergeChatUpdate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// @required
  var previousE164: UInt64 {
    get {return _previousE164 ?? 0}
    set {_previousE164 = newValue}
  }
  /// Returns true if `previousE164` has been explicitly set.
  var hasPreviousE164: Bool {return self._previousE164 != nil}
  /// Clears the value of `previousE164`. Subsequent reads from it will return its default value.
  mutating func clearPreviousE164() {self._previousE164 = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _previousE164: UInt64? = nil
}

struct BackupProtos_SessionSwitchoverChatUpdate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// @required
  var e164: UInt64 {
    get {return _e164 ?? 0}
    set {_e164 = newValue}
  }
  /// Returns true if `e164` has been explicitly set.
  var hasE164: Bool {return self._e164 != nil}
  /// Clears the value of `e164`. Subsequent reads from it will return its default value.
  mutating func clearE164() {self._e164 = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _e164: UInt64? = nil
}

struct BackupProtos_GroupChangeChatUpdate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Must be one or more; all updates batched together came from
  /// a single batched group state update.
  var updates: [BackupProtos_GroupChangeChatUpdate.Update] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct Update {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Note: group expiration timer changes are represented as ExpirationTimerChatUpdate.
    /// oneof update {
    var genericGroupUpdate: BackupProtos_GenericGroupUpdate {
      get {return _storage._genericGroupUpdate ?? BackupProtos_GenericGroupUpdate()}
      set {_uniqueStorage()._genericGroupUpdate = newValue}
    }
    /// Returns true if `genericGroupUpdate` has been explicitly set.
    var hasGenericGroupUpdate: Bool {return _storage._genericGroupUpdate != nil}
    /// Clears the value of `genericGroupUpdate`. Subsequent reads from it will return its default value.
    mutating func clearGenericGroupUpdate() {_uniqueStorage()._genericGroupUpdate = nil}

    var groupCreationUpdate: BackupProtos_GroupCreationUpdate {
      get {return _storage._groupCreationUpdate ?? BackupProtos_GroupCreationUpdate()}
      set {_uniqueStorage()._groupCreationUpdate = newValue}
    }
    /// Returns true if `groupCreationUpdate` has been explicitly set.
    var hasGroupCreationUpdate: Bool {return _storage._groupCreationUpdate != nil}
    /// Clears the value of `groupCreationUpdate`. Subsequent reads from it will return its default value.
    mutating func clearGroupCreationUpdate() {_uniqueStorage()._groupCreationUpdate = nil}

    var groupNameUpdate: BackupProtos_GroupNameUpdate {
      get {return _storage._groupNameUpdate ?? BackupProtos_GroupNameUpdate()}
      set {_uniqueStorage()._groupNameUpdate = newValue}
    }
    /// Returns true if `groupNameUpdate` has been explicitly set.
    var hasGroupNameUpdate: Bool {return _storage._groupNameUpdate != nil}
    /// Clears the value of `groupNameUpdate`. Subsequent reads from it will return its default value.
    mutating func clearGroupNameUpdate() {_uniqueStorage()._groupNameUpdate = nil}

    var groupAvatarUpdate: BackupProtos_GroupAvatarUpdate {
      get {return _storage._groupAvatarUpdate ?? BackupProtos_GroupAvatarUpdate()}
      set {_uniqueStorage()._groupAvatarUpdate = newValue}
    }
    /// Returns true if `groupAvatarUpdate` has been explicitly set.
    var hasGroupAvatarUpdate: Bool {return _storage._groupAvatarUpdate != nil}
    /// Clears the value of `groupAvatarUpdate`. Subsequent reads from it will return its default value.
    mutating func clearGroupAvatarUpdate() {_uniqueStorage()._groupAvatarUpdate = nil}

    var groupDescriptionUpdate: BackupProtos_GroupDescriptionUpdate {
      get {return _storage._groupDescriptionUpdate ?? BackupProtos_GroupDescriptionUpdate()}
      set {_uniqueStorage()._groupDescriptionUpdate = newValue}
    }
    /// Returns true if `groupDescriptionUpdate` has been explicitly set.
    var hasGroupDescriptionUpdate: Bool {return _storage._groupDescriptionUpdate != nil}
    /// Clears the value of `groupDescriptionUpdate`. Subsequent reads from it will return its default value.
    mutating func clearGroupDescriptionUpdate() {_uniqueStorage()._groupDescriptionUpdate = nil}

    var groupMembershipAccessLevelChangeUpdate: BackupProtos_GroupMembershipAccessLevelChangeUpdate {
      get {return _storage._groupMembershipAccessLevelChangeUpdate ?? BackupProtos_GroupMembershipAccessLevelChangeUpdate()}
      set {_uniqueStorage()._groupMembershipAccessLevelChangeUpdate = newValue}
    }
    /// Returns true if `groupMembershipAccessLevelChangeUpdate` has been explicitly set.
    var hasGroupMembershipAccessLevelChangeUpdate: Bool {return _storage._groupMembershipAccessLevelChangeUpdate != nil}
    /// Clears the value of `groupMembershipAccessLevelChangeUpdate`. Subsequent reads from it will return its default value.
    mutating func clearGroupMembershipAccessLevelChangeUpdate() {_uniqueStorage()._groupMembershipAccessLevelChangeUpdate = nil}

    var groupAttributesAccessLevelChangeUpdate: BackupProtos_GroupAttributesAccessLevelChangeUpdate {
      get {return _storage._groupAttributesAccessLevelChangeUpdate ?? BackupProtos_GroupAttributesAccessLevelChangeUpdate()}
      set {_uniqueStorage()._groupAttributesAccessLevelChangeUpdate = newValue}
    }
    /// Returns true if `groupAttributesAccessLevelChangeUpdate` has been explicitly set.
    var hasGroupAttributesAccessLevelChangeUpdate: Bool {return _storage._groupAttributesAccessLevelChangeUpdate != nil}
    /// Clears the value of `groupAttributesAccessLevelChangeUpdate`. Subsequent reads from it will return its default value.
    mutating func clearGroupAttributesAccessLevelChangeUpdate() {_uniqueStorage()._groupAttributesAccessLevelChangeUpdate = nil}

    var groupAnnouncementOnlyChangeUpdate: BackupProtos_GroupAnnouncementOnlyChangeUpdate {
      get {return _storage._groupAnnouncementOnlyChangeUpdate ?? BackupProtos_GroupAnnouncementOnlyChangeUpdate()}
      set {_uniqueStorage()._groupAnnouncementOnlyChangeUpdate = newValue}
    }
    /// Returns true if `groupAnnouncementOnlyChangeUpdate` has been explicitly set.
    var hasGroupAnnouncementOnlyChangeUpdate: Bool {return _storage._groupAnnouncementOnlyChangeUpdate != nil}
    /// Clears the value of `groupAnnouncementOnlyChangeUpdate`. Subsequent reads from it will return its default value.
    mutating func clearGroupAnnouncementOnlyChangeUpdate() {_uniqueStorage()._groupAnnouncementOnlyChangeUpdate = nil}

    var groupAdminStatusUpdate: BackupProtos_GroupAdminStatusUpdate {
      get {return _storage._groupAdminStatusUpdate ?? BackupProtos_GroupAdminStatusUpdate()}
      set {_uniqueStorage()._groupAdminStatusUpdate = newValue}
    }
    /// Returns true if `groupAdminStatusUpdate` has been explicitly set.
    var hasGroupAdminStatusUpdate: Bool {return _storage._groupAdminStatusUpdate != nil}
    /// Clears the value of `groupAdminStatusUpdate`. Subsequent reads from it will return its default value.
    mutating func clearGroupAdminStatusUpdate() {_uniqueStorage()._groupAdminStatusUpdate = nil}

    var groupMemberLeftUpdate: BackupProtos_GroupMemberLeftUpdate {
      get {return _storage._groupMemberLeftUpdate ?? BackupProtos_GroupMemberLeftUpdate()}
      set {_uniqueStorage()._groupMemberLeftUpdate = newValue}
    }
    /// Returns true if `groupMemberLeftUpdate` has been explicitly set.
    var hasGroupMemberLeftUpdate: Bool {return _storage._groupMemberLeftUpdate != nil}
    /// Clears the value of `groupMemberLeftUpdate`. Subsequent reads from it will return its default value.
    mutating func clearGroupMemberLeftUpdate() {_uniqueStorage()._groupMemberLeftUpdate = nil}

    var groupMemberRemovedUpdate: BackupProtos_GroupMemberRemovedUpdate {
      get {return _storage._groupMemberRemovedUpdate ?? BackupProtos_GroupMemberRemovedUpdate()}
      set {_uniqueStorage()._groupMemberRemovedUpdate = newValue}
    }
    /// Returns true if `groupMemberRemovedUpdate` has been explicitly set.
    var hasGroupMemberRemovedUpdate: Bool {return _storage._groupMemberRemovedUpdate != nil}
    /// Clears the value of `groupMemberRemovedUpdate`. Subsequent reads from it will return its default value.
    mutating func clearGroupMemberRemovedUpdate() {_uniqueStorage()._groupMemberRemovedUpdate = nil}

    var selfInvitedToGroupUpdate: BackupProtos_SelfInvitedToGroupUpdate {
      get {return _storage._selfInvitedToGroupUpdate ?? BackupProtos_SelfInvitedToGroupUpdate()}
      set {_uniqueStorage()._selfInvitedToGroupUpdate = newValue}
    }
    /// Returns true if `selfInvitedToGroupUpdate` has been explicitly set.
    var hasSelfInvitedToGroupUpdate: Bool {return _storage._selfInvitedToGroupUpdate != nil}
    /// Clears the value of `selfInvitedToGroupUpdate`. Subsequent reads from it will return its default value.
    mutating func clearSelfInvitedToGroupUpdate() {_uniqueStorage()._selfInvitedToGroupUpdate = nil}

    var selfInvitedOtherUserToGroupUpdate: BackupProtos_SelfInvitedOtherUserToGroupUpdate {
      get {return _storage._selfInvitedOtherUserToGroupUpdate ?? BackupProtos_SelfInvitedOtherUserToGroupUpdate()}
      set {_uniqueStorage()._selfInvitedOtherUserToGroupUpdate = newValue}
    }
    /// Returns true if `selfInvitedOtherUserToGroupUpdate` has been explicitly set.
    var hasSelfInvitedOtherUserToGroupUpdate: Bool {return _storage._selfInvitedOtherUserToGroupUpdate != nil}
    /// Clears the value of `selfInvitedOtherUserToGroupUpdate`. Subsequent reads from it will return its default value.
    mutating func clearSelfInvitedOtherUserToGroupUpdate() {_uniqueStorage()._selfInvitedOtherUserToGroupUpdate = nil}

    var groupUnknownInviteeUpdate: BackupProtos_GroupUnknownInviteeUpdate {
      get {return _storage._groupUnknownInviteeUpdate ?? BackupProtos_GroupUnknownInviteeUpdate()}
      set {_uniqueStorage()._groupUnknownInviteeUpdate = newValue}
    }
    /// Returns true if `groupUnknownInviteeUpdate` has been explicitly set.
    var hasGroupUnknownInviteeUpdate: Bool {return _storage._groupUnknownInviteeUpdate != nil}
    /// Clears the value of `groupUnknownInviteeUpdate`. Subsequent reads from it will return its default value.
    mutating func clearGroupUnknownInviteeUpdate() {_uniqueStorage()._groupUnknownInviteeUpdate = nil}

    var groupInvitationAcceptedUpdate: BackupProtos_GroupInvitationAcceptedUpdate {
      get {return _storage._groupInvitationAcceptedUpdate ?? BackupProtos_GroupInvitationAcceptedUpdate()}
      set {_uniqueStorage()._groupInvitationAcceptedUpdate = newValue}
    }
    /// Returns true if `groupInvitationAcceptedUpdate` has been explicitly set.
    var hasGroupInvitationAcceptedUpdate: Bool {return _storage._groupInvitationAcceptedUpdate != nil}
    /// Clears the value of `groupInvitationAcceptedUpdate`. Subsequent reads from it will return its default value.
    mutating func clearGroupInvitationAcceptedUpdate() {_uniqueStorage()._groupInvitationAcceptedUpdate = nil}

    var groupInvitationDeclinedUpdate: BackupProtos_GroupInvitationDeclinedUpdate {
      get {return _storage._groupInvitationDeclinedUpdate ?? BackupProtos_GroupInvitationDeclinedUpdate()}
      set {_uniqueStorage()._groupInvitationDeclinedUpdate = newValue}
    }
    /// Returns true if `groupInvitationDeclinedUpdate` has been explicitly set.
    var hasGroupInvitationDeclinedUpdate: Bool {return _storage._groupInvitationDeclinedUpdate != nil}
    /// Clears the value of `groupInvitationDeclinedUpdate`. Subsequent reads from it will return its default value.
    mutating func clearGroupInvitationDeclinedUpdate() {_uniqueStorage()._groupInvitationDeclinedUpdate = nil}

    var groupMemberJoinedUpdate: BackupProtos_GroupMemberJoinedUpdate {
      get {return _storage._groupMemberJoinedUpdate ?? BackupProtos_GroupMemberJoinedUpdate()}
      set {_uniqueStorage()._groupMemberJoinedUpdate = newValue}
    }
    /// Returns true if `groupMemberJoinedUpdate` has been explicitly set.
    var hasGroupMemberJoinedUpdate: Bool {return _storage._groupMemberJoinedUpdate != nil}
    /// Clears the value of `groupMemberJoinedUpdate`. Subsequent reads from it will return its default value.
    mutating func clearGroupMemberJoinedUpdate() {_uniqueStorage()._groupMemberJoinedUpdate = nil}

    var groupMemberAddedUpdate: BackupProtos_GroupMemberAddedUpdate {
      get {return _storage._groupMemberAddedUpdate ?? BackupProtos_GroupMemberAddedUpdate()}
      set {_uniqueStorage()._groupMemberAddedUpdate = newValue}
    }
    /// Returns true if `groupMemberAddedUpdate` has been explicitly set.
    var hasGroupMemberAddedUpdate: Bool {return _storage._groupMemberAddedUpdate != nil}
    /// Clears the value of `groupMemberAddedUpdate`. Subsequent reads from it will return its default value.
    mutating func clearGroupMemberAddedUpdate() {_uniqueStorage()._groupMemberAddedUpdate = nil}

    var groupSelfInvitationRevokedUpdate: BackupProtos_GroupSelfInvitationRevokedUpdate {
      get {return _storage._groupSelfInvitationRevokedUpdate ?? BackupProtos_GroupSelfInvitationRevokedUpdate()}
      set {_uniqueStorage()._groupSelfInvitationRevokedUpdate = newValue}
    }
    /// Returns true if `groupSelfInvitationRevokedUpdate` has been explicitly set.
    var hasGroupSelfInvitationRevokedUpdate: Bool {return _storage._groupSelfInvitationRevokedUpdate != nil}
    /// Clears the value of `groupSelfInvitationRevokedUpdate`. Subsequent reads from it will return its default value.
    mutating func clearGroupSelfInvitationRevokedUpdate() {_uniqueStorage()._groupSelfInvitationRevokedUpdate = nil}

    var groupInvitationRevokedUpdate: BackupProtos_GroupInvitationRevokedUpdate {
      get {return _storage._groupInvitationRevokedUpdate ?? BackupProtos_GroupInvitationRevokedUpdate()}
      set {_uniqueStorage()._groupInvitationRevokedUpdate = newValue}
    }
    /// Returns true if `groupInvitationRevokedUpdate` has been explicitly set.
    var hasGroupInvitationRevokedUpdate: Bool {return _storage._groupInvitationRevokedUpdate != nil}
    /// Clears the value of `groupInvitationRevokedUpdate`. Subsequent reads from it will return its default value.
    mutating func clearGroupInvitationRevokedUpdate() {_uniqueStorage()._groupInvitationRevokedUpdate = nil}

    var groupJoinRequestUpdate: BackupProtos_GroupJoinRequestUpdate {
      get {return _storage._groupJoinRequestUpdate ?? BackupProtos_GroupJoinRequestUpdate()}
      set {_uniqueStorage()._groupJoinRequestUpdate = newValue}
    }
    /// Returns true if `groupJoinRequestUpdate` has been explicitly set.
    var hasGroupJoinRequestUpdate: Bool {return _storage._groupJoinRequestUpdate != nil}
    /// Clears the value of `groupJoinRequestUpdate`. Subsequent reads from it will return its default value.
    mutating func clearGroupJoinRequestUpdate() {_uniqueStorage()._groupJoinRequestUpdate = nil}

    var groupJoinRequestApprovalUpdate: BackupProtos_GroupJoinRequestApprovalUpdate {
      get {return _storage._groupJoinRequestApprovalUpdate ?? BackupProtos_GroupJoinRequestApprovalUpdate()}
      set {_uniqueStorage()._groupJoinRequestApprovalUpdate = newValue}
    }
    /// Returns true if `groupJoinRequestApprovalUpdate` has been explicitly set.
    var hasGroupJoinRequestApprovalUpdate: Bool {return _storage._groupJoinRequestApprovalUpdate != nil}
    /// Clears the value of `groupJoinRequestApprovalUpdate`. Subsequent reads from it will return its default value.
    mutating func clearGroupJoinRequestApprovalUpdate() {_uniqueStorage()._groupJoinRequestApprovalUpdate = nil}

    var groupJoinRequestCanceledUpdate: BackupProtos_GroupJoinRequestCanceledUpdate {
      get {return _storage._groupJoinRequestCanceledUpdate ?? BackupProtos_GroupJoinRequestCanceledUpdate()}
      set {_uniqueStorage()._groupJoinRequestCanceledUpdate = newValue}
    }
    /// Returns true if `groupJoinRequestCanceledUpdate` has been explicitly set.
    var hasGroupJoinRequestCanceledUpdate: Bool {return _storage._groupJoinRequestCanceledUpdate != nil}
    /// Clears the value of `groupJoinRequestCanceledUpdate`. Subsequent reads from it will return its default value.
    mutating func clearGroupJoinRequestCanceledUpdate() {_uniqueStorage()._groupJoinRequestCanceledUpdate = nil}

    var groupInviteLinkResetUpdate: BackupProtos_GroupInviteLinkResetUpdate {
      get {return _storage._groupInviteLinkResetUpdate ?? BackupProtos_GroupInviteLinkResetUpdate()}
      set {_uniqueStorage()._groupInviteLinkResetUpdate = newValue}
    }
    /// Returns true if `groupInviteLinkResetUpdate` has been explicitly set.
    var hasGroupInviteLinkResetUpdate: Bool {return _storage._groupInviteLinkResetUpdate != nil}
    /// Clears the value of `groupInviteLinkResetUpdate`. Subsequent reads from it will return its default value.
    mutating func clearGroupInviteLinkResetUpdate() {_uniqueStorage()._groupInviteLinkResetUpdate = nil}

    var groupInviteLinkEnabledUpdate: BackupProtos_GroupInviteLinkEnabledUpdate {
      get {return _storage._groupInviteLinkEnabledUpdate ?? BackupProtos_GroupInviteLinkEnabledUpdate()}
      set {_uniqueStorage()._groupInviteLinkEnabledUpdate = newValue}
    }
    /// Returns true if `groupInviteLinkEnabledUpdate` has been explicitly set.
    var hasGroupInviteLinkEnabledUpdate: Bool {return _storage._groupInviteLinkEnabledUpdate != nil}
    /// Clears the value of `groupInviteLinkEnabledUpdate`. Subsequent reads from it will return its default value.
    mutating func clearGroupInviteLinkEnabledUpdate() {_uniqueStorage()._groupInviteLinkEnabledUpdate = nil}

    var groupInviteLinkAdminApprovalUpdate: BackupProtos_GroupInviteLinkAdminApprovalUpdate {
      get {return _storage._groupInviteLinkAdminApprovalUpdate ?? BackupProtos_GroupInviteLinkAdminApprovalUpdate()}
      set {_uniqueStorage()._groupInviteLinkAdminApprovalUpdate = newValue}
    }
    /// Returns true if `groupInviteLinkAdminApprovalUpdate` has been explicitly set.
    var hasGroupInviteLinkAdminApprovalUpdate: Bool {return _storage._groupInviteLinkAdminApprovalUpdate != nil}
    /// Clears the value of `groupInviteLinkAdminApprovalUpdate`. Subsequent reads from it will return its default value.
    mutating func clearGroupInviteLinkAdminApprovalUpdate() {_uniqueStorage()._groupInviteLinkAdminApprovalUpdate = nil}

    var groupInviteLinkDisabledUpdate: BackupProtos_GroupInviteLinkDisabledUpdate {
      get {return _storage._groupInviteLinkDisabledUpdate ?? BackupProtos_GroupInviteLinkDisabledUpdate()}
      set {_uniqueStorage()._groupInviteLinkDisabledUpdate = newValue}
    }
    /// Returns true if `groupInviteLinkDisabledUpdate` has been explicitly set.
    var hasGroupInviteLinkDisabledUpdate: Bool {return _storage._groupInviteLinkDisabledUpdate != nil}
    /// Clears the value of `groupInviteLinkDisabledUpdate`. Subsequent reads from it will return its default value.
    mutating func clearGroupInviteLinkDisabledUpdate() {_uniqueStorage()._groupInviteLinkDisabledUpdate = nil}

    var groupMemberJoinedByLinkUpdate: BackupProtos_GroupMemberJoinedByLinkUpdate {
      get {return _storage._groupMemberJoinedByLinkUpdate ?? BackupProtos_GroupMemberJoinedByLinkUpdate()}
      set {_uniqueStorage()._groupMemberJoinedByLinkUpdate = newValue}
    }
    /// Returns true if `groupMemberJoinedByLinkUpdate` has been explicitly set.
    var hasGroupMemberJoinedByLinkUpdate: Bool {return _storage._groupMemberJoinedByLinkUpdate != nil}
    /// Clears the value of `groupMemberJoinedByLinkUpdate`. Subsequent reads from it will return its default value.
    mutating func clearGroupMemberJoinedByLinkUpdate() {_uniqueStorage()._groupMemberJoinedByLinkUpdate = nil}

    var groupV2MigrationUpdate: BackupProtos_GroupV2MigrationUpdate {
      get {return _storage._groupV2MigrationUpdate ?? BackupProtos_GroupV2MigrationUpdate()}
      set {_uniqueStorage()._groupV2MigrationUpdate = newValue}
    }
    /// Returns true if `groupV2MigrationUpdate` has been explicitly set.
    var hasGroupV2MigrationUpdate: Bool {return _storage._groupV2MigrationUpdate != nil}
    /// Clears the value of `groupV2MigrationUpdate`. Subsequent reads from it will return its default value.
    mutating func clearGroupV2MigrationUpdate() {_uniqueStorage()._groupV2MigrationUpdate = nil}

    var groupV2MigrationSelfInvitedUpdate: BackupProtos_GroupV2MigrationSelfInvitedUpdate {
      get {return _storage._groupV2MigrationSelfInvitedUpdate ?? BackupProtos_GroupV2MigrationSelfInvitedUpdate()}
      set {_uniqueStorage()._groupV2MigrationSelfInvitedUpdate = newValue}
    }
    /// Returns true if `groupV2MigrationSelfInvitedUpdate` has been explicitly set.
    var hasGroupV2MigrationSelfInvitedUpdate: Bool {return _storage._groupV2MigrationSelfInvitedUpdate != nil}
    /// Clears the value of `groupV2MigrationSelfInvitedUpdate`. Subsequent reads from it will return its default value.
    mutating func clearGroupV2MigrationSelfInvitedUpdate() {_uniqueStorage()._groupV2MigrationSelfInvitedUpdate = nil}

    var groupV2MigrationInvitedMembersUpdate: BackupProtos_GroupV2MigrationInvitedMembersUpdate {
      get {return _storage._groupV2MigrationInvitedMembersUpdate ?? BackupProtos_GroupV2MigrationInvitedMembersUpdate()}
      set {_uniqueStorage()._groupV2MigrationInvitedMembersUpdate = newValue}
    }
    /// Returns true if `groupV2MigrationInvitedMembersUpdate` has been explicitly set.
    var hasGroupV2MigrationInvitedMembersUpdate: Bool {return _storage._groupV2MigrationInvitedMembersUpdate != nil}
    /// Clears the value of `groupV2MigrationInvitedMembersUpdate`. Subsequent reads from it will return its default value.
    mutating func clearGroupV2MigrationInvitedMembersUpdate() {_uniqueStorage()._groupV2MigrationInvitedMembersUpdate = nil}

    var groupV2MigrationDroppedMembersUpdate: BackupProtos_GroupV2MigrationDroppedMembersUpdate {
      get {return _storage._groupV2MigrationDroppedMembersUpdate ?? BackupProtos_GroupV2MigrationDroppedMembersUpdate()}
      set {_uniqueStorage()._groupV2MigrationDroppedMembersUpdate = newValue}
    }
    /// Returns true if `groupV2MigrationDroppedMembersUpdate` has been explicitly set.
    var hasGroupV2MigrationDroppedMembersUpdate: Bool {return _storage._groupV2MigrationDroppedMembersUpdate != nil}
    /// Clears the value of `groupV2MigrationDroppedMembersUpdate`. Subsequent reads from it will return its default value.
    mutating func clearGroupV2MigrationDroppedMembersUpdate() {_uniqueStorage()._groupV2MigrationDroppedMembersUpdate = nil}

    var groupSequenceOfRequestsAndCancelsUpdate: BackupProtos_GroupSequenceOfRequestsAndCancelsUpdate {
      get {return _storage._groupSequenceOfRequestsAndCancelsUpdate ?? BackupProtos_GroupSequenceOfRequestsAndCancelsUpdate()}
      set {_uniqueStorage()._groupSequenceOfRequestsAndCancelsUpdate = newValue}
    }
    /// Returns true if `groupSequenceOfRequestsAndCancelsUpdate` has been explicitly set.
    var hasGroupSequenceOfRequestsAndCancelsUpdate: Bool {return _storage._groupSequenceOfRequestsAndCancelsUpdate != nil}
    /// Clears the value of `groupSequenceOfRequestsAndCancelsUpdate`. Subsequent reads from it will return its default value.
    mutating func clearGroupSequenceOfRequestsAndCancelsUpdate() {_uniqueStorage()._groupSequenceOfRequestsAndCancelsUpdate = nil}

    /// }
    var groupExpirationTimerUpdate: BackupProtos_GroupExpirationTimerUpdate {
      get {return _storage._groupExpirationTimerUpdate ?? BackupProtos_GroupExpirationTimerUpdate()}
      set {_uniqueStorage()._groupExpirationTimerUpdate = newValue}
    }
    /// Returns true if `groupExpirationTimerUpdate` has been explicitly set.
    var hasGroupExpirationTimerUpdate: Bool {return _storage._groupExpirationTimerUpdate != nil}
    /// Clears the value of `groupExpirationTimerUpdate`. Subsequent reads from it will return its default value.
    mutating func clearGroupExpirationTimerUpdate() {_uniqueStorage()._groupExpirationTimerUpdate = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  init() {}
}

struct BackupProtos_GenericGroupUpdate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var updaterAci: Data {
    get {return _updaterAci ?? Data()}
    set {_updaterAci = newValue}
  }
  /// Returns true if `updaterAci` has been explicitly set.
  var hasUpdaterAci: Bool {return self._updaterAci != nil}
  /// Clears the value of `updaterAci`. Subsequent reads from it will return its default value.
  mutating func clearUpdaterAci() {self._updaterAci = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _updaterAci: Data? = nil
}

struct BackupProtos_GroupCreationUpdate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var updaterAci: Data {
    get {return _updaterAci ?? Data()}
    set {_updaterAci = newValue}
  }
  /// Returns true if `updaterAci` has been explicitly set.
  var hasUpdaterAci: Bool {return self._updaterAci != nil}
  /// Clears the value of `updaterAci`. Subsequent reads from it will return its default value.
  mutating func clearUpdaterAci() {self._updaterAci = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _updaterAci: Data? = nil
}

struct BackupProtos_GroupNameUpdate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var updaterAci: Data {
    get {return _updaterAci ?? Data()}
    set {_updaterAci = newValue}
  }
  /// Returns true if `updaterAci` has been explicitly set.
  var hasUpdaterAci: Bool {return self._updaterAci != nil}
  /// Clears the value of `updaterAci`. Subsequent reads from it will return its default value.
  mutating func clearUpdaterAci() {self._updaterAci = nil}

  /// Null value means the group name was removed.
  var newGroupName: String {
    get {return _newGroupName ?? String()}
    set {_newGroupName = newValue}
  }
  /// Returns true if `newGroupName` has been explicitly set.
  var hasNewGroupName: Bool {return self._newGroupName != nil}
  /// Clears the value of `newGroupName`. Subsequent reads from it will return its default value.
  mutating func clearNewGroupName() {self._newGroupName = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _updaterAci: Data? = nil
  fileprivate var _newGroupName: String? = nil
}

struct BackupProtos_GroupAvatarUpdate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var updaterAci: Data {
    get {return _updaterAci ?? Data()}
    set {_updaterAci = newValue}
  }
  /// Returns true if `updaterAci` has been explicitly set.
  var hasUpdaterAci: Bool {return self._updaterAci != nil}
  /// Clears the value of `updaterAci`. Subsequent reads from it will return its default value.
  mutating func clearUpdaterAci() {self._updaterAci = nil}

  /// @required
  var wasRemoved: Bool {
    get {return _wasRemoved ?? false}
    set {_wasRemoved = newValue}
  }
  /// Returns true if `wasRemoved` has been explicitly set.
  var hasWasRemoved: Bool {return self._wasRemoved != nil}
  /// Clears the value of `wasRemoved`. Subsequent reads from it will return its default value.
  mutating func clearWasRemoved() {self._wasRemoved = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _updaterAci: Data? = nil
  fileprivate var _wasRemoved: Bool? = nil
}

struct BackupProtos_GroupDescriptionUpdate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var updaterAci: Data {
    get {return _updaterAci ?? Data()}
    set {_updaterAci = newValue}
  }
  /// Returns true if `updaterAci` has been explicitly set.
  var hasUpdaterAci: Bool {return self._updaterAci != nil}
  /// Clears the value of `updaterAci`. Subsequent reads from it will return its default value.
  mutating func clearUpdaterAci() {self._updaterAci = nil}

  /// Null value means the group description was removed.
  var newDescription: String {
    get {return _newDescription ?? String()}
    set {_newDescription = newValue}
  }
  /// Returns true if `newDescription` has been explicitly set.
  var hasNewDescription: Bool {return self._newDescription != nil}
  /// Clears the value of `newDescription`. Subsequent reads from it will return its default value.
  mutating func clearNewDescription() {self._newDescription = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _updaterAci: Data? = nil
  fileprivate var _newDescription: String? = nil
}

struct BackupProtos_GroupMembershipAccessLevelChangeUpdate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var updaterAci: Data {
    get {return _updaterAci ?? Data()}
    set {_updaterAci = newValue}
  }
  /// Returns true if `updaterAci` has been explicitly set.
  var hasUpdaterAci: Bool {return self._updaterAci != nil}
  /// Clears the value of `updaterAci`. Subsequent reads from it will return its default value.
  mutating func clearUpdaterAci() {self._updaterAci = nil}

  var accessLevel: BackupProtos_GroupV2AccessLevel {
    get {return _accessLevel ?? .unknown}
    set {_accessLevel = newValue}
  }
  /// Returns true if `accessLevel` has been explicitly set.
  var hasAccessLevel: Bool {return self._accessLevel != nil}
  /// Clears the value of `accessLevel`. Subsequent reads from it will return its default value.
  mutating func clearAccessLevel() {self._accessLevel = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _updaterAci: Data? = nil
  fileprivate var _accessLevel: BackupProtos_GroupV2AccessLevel? = nil
}

struct BackupProtos_GroupAttributesAccessLevelChangeUpdate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var updaterAci: Data {
    get {return _updaterAci ?? Data()}
    set {_updaterAci = newValue}
  }
  /// Returns true if `updaterAci` has been explicitly set.
  var hasUpdaterAci: Bool {return self._updaterAci != nil}
  /// Clears the value of `updaterAci`. Subsequent reads from it will return its default value.
  mutating func clearUpdaterAci() {self._updaterAci = nil}

  var accessLevel: BackupProtos_GroupV2AccessLevel {
    get {return _accessLevel ?? .unknown}
    set {_accessLevel = newValue}
  }
  /// Returns true if `accessLevel` has been explicitly set.
  var hasAccessLevel: Bool {return self._accessLevel != nil}
  /// Clears the value of `accessLevel`. Subsequent reads from it will return its default value.
  mutating func clearAccessLevel() {self._accessLevel = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _updaterAci: Data? = nil
  fileprivate var _accessLevel: BackupProtos_GroupV2AccessLevel? = nil
}

struct BackupProtos_GroupAnnouncementOnlyChangeUpdate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var updaterAci: Data {
    get {return _updaterAci ?? Data()}
    set {_updaterAci = newValue}
  }
  /// Returns true if `updaterAci` has been explicitly set.
  var hasUpdaterAci: Bool {return self._updaterAci != nil}
  /// Clears the value of `updaterAci`. Subsequent reads from it will return its default value.
  mutating func clearUpdaterAci() {self._updaterAci = nil}

  /// @required
  var isAnnouncementOnly: Bool {
    get {return _isAnnouncementOnly ?? false}
    set {_isAnnouncementOnly = newValue}
  }
  /// Returns true if `isAnnouncementOnly` has been explicitly set.
  var hasIsAnnouncementOnly: Bool {return self._isAnnouncementOnly != nil}
  /// Clears the value of `isAnnouncementOnly`. Subsequent reads from it will return its default value.
  mutating func clearIsAnnouncementOnly() {self._isAnnouncementOnly = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _updaterAci: Data? = nil
  fileprivate var _isAnnouncementOnly: Bool? = nil
}

struct BackupProtos_GroupAdminStatusUpdate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var updaterAci: Data {
    get {return _updaterAci ?? Data()}
    set {_updaterAci = newValue}
  }
  /// Returns true if `updaterAci` has been explicitly set.
  var hasUpdaterAci: Bool {return self._updaterAci != nil}
  /// Clears the value of `updaterAci`. Subsequent reads from it will return its default value.
  mutating func clearUpdaterAci() {self._updaterAci = nil}

  /// The aci who had admin status granted or revoked.
  /// @required
  var memberAci: Data {
    get {return _memberAci ?? Data()}
    set {_memberAci = newValue}
  }
  /// Returns true if `memberAci` has been explicitly set.
  var hasMemberAci: Bool {return self._memberAci != nil}
  /// Clears the value of `memberAci`. Subsequent reads from it will return its default value.
  mutating func clearMemberAci() {self._memberAci = nil}

  /// @required
  var wasAdminStatusGranted: Bool {
    get {return _wasAdminStatusGranted ?? false}
    set {_wasAdminStatusGranted = newValue}
  }
  /// Returns true if `wasAdminStatusGranted` has been explicitly set.
  var hasWasAdminStatusGranted: Bool {return self._wasAdminStatusGranted != nil}
  /// Clears the value of `wasAdminStatusGranted`. Subsequent reads from it will return its default value.
  mutating func clearWasAdminStatusGranted() {self._wasAdminStatusGranted = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _updaterAci: Data? = nil
  fileprivate var _memberAci: Data? = nil
  fileprivate var _wasAdminStatusGranted: Bool? = nil
}

struct BackupProtos_GroupMemberLeftUpdate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// @required
  var aci: Data {
    get {return _aci ?? Data()}
    set {_aci = newValue}
  }
  /// Returns true if `aci` has been explicitly set.
  var hasAci: Bool {return self._aci != nil}
  /// Clears the value of `aci`. Subsequent reads from it will return its default value.
  mutating func clearAci() {self._aci = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _aci: Data? = nil
}

struct BackupProtos_GroupMemberRemovedUpdate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var removerAci: Data {
    get {return _removerAci ?? Data()}
    set {_removerAci = newValue}
  }
  /// Returns true if `removerAci` has been explicitly set.
  var hasRemoverAci: Bool {return self._removerAci != nil}
  /// Clears the value of `removerAci`. Subsequent reads from it will return its default value.
  mutating func clearRemoverAci() {self._removerAci = nil}

  /// @required
  var removedAci: Data {
    get {return _removedAci ?? Data()}
    set {_removedAci = newValue}
  }
  /// Returns true if `removedAci` has been explicitly set.
  var hasRemovedAci: Bool {return self._removedAci != nil}
  /// Clears the value of `removedAci`. Subsequent reads from it will return its default value.
  mutating func clearRemovedAci() {self._removedAci = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _removerAci: Data? = nil
  fileprivate var _removedAci: Data? = nil
}

struct BackupProtos_SelfInvitedToGroupUpdate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var inviterAci: Data {
    get {return _inviterAci ?? Data()}
    set {_inviterAci = newValue}
  }
  /// Returns true if `inviterAci` has been explicitly set.
  var hasInviterAci: Bool {return self._inviterAci != nil}
  /// Clears the value of `inviterAci`. Subsequent reads from it will return its default value.
  mutating func clearInviterAci() {self._inviterAci = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _inviterAci: Data? = nil
}

struct BackupProtos_SelfInvitedOtherUserToGroupUpdate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// If no invitee id available, use GroupUnknownInviteeUpdate
  /// @required
  var inviteeServiceID: Data {
    get {return _inviteeServiceID ?? Data()}
    set {_inviteeServiceID = newValue}
  }
  /// Returns true if `inviteeServiceID` has been explicitly set.
  var hasInviteeServiceID: Bool {return self._inviteeServiceID != nil}
  /// Clears the value of `inviteeServiceID`. Subsequent reads from it will return its default value.
  mutating func clearInviteeServiceID() {self._inviteeServiceID = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _inviteeServiceID: Data? = nil
}

struct BackupProtos_GroupUnknownInviteeUpdate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Can be the self user.
  var inviterAci: Data {
    get {return _inviterAci ?? Data()}
    set {_inviterAci = newValue}
  }
  /// Returns true if `inviterAci` has been explicitly set.
  var hasInviterAci: Bool {return self._inviterAci != nil}
  /// Clears the value of `inviterAci`. Subsequent reads from it will return its default value.
  mutating func clearInviterAci() {self._inviterAci = nil}

  /// @required
  var inviteeCount: UInt32 {
    get {return _inviteeCount ?? 0}
    set {_inviteeCount = newValue}
  }
  /// Returns true if `inviteeCount` has been explicitly set.
  var hasInviteeCount: Bool {return self._inviteeCount != nil}
  /// Clears the value of `inviteeCount`. Subsequent reads from it will return its default value.
  mutating func clearInviteeCount() {self._inviteeCount = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _inviterAci: Data? = nil
  fileprivate var _inviteeCount: UInt32? = nil
}

struct BackupProtos_GroupInvitationAcceptedUpdate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var inviterAci: Data {
    get {return _inviterAci ?? Data()}
    set {_inviterAci = newValue}
  }
  /// Returns true if `inviterAci` has been explicitly set.
  var hasInviterAci: Bool {return self._inviterAci != nil}
  /// Clears the value of `inviterAci`. Subsequent reads from it will return its default value.
  mutating func clearInviterAci() {self._inviterAci = nil}

  /// @required
  var newMemberAci: Data {
    get {return _newMemberAci ?? Data()}
    set {_newMemberAci = newValue}
  }
  /// Returns true if `newMemberAci` has been explicitly set.
  var hasNewMemberAci: Bool {return self._newMemberAci != nil}
  /// Clears the value of `newMemberAci`. Subsequent reads from it will return its default value.
  mutating func clearNewMemberAci() {self._newMemberAci = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _inviterAci: Data? = nil
  fileprivate var _newMemberAci: Data? = nil
}

struct BackupProtos_GroupInvitationDeclinedUpdate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var inviterAci: Data {
    get {return _inviterAci ?? Data()}
    set {_inviterAci = newValue}
  }
  /// Returns true if `inviterAci` has been explicitly set.
  var hasInviterAci: Bool {return self._inviterAci != nil}
  /// Clears the value of `inviterAci`. Subsequent reads from it will return its default value.
  mutating func clearInviterAci() {self._inviterAci = nil}

  /// Note: if invited by pni, just set inviteeAci to nil.
  var inviteeAci: Data {
    get {return _inviteeAci ?? Data()}
    set {_inviteeAci = newValue}
  }
  /// Returns true if `inviteeAci` has been explicitly set.
  var hasInviteeAci: Bool {return self._inviteeAci != nil}
  /// Clears the value of `inviteeAci`. Subsequent reads from it will return its default value.
  mutating func clearInviteeAci() {self._inviteeAci = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _inviterAci: Data? = nil
  fileprivate var _inviteeAci: Data? = nil
}

struct BackupProtos_GroupMemberJoinedUpdate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// @required
  var newMemberAci: Data {
    get {return _newMemberAci ?? Data()}
    set {_newMemberAci = newValue}
  }
  /// Returns true if `newMemberAci` has been explicitly set.
  var hasNewMemberAci: Bool {return self._newMemberAci != nil}
  /// Clears the value of `newMemberAci`. Subsequent reads from it will return its default value.
  mutating func clearNewMemberAci() {self._newMemberAci = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _newMemberAci: Data? = nil
}

struct BackupProtos_GroupMemberAddedUpdate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var updaterAci: Data {
    get {return _updaterAci ?? Data()}
    set {_updaterAci = newValue}
  }
  /// Returns true if `updaterAci` has been explicitly set.
  var hasUpdaterAci: Bool {return self._updaterAci != nil}
  /// Clears the value of `updaterAci`. Subsequent reads from it will return its default value.
  mutating func clearUpdaterAci() {self._updaterAci = nil}

  /// @required
  var newMemberAci: Data {
    get {return _newMemberAci ?? Data()}
    set {_newMemberAci = newValue}
  }
  /// Returns true if `newMemberAci` has been explicitly set.
  var hasNewMemberAci: Bool {return self._newMemberAci != nil}
  /// Clears the value of `newMemberAci`. Subsequent reads from it will return its default value.
  mutating func clearNewMemberAci() {self._newMemberAci = nil}

  /// @required
  var hadOpenInvitation: Bool {
    get {return _hadOpenInvitation ?? false}
    set {_hadOpenInvitation = newValue}
  }
  /// Returns true if `hadOpenInvitation` has been explicitly set.
  var hasHadOpenInvitation: Bool {return self._hadOpenInvitation != nil}
  /// Clears the value of `hadOpenInvitation`. Subsequent reads from it will return its default value.
  mutating func clearHadOpenInvitation() {self._hadOpenInvitation = nil}

  /// If hadOpenInvitation is true, optionally include aci of the inviter.
  var inviterAci: Data {
    get {return _inviterAci ?? Data()}
    set {_inviterAci = newValue}
  }
  /// Returns true if `inviterAci` has been explicitly set.
  var hasInviterAci: Bool {return self._inviterAci != nil}
  /// Clears the value of `inviterAci`. Subsequent reads from it will return its default value.
  mutating func clearInviterAci() {self._inviterAci = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _updaterAci: Data? = nil
  fileprivate var _newMemberAci: Data? = nil
  fileprivate var _hadOpenInvitation: Bool? = nil
  fileprivate var _inviterAci: Data? = nil
}

/// An invitation to self was revoked.
struct BackupProtos_GroupSelfInvitationRevokedUpdate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var revokerAci: Data {
    get {return _revokerAci ?? Data()}
    set {_revokerAci = newValue}
  }
  /// Returns true if `revokerAci` has been explicitly set.
  var hasRevokerAci: Bool {return self._revokerAci != nil}
  /// Clears the value of `revokerAci`. Subsequent reads from it will return its default value.
  mutating func clearRevokerAci() {self._revokerAci = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _revokerAci: Data? = nil
}

/// These invitees should never be the local user.
/// Use GroupSelfInvitationRevokedUpdate in those cases.
/// The inviter or updater can be the local user.
struct BackupProtos_GroupInvitationRevokedUpdate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The member that revoked the invite(s), not the inviter!
  /// Assumed to be an admin (at the time, may no longer be an
  /// admin or even a member).
  var updaterAci: Data {
    get {return _updaterAci ?? Data()}
    set {_updaterAci = newValue}
  }
  /// Returns true if `updaterAci` has been explicitly set.
  var hasUpdaterAci: Bool {return self._updaterAci != nil}
  /// Clears the value of `updaterAci`. Subsequent reads from it will return its default value.
  mutating func clearUpdaterAci() {self._updaterAci = nil}

  var invitees: [BackupProtos_GroupInvitationRevokedUpdate.Invitee] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct Invitee {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var inviterAci: Data {
      get {return _inviterAci ?? Data()}
      set {_inviterAci = newValue}
    }
    /// Returns true if `inviterAci` has been explicitly set.
    var hasInviterAci: Bool {return self._inviterAci != nil}
    /// Clears the value of `inviterAci`. Subsequent reads from it will return its default value.
    mutating func clearInviterAci() {self._inviterAci = nil}

    /// Prefer to use aci over pni. No need to set
    /// pni if aci is set. Both can be missing.
    var inviteeAci: Data {
      get {return _inviteeAci ?? Data()}
      set {_inviteeAci = newValue}
    }
    /// Returns true if `inviteeAci` has been explicitly set.
    var hasInviteeAci: Bool {return self._inviteeAci != nil}
    /// Clears the value of `inviteeAci`. Subsequent reads from it will return its default value.
    mutating func clearInviteeAci() {self._inviteeAci = nil}

    var inviteePni: Data {
      get {return _inviteePni ?? Data()}
      set {_inviteePni = newValue}
    }
    /// Returns true if `inviteePni` has been explicitly set.
    var hasInviteePni: Bool {return self._inviteePni != nil}
    /// Clears the value of `inviteePni`. Subsequent reads from it will return its default value.
    mutating func clearInviteePni() {self._inviteePni = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _inviterAci: Data? = nil
    fileprivate var _inviteeAci: Data? = nil
    fileprivate var _inviteePni: Data? = nil
  }

  init() {}

  fileprivate var _updaterAci: Data? = nil
}

struct BackupProtos_GroupJoinRequestUpdate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// @required
  var requestorAci: Data {
    get {return _requestorAci ?? Data()}
    set {_requestorAci = newValue}
  }
  /// Returns true if `requestorAci` has been explicitly set.
  var hasRequestorAci: Bool {return self._requestorAci != nil}
  /// Clears the value of `requestorAci`. Subsequent reads from it will return its default value.
  mutating func clearRequestorAci() {self._requestorAci = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _requestorAci: Data? = nil
}

struct BackupProtos_GroupJoinRequestApprovalUpdate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// @required
  var requestorAci: Data {
    get {return _requestorAci ?? Data()}
    set {_requestorAci = newValue}
  }
  /// Returns true if `requestorAci` has been explicitly set.
  var hasRequestorAci: Bool {return self._requestorAci != nil}
  /// Clears the value of `requestorAci`. Subsequent reads from it will return its default value.
  mutating func clearRequestorAci() {self._requestorAci = nil}

  /// The aci that approved or rejected the request.
  var updaterAci: Data {
    get {return _updaterAci ?? Data()}
    set {_updaterAci = newValue}
  }
  /// Returns true if `updaterAci` has been explicitly set.
  var hasUpdaterAci: Bool {return self._updaterAci != nil}
  /// Clears the value of `updaterAci`. Subsequent reads from it will return its default value.
  mutating func clearUpdaterAci() {self._updaterAci = nil}

  /// @required
  var wasApproved: Bool {
    get {return _wasApproved ?? false}
    set {_wasApproved = newValue}
  }
  /// Returns true if `wasApproved` has been explicitly set.
  var hasWasApproved: Bool {return self._wasApproved != nil}
  /// Clears the value of `wasApproved`. Subsequent reads from it will return its default value.
  mutating func clearWasApproved() {self._wasApproved = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _requestorAci: Data? = nil
  fileprivate var _updaterAci: Data? = nil
  fileprivate var _wasApproved: Bool? = nil
}

struct BackupProtos_GroupJoinRequestCanceledUpdate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// @required
  var requestorAci: Data {
    get {return _requestorAci ?? Data()}
    set {_requestorAci = newValue}
  }
  /// Returns true if `requestorAci` has been explicitly set.
  var hasRequestorAci: Bool {return self._requestorAci != nil}
  /// Clears the value of `requestorAci`. Subsequent reads from it will return its default value.
  mutating func clearRequestorAci() {self._requestorAci = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _requestorAci: Data? = nil
}

/// A single requestor has requested to join and cancelled
/// their request repeatedly with no other updates in between.
/// The last action encompassed by this update is always a
/// cancellation; if there was another open request immediately
/// after, it will be a separate GroupJoinRequestUpdate, either
/// in the same frame or in a subsequent frame.
struct BackupProtos_GroupSequenceOfRequestsAndCancelsUpdate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// @required
  var requestorAci: Data {
    get {return _requestorAci ?? Data()}
    set {_requestorAci = newValue}
  }
  /// Returns true if `requestorAci` has been explicitly set.
  var hasRequestorAci: Bool {return self._requestorAci != nil}
  /// Clears the value of `requestorAci`. Subsequent reads from it will return its default value.
  mutating func clearRequestorAci() {self._requestorAci = nil}

  /// @required
  var count: UInt32 {
    get {return _count ?? 0}
    set {_count = newValue}
  }
  /// Returns true if `count` has been explicitly set.
  var hasCount: Bool {return self._count != nil}
  /// Clears the value of `count`. Subsequent reads from it will return its default value.
  mutating func clearCount() {self._count = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _requestorAci: Data? = nil
  fileprivate var _count: UInt32? = nil
}

struct BackupProtos_GroupInviteLinkResetUpdate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var updaterAci: Data {
    get {return _updaterAci ?? Data()}
    set {_updaterAci = newValue}
  }
  /// Returns true if `updaterAci` has been explicitly set.
  var hasUpdaterAci: Bool {return self._updaterAci != nil}
  /// Clears the value of `updaterAci`. Subsequent reads from it will return its default value.
  mutating func clearUpdaterAci() {self._updaterAci = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _updaterAci: Data? = nil
}

struct BackupProtos_GroupInviteLinkEnabledUpdate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var updaterAci: Data {
    get {return _updaterAci ?? Data()}
    set {_updaterAci = newValue}
  }
  /// Returns true if `updaterAci` has been explicitly set.
  var hasUpdaterAci: Bool {return self._updaterAci != nil}
  /// Clears the value of `updaterAci`. Subsequent reads from it will return its default value.
  mutating func clearUpdaterAci() {self._updaterAci = nil}

  /// @required
  var linkRequiresAdminApproval: Bool {
    get {return _linkRequiresAdminApproval ?? false}
    set {_linkRequiresAdminApproval = newValue}
  }
  /// Returns true if `linkRequiresAdminApproval` has been explicitly set.
  var hasLinkRequiresAdminApproval: Bool {return self._linkRequiresAdminApproval != nil}
  /// Clears the value of `linkRequiresAdminApproval`. Subsequent reads from it will return its default value.
  mutating func clearLinkRequiresAdminApproval() {self._linkRequiresAdminApproval = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _updaterAci: Data? = nil
  fileprivate var _linkRequiresAdminApproval: Bool? = nil
}

struct BackupProtos_GroupInviteLinkAdminApprovalUpdate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var updaterAci: Data {
    get {return _updaterAci ?? Data()}
    set {_updaterAci = newValue}
  }
  /// Returns true if `updaterAci` has been explicitly set.
  var hasUpdaterAci: Bool {return self._updaterAci != nil}
  /// Clears the value of `updaterAci`. Subsequent reads from it will return its default value.
  mutating func clearUpdaterAci() {self._updaterAci = nil}

  /// @required
  var linkRequiresAdminApproval: Bool {
    get {return _linkRequiresAdminApproval ?? false}
    set {_linkRequiresAdminApproval = newValue}
  }
  /// Returns true if `linkRequiresAdminApproval` has been explicitly set.
  var hasLinkRequiresAdminApproval: Bool {return self._linkRequiresAdminApproval != nil}
  /// Clears the value of `linkRequiresAdminApproval`. Subsequent reads from it will return its default value.
  mutating func clearLinkRequiresAdminApproval() {self._linkRequiresAdminApproval = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _updaterAci: Data? = nil
  fileprivate var _linkRequiresAdminApproval: Bool? = nil
}

struct BackupProtos_GroupInviteLinkDisabledUpdate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var updaterAci: Data {
    get {return _updaterAci ?? Data()}
    set {_updaterAci = newValue}
  }
  /// Returns true if `updaterAci` has been explicitly set.
  var hasUpdaterAci: Bool {return self._updaterAci != nil}
  /// Clears the value of `updaterAci`. Subsequent reads from it will return its default value.
  mutating func clearUpdaterAci() {self._updaterAci = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _updaterAci: Data? = nil
}

struct BackupProtos_GroupMemberJoinedByLinkUpdate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// @required
  var newMemberAci: Data {
    get {return _newMemberAci ?? Data()}
    set {_newMemberAci = newValue}
  }
  /// Returns true if `newMemberAci` has been explicitly set.
  var hasNewMemberAci: Bool {return self._newMemberAci != nil}
  /// Clears the value of `newMemberAci`. Subsequent reads from it will return its default value.
  mutating func clearNewMemberAci() {self._newMemberAci = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _newMemberAci: Data? = nil
}

/// A gv1->gv2 migration occurred.
struct BackupProtos_GroupV2MigrationUpdate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Another user migrated gv1->gv2 but was unable to add
/// the local user and invited them instead.
struct BackupProtos_GroupV2MigrationSelfInvitedUpdate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// The local user migrated gv1->gv2 but was unable to
/// add some members and invited them instead.
/// (Happens if we don't have the invitee's profile key)
struct BackupProtos_GroupV2MigrationInvitedMembersUpdate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// @required
  var invitedMembersCount: UInt32 {
    get {return _invitedMembersCount ?? 0}
    set {_invitedMembersCount = newValue}
  }
  /// Returns true if `invitedMembersCount` has been explicitly set.
  var hasInvitedMembersCount: Bool {return self._invitedMembersCount != nil}
  /// Clears the value of `invitedMembersCount`. Subsequent reads from it will return its default value.
  mutating func clearInvitedMembersCount() {self._invitedMembersCount = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _invitedMembersCount: UInt32? = nil
}

/// The local user migrated gv1->gv2 but was unable to
/// add or invite some members and dropped them instead.
/// (Happens for e164 members where we don't have an aci).
struct BackupProtos_GroupV2MigrationDroppedMembersUpdate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// @required
  var droppedMembersCount: UInt32 {
    get {return _droppedMembersCount ?? 0}
    set {_droppedMembersCount = newValue}
  }
  /// Returns true if `droppedMembersCount` has been explicitly set.
  var hasDroppedMembersCount: Bool {return self._droppedMembersCount != nil}
  /// Clears the value of `droppedMembersCount`. Subsequent reads from it will return its default value.
  mutating func clearDroppedMembersCount() {self._droppedMembersCount = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _droppedMembersCount: UInt32? = nil
}

/// For 1:1 timer updates, use ExpirationTimerChatUpdate.
struct BackupProtos_GroupExpirationTimerUpdate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// @required
  var expiresInMs: UInt32 {
    get {return _expiresInMs ?? 0}
    set {_expiresInMs = newValue}
  }
  /// Returns true if `expiresInMs` has been explicitly set.
  var hasExpiresInMs: Bool {return self._expiresInMs != nil}
  /// Clears the value of `expiresInMs`. Subsequent reads from it will return its default value.
  mutating func clearExpiresInMs() {self._expiresInMs = nil}

  var updaterAci: Data {
    get {return _updaterAci ?? Data()}
    set {_updaterAci = newValue}
  }
  /// Returns true if `updaterAci` has been explicitly set.
  var hasUpdaterAci: Bool {return self._updaterAci != nil}
  /// Clears the value of `updaterAci`. Subsequent reads from it will return its default value.
  mutating func clearUpdaterAci() {self._updaterAci = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _expiresInMs: UInt32? = nil
  fileprivate var _updaterAci: Data? = nil
}

struct BackupProtos_StickerPack {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// @required
  var id: Data {
    get {return _id ?? Data()}
    set {_id = newValue}
  }
  /// Returns true if `id` has been explicitly set.
  var hasID: Bool {return self._id != nil}
  /// Clears the value of `id`. Subsequent reads from it will return its default value.
  mutating func clearID() {self._id = nil}

  /// @required
  var key: Data {
    get {return _key ?? Data()}
    set {_key = newValue}
  }
  /// Returns true if `key` has been explicitly set.
  var hasKey: Bool {return self._key != nil}
  /// Clears the value of `key`. Subsequent reads from it will return its default value.
  mutating func clearKey() {self._key = nil}

  /// @required
  var title: String {
    get {return _title ?? String()}
    set {_title = newValue}
  }
  /// Returns true if `title` has been explicitly set.
  var hasTitle: Bool {return self._title != nil}
  /// Clears the value of `title`. Subsequent reads from it will return its default value.
  mutating func clearTitle() {self._title = nil}

  /// @required
  var author: String {
    get {return _author ?? String()}
    set {_author = newValue}
  }
  /// Returns true if `author` has been explicitly set.
  var hasAuthor: Bool {return self._author != nil}
  /// Clears the value of `author`. Subsequent reads from it will return its default value.
  mutating func clearAuthor() {self._author = nil}

  /// First one should be cover sticker.
  var stickers: [BackupProtos_StickerPackSticker] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _id: Data? = nil
  fileprivate var _key: Data? = nil
  fileprivate var _title: String? = nil
  fileprivate var _author: String? = nil
}

struct BackupProtos_StickerPackSticker {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// @required
  var data: BackupProtos_FilePointer {
    get {return _data ?? BackupProtos_FilePointer()}
    set {_data = newValue}
  }
  /// Returns true if `data` has been explicitly set.
  var hasData: Bool {return self._data != nil}
  /// Clears the value of `data`. Subsequent reads from it will return its default value.
  mutating func clearData() {self._data = nil}

  /// @required
  var emoji: String {
    get {return _emoji ?? String()}
    set {_emoji = newValue}
  }
  /// Returns true if `emoji` has been explicitly set.
  var hasEmoji: Bool {return self._emoji != nil}
  /// Clears the value of `emoji`. Subsequent reads from it will return its default value.
  mutating func clearEmoji() {self._emoji = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _data: BackupProtos_FilePointer? = nil
  fileprivate var _emoji: String? = nil
}

#if swift(>=5.5) && canImport(_Concurrency)
extension BackupProtos_GroupV2AccessLevel: @unchecked Sendable {}
extension BackupProtos_BackupInfo: @unchecked Sendable {}
extension BackupProtos_Frame: @unchecked Sendable {}
extension BackupProtos_AccountData: @unchecked Sendable {}
extension BackupProtos_AccountData.PhoneNumberSharingMode: @unchecked Sendable {}
extension BackupProtos_AccountData.UsernameLink: @unchecked Sendable {}
extension BackupProtos_AccountData.UsernameLink.Color: @unchecked Sendable {}
extension BackupProtos_AccountData.AccountSettings: @unchecked Sendable {}
extension BackupProtos_Recipient: @unchecked Sendable {}
extension BackupProtos_Contact: @unchecked Sendable {}
extension BackupProtos_Contact.Registered: @unchecked Sendable {}
extension BackupProtos_Group: @unchecked Sendable {}
extension BackupProtos_Group.StorySendMode: @unchecked Sendable {}
extension BackupProtos_SelfRecipient: @unchecked Sendable {}
extension BackupProtos_ReleaseNotes: @unchecked Sendable {}
extension BackupProtos_Chat: @unchecked Sendable {}
extension BackupProtos_DistributionList: @unchecked Sendable {}
extension BackupProtos_DistributionList.PrivacyMode: @unchecked Sendable {}
extension BackupProtos_Identity: @unchecked Sendable {}
extension BackupProtos_Call: @unchecked Sendable {}
extension BackupProtos_Call.TypeEnum: @unchecked Sendable {}
extension BackupProtos_Call.Event: @unchecked Sendable {}
extension BackupProtos_ChatItem: @unchecked Sendable {}
extension BackupProtos_ChatItem.IncomingMessageDetails: @unchecked Sendable {}
extension BackupProtos_ChatItem.OutgoingMessageDetails: @unchecked Sendable {}
extension BackupProtos_ChatItem.DirectionlessMessageDetails: @unchecked Sendable {}
extension BackupProtos_SendStatus: @unchecked Sendable {}
extension BackupProtos_SendStatus.Status: @unchecked Sendable {}
extension BackupProtos_Text: @unchecked Sendable {}
extension BackupProtos_StandardMessage: @unchecked Sendable {}
extension BackupProtos_ContactMessage: @unchecked Sendable {}
extension BackupProtos_ContactAttachment: @unchecked Sendable {}
extension BackupProtos_ContactAttachment.Name: @unchecked Sendable {}
extension BackupProtos_ContactAttachment.Phone: @unchecked Sendable {}
extension BackupProtos_ContactAttachment.Phone.TypeEnum: @unchecked Sendable {}
extension BackupProtos_ContactAttachment.Email: @unchecked Sendable {}
extension BackupProtos_ContactAttachment.Email.TypeEnum: @unchecked Sendable {}
extension BackupProtos_ContactAttachment.PostalAddress: @unchecked Sendable {}
extension BackupProtos_ContactAttachment.PostalAddress.TypeEnum: @unchecked Sendable {}
extension BackupProtos_ContactAttachment.Avatar: @unchecked Sendable {}
extension BackupProtos_DocumentMessage: @unchecked Sendable {}
extension BackupProtos_VoiceMessage: @unchecked Sendable {}
extension BackupProtos_StickerMessage: @unchecked Sendable {}
extension BackupProtos_RemoteDeletedMessage: @unchecked Sendable {}
extension BackupProtos_Sticker: @unchecked Sendable {}
extension BackupProtos_LinkPreview: @unchecked Sendable {}
extension BackupProtos_FilePointer: @unchecked Sendable {}
extension BackupProtos_FilePointer.Flags: @unchecked Sendable {}
extension BackupProtos_FilePointer.BackupLocator: @unchecked Sendable {}
extension BackupProtos_FilePointer.AttachmentLocator: @unchecked Sendable {}
extension BackupProtos_FilePointer.LegacyAttachmentLocator: @unchecked Sendable {}
extension BackupProtos_FilePointer.UndownloadedBackupLocator: @unchecked Sendable {}
extension BackupProtos_Quote: @unchecked Sendable {}
extension BackupProtos_Quote.TypeEnum: @unchecked Sendable {}
extension BackupProtos_Quote.QuotedAttachment: @unchecked Sendable {}
extension BackupProtos_BodyRange: @unchecked Sendable {}
extension BackupProtos_BodyRange.Style: @unchecked Sendable {}
extension BackupProtos_Reaction: @unchecked Sendable {}
extension BackupProtos_ChatUpdateMessage: @unchecked Sendable {}
extension BackupProtos_CallChatUpdate: @unchecked Sendable {}
extension BackupProtos_IndividualCallChatUpdate: @unchecked Sendable {}
extension BackupProtos_IndividualCallChatUpdate.TypeEnum: @unchecked Sendable {}
extension BackupProtos_GroupCallChatUpdate: @unchecked Sendable {}
extension BackupProtos_SimpleChatUpdate: @unchecked Sendable {}
extension BackupProtos_SimpleChatUpdate.TypeEnum: @unchecked Sendable {}
extension BackupProtos_GroupDescriptionChatUpdate: @unchecked Sendable {}
extension BackupProtos_ExpirationTimerChatUpdate: @unchecked Sendable {}
extension BackupProtos_ProfileChangeChatUpdate: @unchecked Sendable {}
extension BackupProtos_ThreadMergeChatUpdate: @unchecked Sendable {}
extension BackupProtos_SessionSwitchoverChatUpdate: @unchecked Sendable {}
extension BackupProtos_GroupChangeChatUpdate: @unchecked Sendable {}
extension BackupProtos_GroupChangeChatUpdate.Update: @unchecked Sendable {}
extension BackupProtos_GenericGroupUpdate: @unchecked Sendable {}
extension BackupProtos_GroupCreationUpdate: @unchecked Sendable {}
extension BackupProtos_GroupNameUpdate: @unchecked Sendable {}
extension BackupProtos_GroupAvatarUpdate: @unchecked Sendable {}
extension BackupProtos_GroupDescriptionUpdate: @unchecked Sendable {}
extension BackupProtos_GroupMembershipAccessLevelChangeUpdate: @unchecked Sendable {}
extension BackupProtos_GroupAttributesAccessLevelChangeUpdate: @unchecked Sendable {}
extension BackupProtos_GroupAnnouncementOnlyChangeUpdate: @unchecked Sendable {}
extension BackupProtos_GroupAdminStatusUpdate: @unchecked Sendable {}
extension BackupProtos_GroupMemberLeftUpdate: @unchecked Sendable {}
extension BackupProtos_GroupMemberRemovedUpdate: @unchecked Sendable {}
extension BackupProtos_SelfInvitedToGroupUpdate: @unchecked Sendable {}
extension BackupProtos_SelfInvitedOtherUserToGroupUpdate: @unchecked Sendable {}
extension BackupProtos_GroupUnknownInviteeUpdate: @unchecked Sendable {}
extension BackupProtos_GroupInvitationAcceptedUpdate: @unchecked Sendable {}
extension BackupProtos_GroupInvitationDeclinedUpdate: @unchecked Sendable {}
extension BackupProtos_GroupMemberJoinedUpdate: @unchecked Sendable {}
extension BackupProtos_GroupMemberAddedUpdate: @unchecked Sendable {}
extension BackupProtos_GroupSelfInvitationRevokedUpdate: @unchecked Sendable {}
extension BackupProtos_GroupInvitationRevokedUpdate: @unchecked Sendable {}
extension BackupProtos_GroupInvitationRevokedUpdate.Invitee: @unchecked Sendable {}
extension BackupProtos_GroupJoinRequestUpdate: @unchecked Sendable {}
extension BackupProtos_GroupJoinRequestApprovalUpdate: @unchecked Sendable {}
extension BackupProtos_GroupJoinRequestCanceledUpdate: @unchecked Sendable {}
extension BackupProtos_GroupSequenceOfRequestsAndCancelsUpdate: @unchecked Sendable {}
extension BackupProtos_GroupInviteLinkResetUpdate: @unchecked Sendable {}
extension BackupProtos_GroupInviteLinkEnabledUpdate: @unchecked Sendable {}
extension BackupProtos_GroupInviteLinkAdminApprovalUpdate: @unchecked Sendable {}
extension BackupProtos_GroupInviteLinkDisabledUpdate: @unchecked Sendable {}
extension BackupProtos_GroupMemberJoinedByLinkUpdate: @unchecked Sendable {}
extension BackupProtos_GroupV2MigrationUpdate: @unchecked Sendable {}
extension BackupProtos_GroupV2MigrationSelfInvitedUpdate: @unchecked Sendable {}
extension BackupProtos_GroupV2MigrationInvitedMembersUpdate: @unchecked Sendable {}
extension BackupProtos_GroupV2MigrationDroppedMembersUpdate: @unchecked Sendable {}
extension BackupProtos_GroupExpirationTimerUpdate: @unchecked Sendable {}
extension BackupProtos_StickerPack: @unchecked Sendable {}
extension BackupProtos_StickerPackSticker: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "BackupProtos"

extension BackupProtos_GroupV2AccessLevel: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN"),
    1: .same(proto: "ANY"),
    2: .same(proto: "MEMBER"),
    3: .same(proto: "ADMINISTRATOR"),
    4: .same(proto: "UNSATISFIABLE"),
  ]
}

extension BackupProtos_BackupInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BackupInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "version"),
    2: .same(proto: "backupTimeMs"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self._version) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self._backupTimeMs) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._version {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._backupTimeMs {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: BackupProtos_BackupInfo, rhs: BackupProtos_BackupInfo) -> Bool {
    if lhs._version != rhs._version {return false}
    if lhs._backupTimeMs != rhs._backupTimeMs {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProtos_Frame: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Frame"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "account"),
    2: .same(proto: "recipient"),
    3: .same(proto: "chat"),
    4: .same(proto: "chatItem"),
    5: .same(proto: "call"),
    6: .same(proto: "stickerPack"),
  ]

  fileprivate class _StorageClass {
    var _account: BackupProtos_AccountData? = nil
    var _recipient: BackupProtos_Recipient? = nil
    var _chat: BackupProtos_Chat? = nil
    var _chatItem: BackupProtos_ChatItem? = nil
    var _call: BackupProtos_Call? = nil
    var _stickerPack: BackupProtos_StickerPack? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _account = source._account
      _recipient = source._recipient
      _chat = source._chat
      _chatItem = source._chatItem
      _call = source._call
      _stickerPack = source._stickerPack
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._account) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._recipient) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._chat) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._chatItem) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._call) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._stickerPack) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._account {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._recipient {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._chat {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._chatItem {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._call {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._stickerPack {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: BackupProtos_Frame, rhs: BackupProtos_Frame) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._account != rhs_storage._account {return false}
        if _storage._recipient != rhs_storage._recipient {return false}
        if _storage._chat != rhs_storage._chat {return false}
        if _storage._chatItem != rhs_storage._chatItem {return false}
        if _storage._call != rhs_storage._call {return false}
        if _storage._stickerPack != rhs_storage._stickerPack {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProtos_AccountData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AccountData"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "profileKey"),
    2: .same(proto: "username"),
    3: .same(proto: "usernameLink"),
    4: .same(proto: "givenName"),
    5: .same(proto: "familyName"),
    6: .same(proto: "avatarPath"),
    7: .same(proto: "subscriberId"),
    8: .same(proto: "subscriberCurrencyCode"),
    9: .same(proto: "subscriptionManuallyCancelled"),
    10: .same(proto: "accountSettings"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self._profileKey) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._username) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._usernameLink) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self._givenName) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self._familyName) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self._avatarPath) }()
      case 7: try { try decoder.decodeSingularBytesField(value: &self._subscriberID) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self._subscriberCurrencyCode) }()
      case 9: try { try decoder.decodeSingularBoolField(value: &self._subscriptionManuallyCancelled) }()
      case 10: try { try decoder.decodeSingularMessageField(value: &self._accountSettings) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._profileKey {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._username {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._usernameLink {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._givenName {
      try visitor.visitSingularStringField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._familyName {
      try visitor.visitSingularStringField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._avatarPath {
      try visitor.visitSingularStringField(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._subscriberID {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 7)
    } }()
    try { if let v = self._subscriberCurrencyCode {
      try visitor.visitSingularStringField(value: v, fieldNumber: 8)
    } }()
    try { if let v = self._subscriptionManuallyCancelled {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 9)
    } }()
    try { if let v = self._accountSettings {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: BackupProtos_AccountData, rhs: BackupProtos_AccountData) -> Bool {
    if lhs._profileKey != rhs._profileKey {return false}
    if lhs._username != rhs._username {return false}
    if lhs._usernameLink != rhs._usernameLink {return false}
    if lhs._givenName != rhs._givenName {return false}
    if lhs._familyName != rhs._familyName {return false}
    if lhs._avatarPath != rhs._avatarPath {return false}
    if lhs._subscriberID != rhs._subscriberID {return false}
    if lhs._subscriberCurrencyCode != rhs._subscriberCurrencyCode {return false}
    if lhs._subscriptionManuallyCancelled != rhs._subscriptionManuallyCancelled {return false}
    if lhs._accountSettings != rhs._accountSettings {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProtos_AccountData.PhoneNumberSharingMode: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN"),
    1: .same(proto: "EVERYBODY"),
    2: .same(proto: "NOBODY"),
  ]
}

extension BackupProtos_AccountData.UsernameLink: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = BackupProtos_AccountData.protoMessageName + ".UsernameLink"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "entropy"),
    2: .same(proto: "serverId"),
    3: .same(proto: "color"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self._entropy) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self._serverID) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self._color) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._entropy {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._serverID {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._color {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: BackupProtos_AccountData.UsernameLink, rhs: BackupProtos_AccountData.UsernameLink) -> Bool {
    if lhs._entropy != rhs._entropy {return false}
    if lhs._serverID != rhs._serverID {return false}
    if lhs._color != rhs._color {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProtos_AccountData.UsernameLink.Color: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN"),
    1: .same(proto: "BLUE"),
    2: .same(proto: "WHITE"),
    3: .same(proto: "GREY"),
    4: .same(proto: "OLIVE"),
    5: .same(proto: "GREEN"),
    6: .same(proto: "ORANGE"),
    7: .same(proto: "PINK"),
    8: .same(proto: "PURPLE"),
  ]
}

extension BackupProtos_AccountData.AccountSettings: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = BackupProtos_AccountData.protoMessageName + ".AccountSettings"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "readReceipts"),
    2: .same(proto: "sealedSenderIndicators"),
    3: .same(proto: "typingIndicators"),
    4: .same(proto: "noteToSelfMarkedUnread"),
    5: .same(proto: "linkPreviews"),
    6: .same(proto: "notDiscoverableByPhoneNumber"),
    7: .same(proto: "preferContactAvatars"),
    8: .same(proto: "universalExpireTimer"),
    9: .same(proto: "preferredReactionEmoji"),
    10: .same(proto: "displayBadgesOnProfile"),
    11: .same(proto: "keepMutedChatsArchived"),
    12: .same(proto: "myStoriesPrivacyHasBeenSet"),
    13: .same(proto: "onboardingStoryHasBeenViewed"),
    14: .same(proto: "storiesDisabled"),
    15: .same(proto: "storyViewReceiptsEnabled"),
    16: .same(proto: "groupStoryEducationSheetHasBeenSeen"),
    17: .same(proto: "usernameOnboardingHasBeenCompleted"),
    18: .same(proto: "phoneNumberSharingMode"),
  ]

  fileprivate class _StorageClass {
    var _readReceipts: Bool? = nil
    var _sealedSenderIndicators: Bool? = nil
    var _typingIndicators: Bool? = nil
    var _noteToSelfMarkedUnread: Bool? = nil
    var _linkPreviews: Bool? = nil
    var _notDiscoverableByPhoneNumber: Bool? = nil
    var _preferContactAvatars: Bool? = nil
    var _universalExpireTimer: UInt32? = nil
    var _preferredReactionEmoji: [String] = []
    var _displayBadgesOnProfile: Bool? = nil
    var _keepMutedChatsArchived: Bool? = nil
    var _myStoriesPrivacyHasBeenSet: Bool? = nil
    var _onboardingStoryHasBeenViewed: Bool? = nil
    var _storiesDisabled: Bool? = nil
    var _storyViewReceiptsEnabled: Bool? = nil
    var _groupStoryEducationSheetHasBeenSeen: Bool? = nil
    var _usernameOnboardingHasBeenCompleted: Bool? = nil
    var _phoneNumberSharingMode: BackupProtos_AccountData.PhoneNumberSharingMode? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _readReceipts = source._readReceipts
      _sealedSenderIndicators = source._sealedSenderIndicators
      _typingIndicators = source._typingIndicators
      _noteToSelfMarkedUnread = source._noteToSelfMarkedUnread
      _linkPreviews = source._linkPreviews
      _notDiscoverableByPhoneNumber = source._notDiscoverableByPhoneNumber
      _preferContactAvatars = source._preferContactAvatars
      _universalExpireTimer = source._universalExpireTimer
      _preferredReactionEmoji = source._preferredReactionEmoji
      _displayBadgesOnProfile = source._displayBadgesOnProfile
      _keepMutedChatsArchived = source._keepMutedChatsArchived
      _myStoriesPrivacyHasBeenSet = source._myStoriesPrivacyHasBeenSet
      _onboardingStoryHasBeenViewed = source._onboardingStoryHasBeenViewed
      _storiesDisabled = source._storiesDisabled
      _storyViewReceiptsEnabled = source._storyViewReceiptsEnabled
      _groupStoryEducationSheetHasBeenSeen = source._groupStoryEducationSheetHasBeenSeen
      _usernameOnboardingHasBeenCompleted = source._usernameOnboardingHasBeenCompleted
      _phoneNumberSharingMode = source._phoneNumberSharingMode
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularBoolField(value: &_storage._readReceipts) }()
        case 2: try { try decoder.decodeSingularBoolField(value: &_storage._sealedSenderIndicators) }()
        case 3: try { try decoder.decodeSingularBoolField(value: &_storage._typingIndicators) }()
        case 4: try { try decoder.decodeSingularBoolField(value: &_storage._noteToSelfMarkedUnread) }()
        case 5: try { try decoder.decodeSingularBoolField(value: &_storage._linkPreviews) }()
        case 6: try { try decoder.decodeSingularBoolField(value: &_storage._notDiscoverableByPhoneNumber) }()
        case 7: try { try decoder.decodeSingularBoolField(value: &_storage._preferContactAvatars) }()
        case 8: try { try decoder.decodeSingularUInt32Field(value: &_storage._universalExpireTimer) }()
        case 9: try { try decoder.decodeRepeatedStringField(value: &_storage._preferredReactionEmoji) }()
        case 10: try { try decoder.decodeSingularBoolField(value: &_storage._displayBadgesOnProfile) }()
        case 11: try { try decoder.decodeSingularBoolField(value: &_storage._keepMutedChatsArchived) }()
        case 12: try { try decoder.decodeSingularBoolField(value: &_storage._myStoriesPrivacyHasBeenSet) }()
        case 13: try { try decoder.decodeSingularBoolField(value: &_storage._onboardingStoryHasBeenViewed) }()
        case 14: try { try decoder.decodeSingularBoolField(value: &_storage._storiesDisabled) }()
        case 15: try { try decoder.decodeSingularBoolField(value: &_storage._storyViewReceiptsEnabled) }()
        case 16: try { try decoder.decodeSingularBoolField(value: &_storage._groupStoryEducationSheetHasBeenSeen) }()
        case 17: try { try decoder.decodeSingularBoolField(value: &_storage._usernameOnboardingHasBeenCompleted) }()
        case 18: try { try decoder.decodeSingularEnumField(value: &_storage._phoneNumberSharingMode) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._readReceipts {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._sealedSenderIndicators {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._typingIndicators {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._noteToSelfMarkedUnread {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._linkPreviews {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._notDiscoverableByPhoneNumber {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._preferContactAvatars {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._universalExpireTimer {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 8)
      } }()
      if !_storage._preferredReactionEmoji.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._preferredReactionEmoji, fieldNumber: 9)
      }
      try { if let v = _storage._displayBadgesOnProfile {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 10)
      } }()
      try { if let v = _storage._keepMutedChatsArchived {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 11)
      } }()
      try { if let v = _storage._myStoriesPrivacyHasBeenSet {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 12)
      } }()
      try { if let v = _storage._onboardingStoryHasBeenViewed {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 13)
      } }()
      try { if let v = _storage._storiesDisabled {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 14)
      } }()
      try { if let v = _storage._storyViewReceiptsEnabled {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 15)
      } }()
      try { if let v = _storage._groupStoryEducationSheetHasBeenSeen {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 16)
      } }()
      try { if let v = _storage._usernameOnboardingHasBeenCompleted {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 17)
      } }()
      try { if let v = _storage._phoneNumberSharingMode {
        try visitor.visitSingularEnumField(value: v, fieldNumber: 18)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: BackupProtos_AccountData.AccountSettings, rhs: BackupProtos_AccountData.AccountSettings) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._readReceipts != rhs_storage._readReceipts {return false}
        if _storage._sealedSenderIndicators != rhs_storage._sealedSenderIndicators {return false}
        if _storage._typingIndicators != rhs_storage._typingIndicators {return false}
        if _storage._noteToSelfMarkedUnread != rhs_storage._noteToSelfMarkedUnread {return false}
        if _storage._linkPreviews != rhs_storage._linkPreviews {return false}
        if _storage._notDiscoverableByPhoneNumber != rhs_storage._notDiscoverableByPhoneNumber {return false}
        if _storage._preferContactAvatars != rhs_storage._preferContactAvatars {return false}
        if _storage._universalExpireTimer != rhs_storage._universalExpireTimer {return false}
        if _storage._preferredReactionEmoji != rhs_storage._preferredReactionEmoji {return false}
        if _storage._displayBadgesOnProfile != rhs_storage._displayBadgesOnProfile {return false}
        if _storage._keepMutedChatsArchived != rhs_storage._keepMutedChatsArchived {return false}
        if _storage._myStoriesPrivacyHasBeenSet != rhs_storage._myStoriesPrivacyHasBeenSet {return false}
        if _storage._onboardingStoryHasBeenViewed != rhs_storage._onboardingStoryHasBeenViewed {return false}
        if _storage._storiesDisabled != rhs_storage._storiesDisabled {return false}
        if _storage._storyViewReceiptsEnabled != rhs_storage._storyViewReceiptsEnabled {return false}
        if _storage._groupStoryEducationSheetHasBeenSeen != rhs_storage._groupStoryEducationSheetHasBeenSeen {return false}
        if _storage._usernameOnboardingHasBeenCompleted != rhs_storage._usernameOnboardingHasBeenCompleted {return false}
        if _storage._phoneNumberSharingMode != rhs_storage._phoneNumberSharingMode {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProtos_Recipient: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Recipient"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "contact"),
    3: .same(proto: "group"),
    4: .same(proto: "distributionList"),
    5: .same(proto: "selfRecipient"),
    6: .same(proto: "releaseNotes"),
  ]

  fileprivate class _StorageClass {
    var _id: UInt64? = nil
    var _contact: BackupProtos_Contact? = nil
    var _group: BackupProtos_Group? = nil
    var _distributionList: BackupProtos_DistributionList? = nil
    var _selfRecipient: BackupProtos_SelfRecipient? = nil
    var _releaseNotes: BackupProtos_ReleaseNotes? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _id = source._id
      _contact = source._contact
      _group = source._group
      _distributionList = source._distributionList
      _selfRecipient = source._selfRecipient
      _releaseNotes = source._releaseNotes
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularUInt64Field(value: &_storage._id) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._contact) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._group) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._distributionList) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._selfRecipient) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._releaseNotes) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._id {
        try visitor.visitSingularUInt64Field(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._contact {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._group {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._distributionList {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._selfRecipient {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._releaseNotes {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: BackupProtos_Recipient, rhs: BackupProtos_Recipient) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._id != rhs_storage._id {return false}
        if _storage._contact != rhs_storage._contact {return false}
        if _storage._group != rhs_storage._group {return false}
        if _storage._distributionList != rhs_storage._distributionList {return false}
        if _storage._selfRecipient != rhs_storage._selfRecipient {return false}
        if _storage._releaseNotes != rhs_storage._releaseNotes {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProtos_Contact: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Contact"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "aci"),
    2: .same(proto: "pni"),
    3: .same(proto: "username"),
    4: .same(proto: "e164"),
    5: .same(proto: "blocked"),
    6: .same(proto: "hidden"),
    7: .same(proto: "registered"),
    8: .same(proto: "unregisteredTimestamp"),
    9: .same(proto: "profileKey"),
    10: .same(proto: "profileSharing"),
    11: .same(proto: "profileGivenName"),
    12: .same(proto: "profileFamilyName"),
    13: .same(proto: "hideStory"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self._aci) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self._pni) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._username) }()
      case 4: try { try decoder.decodeSingularUInt64Field(value: &self._e164) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self._blocked) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self._hidden) }()
      case 7: try { try decoder.decodeSingularEnumField(value: &self._registered) }()
      case 8: try { try decoder.decodeSingularUInt64Field(value: &self._unregisteredTimestamp) }()
      case 9: try { try decoder.decodeSingularBytesField(value: &self._profileKey) }()
      case 10: try { try decoder.decodeSingularBoolField(value: &self._profileSharing) }()
      case 11: try { try decoder.decodeSingularStringField(value: &self._profileGivenName) }()
      case 12: try { try decoder.decodeSingularStringField(value: &self._profileFamilyName) }()
      case 13: try { try decoder.decodeSingularBoolField(value: &self._hideStory) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._aci {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._pni {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._username {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._e164 {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._blocked {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._hidden {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._registered {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 7)
    } }()
    try { if let v = self._unregisteredTimestamp {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 8)
    } }()
    try { if let v = self._profileKey {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 9)
    } }()
    try { if let v = self._profileSharing {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 10)
    } }()
    try { if let v = self._profileGivenName {
      try visitor.visitSingularStringField(value: v, fieldNumber: 11)
    } }()
    try { if let v = self._profileFamilyName {
      try visitor.visitSingularStringField(value: v, fieldNumber: 12)
    } }()
    try { if let v = self._hideStory {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 13)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: BackupProtos_Contact, rhs: BackupProtos_Contact) -> Bool {
    if lhs._aci != rhs._aci {return false}
    if lhs._pni != rhs._pni {return false}
    if lhs._username != rhs._username {return false}
    if lhs._e164 != rhs._e164 {return false}
    if lhs._blocked != rhs._blocked {return false}
    if lhs._hidden != rhs._hidden {return false}
    if lhs._registered != rhs._registered {return false}
    if lhs._unregisteredTimestamp != rhs._unregisteredTimestamp {return false}
    if lhs._profileKey != rhs._profileKey {return false}
    if lhs._profileSharing != rhs._profileSharing {return false}
    if lhs._profileGivenName != rhs._profileGivenName {return false}
    if lhs._profileFamilyName != rhs._profileFamilyName {return false}
    if lhs._hideStory != rhs._hideStory {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProtos_Contact.Registered: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN"),
    1: .same(proto: "REGISTERED"),
    2: .same(proto: "NOT_REGISTERED"),
  ]
}

extension BackupProtos_Group: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Group"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "masterKey"),
    2: .same(proto: "whitelisted"),
    3: .same(proto: "hideStory"),
    4: .same(proto: "storySendMode"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self._masterKey) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self._whitelisted) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self._hideStory) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self._storySendMode) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._masterKey {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._whitelisted {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._hideStory {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._storySendMode {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: BackupProtos_Group, rhs: BackupProtos_Group) -> Bool {
    if lhs._masterKey != rhs._masterKey {return false}
    if lhs._whitelisted != rhs._whitelisted {return false}
    if lhs._hideStory != rhs._hideStory {return false}
    if lhs._storySendMode != rhs._storySendMode {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProtos_Group.StorySendMode: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "DEFAULT"),
    1: .same(proto: "DISABLED"),
    2: .same(proto: "ENABLED"),
  ]
}

extension BackupProtos_SelfRecipient: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SelfRecipient"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: BackupProtos_SelfRecipient, rhs: BackupProtos_SelfRecipient) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProtos_ReleaseNotes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ReleaseNotes"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: BackupProtos_ReleaseNotes, rhs: BackupProtos_ReleaseNotes) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProtos_Chat: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Chat"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "recipientId"),
    3: .same(proto: "archived"),
    4: .same(proto: "pinnedOrder"),
    5: .same(proto: "expirationTimerMs"),
    6: .same(proto: "muteUntilMs"),
    7: .same(proto: "markedUnread"),
    8: .same(proto: "dontNotifyForMentionsIfMuted"),
    9: .same(proto: "wallpaper"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self._id) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self._recipientID) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self._archived) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self._pinnedOrder) }()
      case 5: try { try decoder.decodeSingularUInt64Field(value: &self._expirationTimerMs) }()
      case 6: try { try decoder.decodeSingularUInt64Field(value: &self._muteUntilMs) }()
      case 7: try { try decoder.decodeSingularBoolField(value: &self._markedUnread) }()
      case 8: try { try decoder.decodeSingularBoolField(value: &self._dontNotifyForMentionsIfMuted) }()
      case 9: try { try decoder.decodeSingularMessageField(value: &self._wallpaper) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._id {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._recipientID {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._archived {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._pinnedOrder {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._expirationTimerMs {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._muteUntilMs {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._markedUnread {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 7)
    } }()
    try { if let v = self._dontNotifyForMentionsIfMuted {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 8)
    } }()
    try { if let v = self._wallpaper {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: BackupProtos_Chat, rhs: BackupProtos_Chat) -> Bool {
    if lhs._id != rhs._id {return false}
    if lhs._recipientID != rhs._recipientID {return false}
    if lhs._archived != rhs._archived {return false}
    if lhs._pinnedOrder != rhs._pinnedOrder {return false}
    if lhs._expirationTimerMs != rhs._expirationTimerMs {return false}
    if lhs._muteUntilMs != rhs._muteUntilMs {return false}
    if lhs._markedUnread != rhs._markedUnread {return false}
    if lhs._dontNotifyForMentionsIfMuted != rhs._dontNotifyForMentionsIfMuted {return false}
    if lhs._wallpaper != rhs._wallpaper {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProtos_DistributionList: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DistributionList"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "distributionId"),
    3: .same(proto: "allowReplies"),
    4: .same(proto: "deletionTimestamp"),
    5: .same(proto: "privacyMode"),
    6: .same(proto: "memberRecipientIds"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._name) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self._distributionID) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self._allowReplies) }()
      case 4: try { try decoder.decodeSingularUInt64Field(value: &self._deletionTimestamp) }()
      case 5: try { try decoder.decodeSingularEnumField(value: &self._privacyMode) }()
      case 6: try { try decoder.decodeRepeatedUInt64Field(value: &self.memberRecipientIds) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._name {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._distributionID {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._allowReplies {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._deletionTimestamp {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._privacyMode {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 5)
    } }()
    if !self.memberRecipientIds.isEmpty {
      try visitor.visitRepeatedUInt64Field(value: self.memberRecipientIds, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: BackupProtos_DistributionList, rhs: BackupProtos_DistributionList) -> Bool {
    if lhs._name != rhs._name {return false}
    if lhs._distributionID != rhs._distributionID {return false}
    if lhs._allowReplies != rhs._allowReplies {return false}
    if lhs._deletionTimestamp != rhs._deletionTimestamp {return false}
    if lhs._privacyMode != rhs._privacyMode {return false}
    if lhs.memberRecipientIds != rhs.memberRecipientIds {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProtos_DistributionList.PrivacyMode: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN"),
    1: .same(proto: "ONLY_WITH"),
    2: .same(proto: "ALL_EXCEPT"),
    3: .same(proto: "ALL"),
  ]
}

extension BackupProtos_Identity: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Identity"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "serviceId"),
    2: .same(proto: "identityKey"),
    3: .same(proto: "timestamp"),
    4: .same(proto: "firstUse"),
    5: .same(proto: "verified"),
    6: .same(proto: "nonblockingApproval"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self._serviceID) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self._identityKey) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self._timestamp) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self._firstUse) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self._verified) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self._nonblockingApproval) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._serviceID {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._identityKey {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._timestamp {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._firstUse {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._verified {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._nonblockingApproval {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 6)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: BackupProtos_Identity, rhs: BackupProtos_Identity) -> Bool {
    if lhs._serviceID != rhs._serviceID {return false}
    if lhs._identityKey != rhs._identityKey {return false}
    if lhs._timestamp != rhs._timestamp {return false}
    if lhs._firstUse != rhs._firstUse {return false}
    if lhs._verified != rhs._verified {return false}
    if lhs._nonblockingApproval != rhs._nonblockingApproval {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProtos_Call: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Call"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "callId"),
    2: .same(proto: "conversationRecipientId"),
    3: .same(proto: "type"),
    4: .same(proto: "outgoing"),
    5: .same(proto: "timestamp"),
    6: .same(proto: "ringerRecipientId"),
    7: .same(proto: "event"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self._callID) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self._conversationRecipientID) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self._type) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self._outgoing) }()
      case 5: try { try decoder.decodeSingularUInt64Field(value: &self._timestamp) }()
      case 6: try { try decoder.decodeSingularUInt64Field(value: &self._ringerRecipientID) }()
      case 7: try { try decoder.decodeSingularEnumField(value: &self._event) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._callID {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._conversationRecipientID {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._type {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._outgoing {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._timestamp {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._ringerRecipientID {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._event {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 7)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: BackupProtos_Call, rhs: BackupProtos_Call) -> Bool {
    if lhs._callID != rhs._callID {return false}
    if lhs._conversationRecipientID != rhs._conversationRecipientID {return false}
    if lhs._type != rhs._type {return false}
    if lhs._outgoing != rhs._outgoing {return false}
    if lhs._timestamp != rhs._timestamp {return false}
    if lhs._ringerRecipientID != rhs._ringerRecipientID {return false}
    if lhs._event != rhs._event {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProtos_Call.TypeEnum: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN_TYPE"),
    1: .same(proto: "AUDIO_CALL"),
    2: .same(proto: "VIDEO_CALL"),
    3: .same(proto: "GROUP_CALL"),
    4: .same(proto: "AD_HOC_CALL"),
  ]
}

extension BackupProtos_Call.Event: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN_EVENT"),
    1: .same(proto: "OUTGOING"),
    2: .same(proto: "ACCEPTED"),
    3: .same(proto: "NOT_ACCEPTED"),
    4: .same(proto: "MISSED"),
    5: .same(proto: "DELETE"),
    6: .same(proto: "GENERIC_GROUP_CALL"),
    7: .same(proto: "JOINED"),
    8: .same(proto: "DECLINED"),
    9: .same(proto: "OUTGOING_RING"),
  ]
}

extension BackupProtos_ChatItem: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ChatItem"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "chatId"),
    2: .same(proto: "authorId"),
    3: .same(proto: "dateSent"),
    4: .same(proto: "sealedSender"),
    5: .same(proto: "expireStartDate"),
    6: .same(proto: "expiresInMs"),
    7: .same(proto: "revisions"),
    8: .same(proto: "sms"),
    9: .same(proto: "incoming"),
    10: .same(proto: "outgoing"),
    11: .same(proto: "directionless"),
    13: .same(proto: "standardMessage"),
    14: .same(proto: "contactMessage"),
    15: .same(proto: "voiceMessage"),
    16: .same(proto: "stickerMessage"),
    17: .same(proto: "remoteDeletedMessage"),
    18: .same(proto: "updateMessage"),
  ]

  fileprivate class _StorageClass {
    var _chatID: UInt64? = nil
    var _authorID: UInt64? = nil
    var _dateSent: UInt64? = nil
    var _sealedSender: Bool? = nil
    var _expireStartDate: UInt64? = nil
    var _expiresInMs: UInt64? = nil
    var _revisions: [BackupProtos_ChatItem] = []
    var _sms: Bool? = nil
    var _incoming: BackupProtos_ChatItem.IncomingMessageDetails? = nil
    var _outgoing: BackupProtos_ChatItem.OutgoingMessageDetails? = nil
    var _directionless: BackupProtos_ChatItem.DirectionlessMessageDetails? = nil
    var _standardMessage: BackupProtos_StandardMessage? = nil
    var _contactMessage: BackupProtos_ContactMessage? = nil
    var _voiceMessage: BackupProtos_VoiceMessage? = nil
    var _stickerMessage: BackupProtos_StickerMessage? = nil
    var _remoteDeletedMessage: BackupProtos_RemoteDeletedMessage? = nil
    var _updateMessage: BackupProtos_ChatUpdateMessage? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _chatID = source._chatID
      _authorID = source._authorID
      _dateSent = source._dateSent
      _sealedSender = source._sealedSender
      _expireStartDate = source._expireStartDate
      _expiresInMs = source._expiresInMs
      _revisions = source._revisions
      _sms = source._sms
      _incoming = source._incoming
      _outgoing = source._outgoing
      _directionless = source._directionless
      _standardMessage = source._standardMessage
      _contactMessage = source._contactMessage
      _voiceMessage = source._voiceMessage
      _stickerMessage = source._stickerMessage
      _remoteDeletedMessage = source._remoteDeletedMessage
      _updateMessage = source._updateMessage
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularUInt64Field(value: &_storage._chatID) }()
        case 2: try { try decoder.decodeSingularUInt64Field(value: &_storage._authorID) }()
        case 3: try { try decoder.decodeSingularUInt64Field(value: &_storage._dateSent) }()
        case 4: try { try decoder.decodeSingularBoolField(value: &_storage._sealedSender) }()
        case 5: try { try decoder.decodeSingularUInt64Field(value: &_storage._expireStartDate) }()
        case 6: try { try decoder.decodeSingularUInt64Field(value: &_storage._expiresInMs) }()
        case 7: try { try decoder.decodeRepeatedMessageField(value: &_storage._revisions) }()
        case 8: try { try decoder.decodeSingularBoolField(value: &_storage._sms) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._incoming) }()
        case 10: try { try decoder.decodeSingularMessageField(value: &_storage._outgoing) }()
        case 11: try { try decoder.decodeSingularMessageField(value: &_storage._directionless) }()
        case 13: try { try decoder.decodeSingularMessageField(value: &_storage._standardMessage) }()
        case 14: try { try decoder.decodeSingularMessageField(value: &_storage._contactMessage) }()
        case 15: try { try decoder.decodeSingularMessageField(value: &_storage._voiceMessage) }()
        case 16: try { try decoder.decodeSingularMessageField(value: &_storage._stickerMessage) }()
        case 17: try { try decoder.decodeSingularMessageField(value: &_storage._remoteDeletedMessage) }()
        case 18: try { try decoder.decodeSingularMessageField(value: &_storage._updateMessage) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._chatID {
        try visitor.visitSingularUInt64Field(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._authorID {
        try visitor.visitSingularUInt64Field(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._dateSent {
        try visitor.visitSingularUInt64Field(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._sealedSender {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._expireStartDate {
        try visitor.visitSingularUInt64Field(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._expiresInMs {
        try visitor.visitSingularUInt64Field(value: v, fieldNumber: 6)
      } }()
      if !_storage._revisions.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._revisions, fieldNumber: 7)
      }
      try { if let v = _storage._sms {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 8)
      } }()
      try { if let v = _storage._incoming {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      } }()
      try { if let v = _storage._outgoing {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      } }()
      try { if let v = _storage._directionless {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      } }()
      try { if let v = _storage._standardMessage {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
      } }()
      try { if let v = _storage._contactMessage {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
      } }()
      try { if let v = _storage._voiceMessage {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
      } }()
      try { if let v = _storage._stickerMessage {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
      } }()
      try { if let v = _storage._remoteDeletedMessage {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
      } }()
      try { if let v = _storage._updateMessage {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 18)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: BackupProtos_ChatItem, rhs: BackupProtos_ChatItem) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._chatID != rhs_storage._chatID {return false}
        if _storage._authorID != rhs_storage._authorID {return false}
        if _storage._dateSent != rhs_storage._dateSent {return false}
        if _storage._sealedSender != rhs_storage._sealedSender {return false}
        if _storage._expireStartDate != rhs_storage._expireStartDate {return false}
        if _storage._expiresInMs != rhs_storage._expiresInMs {return false}
        if _storage._revisions != rhs_storage._revisions {return false}
        if _storage._sms != rhs_storage._sms {return false}
        if _storage._incoming != rhs_storage._incoming {return false}
        if _storage._outgoing != rhs_storage._outgoing {return false}
        if _storage._directionless != rhs_storage._directionless {return false}
        if _storage._standardMessage != rhs_storage._standardMessage {return false}
        if _storage._contactMessage != rhs_storage._contactMessage {return false}
        if _storage._voiceMessage != rhs_storage._voiceMessage {return false}
        if _storage._stickerMessage != rhs_storage._stickerMessage {return false}
        if _storage._remoteDeletedMessage != rhs_storage._remoteDeletedMessage {return false}
        if _storage._updateMessage != rhs_storage._updateMessage {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProtos_ChatItem.IncomingMessageDetails: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = BackupProtos_ChatItem.protoMessageName + ".IncomingMessageDetails"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "dateReceived"),
    2: .same(proto: "dateServerSent"),
    3: .same(proto: "read"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self._dateReceived) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self._dateServerSent) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self._read) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._dateReceived {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._dateServerSent {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._read {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: BackupProtos_ChatItem.IncomingMessageDetails, rhs: BackupProtos_ChatItem.IncomingMessageDetails) -> Bool {
    if lhs._dateReceived != rhs._dateReceived {return false}
    if lhs._dateServerSent != rhs._dateServerSent {return false}
    if lhs._read != rhs._read {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProtos_ChatItem.OutgoingMessageDetails: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = BackupProtos_ChatItem.protoMessageName + ".OutgoingMessageDetails"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "sendStatus"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.sendStatus) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.sendStatus.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.sendStatus, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: BackupProtos_ChatItem.OutgoingMessageDetails, rhs: BackupProtos_ChatItem.OutgoingMessageDetails) -> Bool {
    if lhs.sendStatus != rhs.sendStatus {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProtos_ChatItem.DirectionlessMessageDetails: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = BackupProtos_ChatItem.protoMessageName + ".DirectionlessMessageDetails"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: BackupProtos_ChatItem.DirectionlessMessageDetails, rhs: BackupProtos_ChatItem.DirectionlessMessageDetails) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProtos_SendStatus: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SendStatus"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "recipientId"),
    2: .same(proto: "deliveryStatus"),
    3: .same(proto: "networkFailure"),
    4: .same(proto: "identityKeyMismatch"),
    5: .same(proto: "sealedSender"),
    6: .same(proto: "lastStatusUpdateTimestamp"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self._recipientID) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self._deliveryStatus) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self._networkFailure) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self._identityKeyMismatch) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self._sealedSender) }()
      case 6: try { try decoder.decodeSingularUInt64Field(value: &self._lastStatusUpdateTimestamp) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._recipientID {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._deliveryStatus {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._networkFailure {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._identityKeyMismatch {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._sealedSender {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._lastStatusUpdateTimestamp {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 6)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: BackupProtos_SendStatus, rhs: BackupProtos_SendStatus) -> Bool {
    if lhs._recipientID != rhs._recipientID {return false}
    if lhs._deliveryStatus != rhs._deliveryStatus {return false}
    if lhs._networkFailure != rhs._networkFailure {return false}
    if lhs._identityKeyMismatch != rhs._identityKeyMismatch {return false}
    if lhs._sealedSender != rhs._sealedSender {return false}
    if lhs._lastStatusUpdateTimestamp != rhs._lastStatusUpdateTimestamp {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProtos_SendStatus.Status: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN"),
    1: .same(proto: "FAILED"),
    2: .same(proto: "PENDING"),
    3: .same(proto: "SENT"),
    4: .same(proto: "DELIVERED"),
    5: .same(proto: "READ"),
    6: .same(proto: "VIEWED"),
    7: .same(proto: "SKIPPED"),
  ]
}

extension BackupProtos_Text: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Text"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "body"),
    2: .same(proto: "bodyRanges"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._body) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.bodyRanges) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._body {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    if !self.bodyRanges.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.bodyRanges, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: BackupProtos_Text, rhs: BackupProtos_Text) -> Bool {
    if lhs._body != rhs._body {return false}
    if lhs.bodyRanges != rhs.bodyRanges {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProtos_StandardMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".StandardMessage"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "quote"),
    2: .same(proto: "text"),
    3: .same(proto: "attachments"),
    4: .same(proto: "linkPreview"),
    5: .same(proto: "longText"),
    6: .same(proto: "reactions"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._quote) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._text) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.attachments) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.linkPreview) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._longText) }()
      case 6: try { try decoder.decodeRepeatedMessageField(value: &self.reactions) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._quote {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._text {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.attachments.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.attachments, fieldNumber: 3)
    }
    if !self.linkPreview.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.linkPreview, fieldNumber: 4)
    }
    try { if let v = self._longText {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    if !self.reactions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.reactions, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: BackupProtos_StandardMessage, rhs: BackupProtos_StandardMessage) -> Bool {
    if lhs._quote != rhs._quote {return false}
    if lhs._text != rhs._text {return false}
    if lhs.attachments != rhs.attachments {return false}
    if lhs.linkPreview != rhs.linkPreview {return false}
    if lhs._longText != rhs._longText {return false}
    if lhs.reactions != rhs.reactions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProtos_ContactMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ContactMessage"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "contact"),
    2: .same(proto: "reactions"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.contact) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.reactions) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.contact.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.contact, fieldNumber: 1)
    }
    if !self.reactions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.reactions, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: BackupProtos_ContactMessage, rhs: BackupProtos_ContactMessage) -> Bool {
    if lhs.contact != rhs.contact {return false}
    if lhs.reactions != rhs.reactions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProtos_ContactAttachment: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ContactAttachment"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    3: .same(proto: "number"),
    4: .same(proto: "email"),
    5: .same(proto: "address"),
    6: .same(proto: "avatar"),
    7: .same(proto: "organization"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._name) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.number) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.email) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.address) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._avatar) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self._organization) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._name {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.number.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.number, fieldNumber: 3)
    }
    if !self.email.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.email, fieldNumber: 4)
    }
    if !self.address.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.address, fieldNumber: 5)
    }
    try { if let v = self._avatar {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._organization {
      try visitor.visitSingularStringField(value: v, fieldNumber: 7)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: BackupProtos_ContactAttachment, rhs: BackupProtos_ContactAttachment) -> Bool {
    if lhs._name != rhs._name {return false}
    if lhs.number != rhs.number {return false}
    if lhs.email != rhs.email {return false}
    if lhs.address != rhs.address {return false}
    if lhs._avatar != rhs._avatar {return false}
    if lhs._organization != rhs._organization {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProtos_ContactAttachment.Name: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = BackupProtos_ContactAttachment.protoMessageName + ".Name"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "givenName"),
    2: .same(proto: "familyName"),
    3: .same(proto: "prefix"),
    4: .same(proto: "suffix"),
    5: .same(proto: "middleName"),
    6: .same(proto: "displayName"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._givenName) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._familyName) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._prefix) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self._suffix) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self._middleName) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self._displayName) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._givenName {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._familyName {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._prefix {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._suffix {
      try visitor.visitSingularStringField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._middleName {
      try visitor.visitSingularStringField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._displayName {
      try visitor.visitSingularStringField(value: v, fieldNumber: 6)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: BackupProtos_ContactAttachment.Name, rhs: BackupProtos_ContactAttachment.Name) -> Bool {
    if lhs._givenName != rhs._givenName {return false}
    if lhs._familyName != rhs._familyName {return false}
    if lhs._prefix != rhs._prefix {return false}
    if lhs._suffix != rhs._suffix {return false}
    if lhs._middleName != rhs._middleName {return false}
    if lhs._displayName != rhs._displayName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProtos_ContactAttachment.Phone: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = BackupProtos_ContactAttachment.protoMessageName + ".Phone"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
    2: .same(proto: "type"),
    3: .same(proto: "label"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._value) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self._type) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._label) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._value {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._type {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._label {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: BackupProtos_ContactAttachment.Phone, rhs: BackupProtos_ContactAttachment.Phone) -> Bool {
    if lhs._value != rhs._value {return false}
    if lhs._type != rhs._type {return false}
    if lhs._label != rhs._label {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProtos_ContactAttachment.Phone.TypeEnum: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN"),
    1: .same(proto: "HOME"),
    2: .same(proto: "MOBILE"),
    3: .same(proto: "WORK"),
    4: .same(proto: "CUSTOM"),
  ]
}

extension BackupProtos_ContactAttachment.Email: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = BackupProtos_ContactAttachment.protoMessageName + ".Email"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
    2: .same(proto: "type"),
    3: .same(proto: "label"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._value) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self._type) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._label) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._value {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._type {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._label {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: BackupProtos_ContactAttachment.Email, rhs: BackupProtos_ContactAttachment.Email) -> Bool {
    if lhs._value != rhs._value {return false}
    if lhs._type != rhs._type {return false}
    if lhs._label != rhs._label {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProtos_ContactAttachment.Email.TypeEnum: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN"),
    1: .same(proto: "HOME"),
    2: .same(proto: "MOBILE"),
    3: .same(proto: "WORK"),
    4: .same(proto: "CUSTOM"),
  ]
}

extension BackupProtos_ContactAttachment.PostalAddress: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = BackupProtos_ContactAttachment.protoMessageName + ".PostalAddress"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "label"),
    3: .same(proto: "street"),
    4: .same(proto: "pobox"),
    5: .same(proto: "neighborhood"),
    6: .same(proto: "city"),
    7: .same(proto: "region"),
    8: .same(proto: "postcode"),
    9: .same(proto: "country"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self._type) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._label) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._street) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self._pobox) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self._neighborhood) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self._city) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self._region) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self._postcode) }()
      case 9: try { try decoder.decodeSingularStringField(value: &self._country) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._type {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._label {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._street {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._pobox {
      try visitor.visitSingularStringField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._neighborhood {
      try visitor.visitSingularStringField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._city {
      try visitor.visitSingularStringField(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._region {
      try visitor.visitSingularStringField(value: v, fieldNumber: 7)
    } }()
    try { if let v = self._postcode {
      try visitor.visitSingularStringField(value: v, fieldNumber: 8)
    } }()
    try { if let v = self._country {
      try visitor.visitSingularStringField(value: v, fieldNumber: 9)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: BackupProtos_ContactAttachment.PostalAddress, rhs: BackupProtos_ContactAttachment.PostalAddress) -> Bool {
    if lhs._type != rhs._type {return false}
    if lhs._label != rhs._label {return false}
    if lhs._street != rhs._street {return false}
    if lhs._pobox != rhs._pobox {return false}
    if lhs._neighborhood != rhs._neighborhood {return false}
    if lhs._city != rhs._city {return false}
    if lhs._region != rhs._region {return false}
    if lhs._postcode != rhs._postcode {return false}
    if lhs._country != rhs._country {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProtos_ContactAttachment.PostalAddress.TypeEnum: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN"),
    1: .same(proto: "HOME"),
    2: .same(proto: "WORK"),
    3: .same(proto: "CUSTOM"),
  ]
}

extension BackupProtos_ContactAttachment.Avatar: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = BackupProtos_ContactAttachment.protoMessageName + ".Avatar"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "avatar"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._avatar) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._avatar {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: BackupProtos_ContactAttachment.Avatar, rhs: BackupProtos_ContactAttachment.Avatar) -> Bool {
    if lhs._avatar != rhs._avatar {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProtos_DocumentMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DocumentMessage"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "text"),
    2: .same(proto: "document"),
    3: .same(proto: "reactions"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._text) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._document) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.reactions) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._text {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._document {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.reactions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.reactions, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: BackupProtos_DocumentMessage, rhs: BackupProtos_DocumentMessage) -> Bool {
    if lhs._text != rhs._text {return false}
    if lhs._document != rhs._document {return false}
    if lhs.reactions != rhs.reactions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProtos_VoiceMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".VoiceMessage"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "quote"),
    2: .same(proto: "audio"),
    3: .same(proto: "reactions"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._quote) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._audio) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.reactions) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._quote {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._audio {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.reactions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.reactions, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: BackupProtos_VoiceMessage, rhs: BackupProtos_VoiceMessage) -> Bool {
    if lhs._quote != rhs._quote {return false}
    if lhs._audio != rhs._audio {return false}
    if lhs.reactions != rhs.reactions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProtos_StickerMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".StickerMessage"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "sticker"),
    2: .same(proto: "reactions"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._sticker) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.reactions) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._sticker {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.reactions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.reactions, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: BackupProtos_StickerMessage, rhs: BackupProtos_StickerMessage) -> Bool {
    if lhs._sticker != rhs._sticker {return false}
    if lhs.reactions != rhs.reactions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProtos_RemoteDeletedMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RemoteDeletedMessage"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: BackupProtos_RemoteDeletedMessage, rhs: BackupProtos_RemoteDeletedMessage) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProtos_Sticker: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Sticker"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "packId"),
    2: .same(proto: "packKey"),
    3: .same(proto: "stickerId"),
    4: .same(proto: "emoji"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self._packID) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self._packKey) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self._stickerID) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self._emoji) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._packID {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._packKey {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._stickerID {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._emoji {
      try visitor.visitSingularStringField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: BackupProtos_Sticker, rhs: BackupProtos_Sticker) -> Bool {
    if lhs._packID != rhs._packID {return false}
    if lhs._packKey != rhs._packKey {return false}
    if lhs._stickerID != rhs._stickerID {return false}
    if lhs._emoji != rhs._emoji {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProtos_LinkPreview: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".LinkPreview"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "url"),
    2: .same(proto: "title"),
    3: .same(proto: "image"),
    4: .same(proto: "descriptionText"),
    5: .same(proto: "date"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._url) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._title) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._image) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self._descriptionText) }()
      case 5: try { try decoder.decodeSingularUInt64Field(value: &self._date) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._url {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._title {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._image {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._descriptionText {
      try visitor.visitSingularStringField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._date {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: BackupProtos_LinkPreview, rhs: BackupProtos_LinkPreview) -> Bool {
    if lhs._url != rhs._url {return false}
    if lhs._title != rhs._title {return false}
    if lhs._image != rhs._image {return false}
    if lhs._descriptionText != rhs._descriptionText {return false}
    if lhs._date != rhs._date {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProtos_FilePointer: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".FilePointer"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "backupLocator"),
    2: .same(proto: "attachmentLocator"),
    3: .same(proto: "legacyAttachmentLocator"),
    4: .same(proto: "undownloadedBackupLocator"),
    5: .same(proto: "key"),
    6: .same(proto: "contentType"),
    7: .same(proto: "size"),
    8: .same(proto: "incrementalMac"),
    9: .same(proto: "incrementalMacChunkSize"),
    10: .same(proto: "fileName"),
    11: .same(proto: "flags"),
    12: .same(proto: "width"),
    13: .same(proto: "height"),
    14: .same(proto: "caption"),
    15: .same(proto: "blurHash"),
  ]

  fileprivate class _StorageClass {
    var _backupLocator: BackupProtos_FilePointer.BackupLocator? = nil
    var _attachmentLocator: BackupProtos_FilePointer.AttachmentLocator? = nil
    var _legacyAttachmentLocator: BackupProtos_FilePointer.LegacyAttachmentLocator? = nil
    var _undownloadedBackupLocator: BackupProtos_FilePointer.UndownloadedBackupLocator? = nil
    var _key: Data? = nil
    var _contentType: String? = nil
    var _size: UInt32? = nil
    var _incrementalMac: Data? = nil
    var _incrementalMacChunkSize: Data? = nil
    var _fileName: String? = nil
    var _flags: UInt32? = nil
    var _width: UInt32? = nil
    var _height: UInt32? = nil
    var _caption: String? = nil
    var _blurHash: String? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _backupLocator = source._backupLocator
      _attachmentLocator = source._attachmentLocator
      _legacyAttachmentLocator = source._legacyAttachmentLocator
      _undownloadedBackupLocator = source._undownloadedBackupLocator
      _key = source._key
      _contentType = source._contentType
      _size = source._size
      _incrementalMac = source._incrementalMac
      _incrementalMacChunkSize = source._incrementalMacChunkSize
      _fileName = source._fileName
      _flags = source._flags
      _width = source._width
      _height = source._height
      _caption = source._caption
      _blurHash = source._blurHash
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._backupLocator) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._attachmentLocator) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._legacyAttachmentLocator) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._undownloadedBackupLocator) }()
        case 5: try { try decoder.decodeSingularBytesField(value: &_storage._key) }()
        case 6: try { try decoder.decodeSingularStringField(value: &_storage._contentType) }()
        case 7: try { try decoder.decodeSingularUInt32Field(value: &_storage._size) }()
        case 8: try { try decoder.decodeSingularBytesField(value: &_storage._incrementalMac) }()
        case 9: try { try decoder.decodeSingularBytesField(value: &_storage._incrementalMacChunkSize) }()
        case 10: try { try decoder.decodeSingularStringField(value: &_storage._fileName) }()
        case 11: try { try decoder.decodeSingularUInt32Field(value: &_storage._flags) }()
        case 12: try { try decoder.decodeSingularUInt32Field(value: &_storage._width) }()
        case 13: try { try decoder.decodeSingularUInt32Field(value: &_storage._height) }()
        case 14: try { try decoder.decodeSingularStringField(value: &_storage._caption) }()
        case 15: try { try decoder.decodeSingularStringField(value: &_storage._blurHash) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._backupLocator {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._attachmentLocator {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._legacyAttachmentLocator {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._undownloadedBackupLocator {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._key {
        try visitor.visitSingularBytesField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._contentType {
        try visitor.visitSingularStringField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._size {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._incrementalMac {
        try visitor.visitSingularBytesField(value: v, fieldNumber: 8)
      } }()
      try { if let v = _storage._incrementalMacChunkSize {
        try visitor.visitSingularBytesField(value: v, fieldNumber: 9)
      } }()
      try { if let v = _storage._fileName {
        try visitor.visitSingularStringField(value: v, fieldNumber: 10)
      } }()
      try { if let v = _storage._flags {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 11)
      } }()
      try { if let v = _storage._width {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 12)
      } }()
      try { if let v = _storage._height {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 13)
      } }()
      try { if let v = _storage._caption {
        try visitor.visitSingularStringField(value: v, fieldNumber: 14)
      } }()
      try { if let v = _storage._blurHash {
        try visitor.visitSingularStringField(value: v, fieldNumber: 15)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: BackupProtos_FilePointer, rhs: BackupProtos_FilePointer) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._backupLocator != rhs_storage._backupLocator {return false}
        if _storage._attachmentLocator != rhs_storage._attachmentLocator {return false}
        if _storage._legacyAttachmentLocator != rhs_storage._legacyAttachmentLocator {return false}
        if _storage._undownloadedBackupLocator != rhs_storage._undownloadedBackupLocator {return false}
        if _storage._key != rhs_storage._key {return false}
        if _storage._contentType != rhs_storage._contentType {return false}
        if _storage._size != rhs_storage._size {return false}
        if _storage._incrementalMac != rhs_storage._incrementalMac {return false}
        if _storage._incrementalMacChunkSize != rhs_storage._incrementalMacChunkSize {return false}
        if _storage._fileName != rhs_storage._fileName {return false}
        if _storage._flags != rhs_storage._flags {return false}
        if _storage._width != rhs_storage._width {return false}
        if _storage._height != rhs_storage._height {return false}
        if _storage._caption != rhs_storage._caption {return false}
        if _storage._blurHash != rhs_storage._blurHash {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProtos_FilePointer.Flags: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "VOICE_MESSAGE"),
    1: .same(proto: "BORDERLESS"),
    2: .same(proto: "GIF"),
  ]
}

extension BackupProtos_FilePointer.BackupLocator: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = BackupProtos_FilePointer.protoMessageName + ".BackupLocator"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "mediaName"),
    2: .same(proto: "cdnNumber"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._mediaName) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self._cdnNumber) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._mediaName {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._cdnNumber {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: BackupProtos_FilePointer.BackupLocator, rhs: BackupProtos_FilePointer.BackupLocator) -> Bool {
    if lhs._mediaName != rhs._mediaName {return false}
    if lhs._cdnNumber != rhs._cdnNumber {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProtos_FilePointer.AttachmentLocator: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = BackupProtos_FilePointer.protoMessageName + ".AttachmentLocator"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "cdnKey"),
    2: .same(proto: "cdnNumber"),
    3: .same(proto: "uploadTimestamp"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._cdnKey) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self._cdnNumber) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self._uploadTimestamp) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._cdnKey {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._cdnNumber {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._uploadTimestamp {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: BackupProtos_FilePointer.AttachmentLocator, rhs: BackupProtos_FilePointer.AttachmentLocator) -> Bool {
    if lhs._cdnKey != rhs._cdnKey {return false}
    if lhs._cdnNumber != rhs._cdnNumber {return false}
    if lhs._uploadTimestamp != rhs._uploadTimestamp {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProtos_FilePointer.LegacyAttachmentLocator: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = BackupProtos_FilePointer.protoMessageName + ".LegacyAttachmentLocator"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "cdnId"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFixed64Field(value: &self._cdnID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._cdnID {
      try visitor.visitSingularFixed64Field(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: BackupProtos_FilePointer.LegacyAttachmentLocator, rhs: BackupProtos_FilePointer.LegacyAttachmentLocator) -> Bool {
    if lhs._cdnID != rhs._cdnID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProtos_FilePointer.UndownloadedBackupLocator: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = BackupProtos_FilePointer.protoMessageName + ".UndownloadedBackupLocator"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "senderAci"),
    2: .same(proto: "cdnKey"),
    3: .same(proto: "cdnNumber"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self._senderAci) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._cdnKey) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self._cdnNumber) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._senderAci {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._cdnKey {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._cdnNumber {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: BackupProtos_FilePointer.UndownloadedBackupLocator, rhs: BackupProtos_FilePointer.UndownloadedBackupLocator) -> Bool {
    if lhs._senderAci != rhs._senderAci {return false}
    if lhs._cdnKey != rhs._cdnKey {return false}
    if lhs._cdnNumber != rhs._cdnNumber {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProtos_Quote: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Quote"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "targetSentTimestamp"),
    2: .same(proto: "authorId"),
    3: .same(proto: "text"),
    4: .same(proto: "attachments"),
    5: .same(proto: "bodyRanges"),
    6: .same(proto: "type"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self._targetSentTimestamp) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self._authorID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._text) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.attachments) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.bodyRanges) }()
      case 6: try { try decoder.decodeSingularEnumField(value: &self._type) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._targetSentTimestamp {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._authorID {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._text {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    } }()
    if !self.attachments.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.attachments, fieldNumber: 4)
    }
    if !self.bodyRanges.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.bodyRanges, fieldNumber: 5)
    }
    try { if let v = self._type {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 6)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: BackupProtos_Quote, rhs: BackupProtos_Quote) -> Bool {
    if lhs._targetSentTimestamp != rhs._targetSentTimestamp {return false}
    if lhs._authorID != rhs._authorID {return false}
    if lhs._text != rhs._text {return false}
    if lhs.attachments != rhs.attachments {return false}
    if lhs.bodyRanges != rhs.bodyRanges {return false}
    if lhs._type != rhs._type {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProtos_Quote.TypeEnum: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN"),
    1: .same(proto: "NORMAL"),
    2: .same(proto: "GIFTBADGE"),
  ]
}

extension BackupProtos_Quote.QuotedAttachment: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = BackupProtos_Quote.protoMessageName + ".QuotedAttachment"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "contentType"),
    2: .same(proto: "fileName"),
    3: .same(proto: "thumbnail"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._contentType) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._fileName) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._thumbnail) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._contentType {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._fileName {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._thumbnail {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: BackupProtos_Quote.QuotedAttachment, rhs: BackupProtos_Quote.QuotedAttachment) -> Bool {
    if lhs._contentType != rhs._contentType {return false}
    if lhs._fileName != rhs._fileName {return false}
    if lhs._thumbnail != rhs._thumbnail {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProtos_BodyRange: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BodyRange"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "start"),
    2: .same(proto: "length"),
    3: .same(proto: "mentionAci"),
    4: .same(proto: "style"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self._start) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self._length) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self._mentionAci) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self._style) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._start {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._length {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._mentionAci {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._style {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: BackupProtos_BodyRange, rhs: BackupProtos_BodyRange) -> Bool {
    if lhs._start != rhs._start {return false}
    if lhs._length != rhs._length {return false}
    if lhs._mentionAci != rhs._mentionAci {return false}
    if lhs._style != rhs._style {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProtos_BodyRange.Style: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NONE"),
    1: .same(proto: "BOLD"),
    2: .same(proto: "ITALIC"),
    3: .same(proto: "SPOILER"),
    4: .same(proto: "STRIKETHROUGH"),
    5: .same(proto: "MONOSPACE"),
  ]
}

extension BackupProtos_Reaction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Reaction"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "emoji"),
    2: .same(proto: "authorId"),
    3: .same(proto: "sentTimestamp"),
    4: .same(proto: "receivedTimestamp"),
    5: .same(proto: "sortOrder"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._emoji) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self._authorID) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self._sentTimestamp) }()
      case 4: try { try decoder.decodeSingularUInt64Field(value: &self._receivedTimestamp) }()
      case 5: try { try decoder.decodeSingularUInt64Field(value: &self._sortOrder) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._emoji {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._authorID {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._sentTimestamp {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._receivedTimestamp {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._sortOrder {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: BackupProtos_Reaction, rhs: BackupProtos_Reaction) -> Bool {
    if lhs._emoji != rhs._emoji {return false}
    if lhs._authorID != rhs._authorID {return false}
    if lhs._sentTimestamp != rhs._sentTimestamp {return false}
    if lhs._receivedTimestamp != rhs._receivedTimestamp {return false}
    if lhs._sortOrder != rhs._sortOrder {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProtos_ChatUpdateMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ChatUpdateMessage"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "simpleUpdate"),
    2: .same(proto: "groupChange"),
    3: .same(proto: "expirationTimerChange"),
    4: .same(proto: "profileChange"),
    5: .same(proto: "threadMerge"),
    6: .same(proto: "sessionSwitchover"),
    7: .same(proto: "callingMessage"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._simpleUpdate) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._groupChange) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._expirationTimerChange) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._profileChange) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._threadMerge) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._sessionSwitchover) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._callingMessage) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._simpleUpdate {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._groupChange {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._expirationTimerChange {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._profileChange {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._threadMerge {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._sessionSwitchover {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._callingMessage {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: BackupProtos_ChatUpdateMessage, rhs: BackupProtos_ChatUpdateMessage) -> Bool {
    if lhs._simpleUpdate != rhs._simpleUpdate {return false}
    if lhs._groupChange != rhs._groupChange {return false}
    if lhs._expirationTimerChange != rhs._expirationTimerChange {return false}
    if lhs._profileChange != rhs._profileChange {return false}
    if lhs._threadMerge != rhs._threadMerge {return false}
    if lhs._sessionSwitchover != rhs._sessionSwitchover {return false}
    if lhs._callingMessage != rhs._callingMessage {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProtos_CallChatUpdate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CallChatUpdate"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "callId"),
    2: .same(proto: "callMessage"),
    3: .same(proto: "groupCall"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self._callID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._callMessage) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._groupCall) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._callID {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._callMessage {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._groupCall {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: BackupProtos_CallChatUpdate, rhs: BackupProtos_CallChatUpdate) -> Bool {
    if lhs._callID != rhs._callID {return false}
    if lhs._callMessage != rhs._callMessage {return false}
    if lhs._groupCall != rhs._groupCall {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProtos_IndividualCallChatUpdate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".IndividualCallChatUpdate"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: BackupProtos_IndividualCallChatUpdate, rhs: BackupProtos_IndividualCallChatUpdate) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProtos_IndividualCallChatUpdate.TypeEnum: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN"),
    1: .same(proto: "INCOMING_AUDIO_CALL"),
    2: .same(proto: "INCOMING_VIDEO_CALL"),
    3: .same(proto: "OUTGOING_AUDIO_CALL"),
    4: .same(proto: "OUTGOING_VIDEO_CALL"),
    5: .same(proto: "MISSED_AUDIO_CALL"),
    6: .same(proto: "MISSED_VIDEO_CALL"),
  ]
}

extension BackupProtos_GroupCallChatUpdate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GroupCallChatUpdate"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "startedCallAci"),
    2: .same(proto: "startedCallTimestamp"),
    3: .same(proto: "inCallAcis"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self._startedCallAci) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self._startedCallTimestamp) }()
      case 3: try { try decoder.decodeRepeatedBytesField(value: &self.inCallAcis) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._startedCallAci {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._startedCallTimestamp {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 2)
    } }()
    if !self.inCallAcis.isEmpty {
      try visitor.visitRepeatedBytesField(value: self.inCallAcis, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: BackupProtos_GroupCallChatUpdate, rhs: BackupProtos_GroupCallChatUpdate) -> Bool {
    if lhs._startedCallAci != rhs._startedCallAci {return false}
    if lhs._startedCallTimestamp != rhs._startedCallTimestamp {return false}
    if lhs.inCallAcis != rhs.inCallAcis {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProtos_SimpleChatUpdate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SimpleChatUpdate"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self._type) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._type {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: BackupProtos_SimpleChatUpdate, rhs: BackupProtos_SimpleChatUpdate) -> Bool {
    if lhs._type != rhs._type {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProtos_SimpleChatUpdate.TypeEnum: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN"),
    1: .same(proto: "JOINED_SIGNAL"),
    2: .same(proto: "IDENTITY_UPDATE"),
    3: .same(proto: "IDENTITY_VERIFIED"),
    4: .same(proto: "IDENTITY_DEFAULT"),
    5: .same(proto: "CHANGE_NUMBER"),
    6: .same(proto: "BOOST_REQUEST"),
    7: .same(proto: "END_SESSION"),
    8: .same(proto: "CHAT_SESSION_REFRESH"),
    9: .same(proto: "BAD_DECRYPT"),
    10: .same(proto: "PAYMENTS_ACTIVATED"),
    11: .same(proto: "PAYMENT_ACTIVATION_REQUEST"),
  ]
}

extension BackupProtos_GroupDescriptionChatUpdate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GroupDescriptionChatUpdate"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "newDescription"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._newDescription) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._newDescription {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: BackupProtos_GroupDescriptionChatUpdate, rhs: BackupProtos_GroupDescriptionChatUpdate) -> Bool {
    if lhs._newDescription != rhs._newDescription {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProtos_ExpirationTimerChatUpdate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ExpirationTimerChatUpdate"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "expiresInMs"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self._expiresInMs) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._expiresInMs {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: BackupProtos_ExpirationTimerChatUpdate, rhs: BackupProtos_ExpirationTimerChatUpdate) -> Bool {
    if lhs._expiresInMs != rhs._expiresInMs {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProtos_ProfileChangeChatUpdate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ProfileChangeChatUpdate"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "previousName"),
    2: .same(proto: "newName"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._previousName) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._newName) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._previousName {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._newName {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: BackupProtos_ProfileChangeChatUpdate, rhs: BackupProtos_ProfileChangeChatUpdate) -> Bool {
    if lhs._previousName != rhs._previousName {return false}
    if lhs._newName != rhs._newName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProtos_ThreadMergeChatUpdate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ThreadMergeChatUpdate"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "previousE164"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self._previousE164) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._previousE164 {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: BackupProtos_ThreadMergeChatUpdate, rhs: BackupProtos_ThreadMergeChatUpdate) -> Bool {
    if lhs._previousE164 != rhs._previousE164 {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProtos_SessionSwitchoverChatUpdate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SessionSwitchoverChatUpdate"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "e164"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self._e164) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._e164 {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: BackupProtos_SessionSwitchoverChatUpdate, rhs: BackupProtos_SessionSwitchoverChatUpdate) -> Bool {
    if lhs._e164 != rhs._e164 {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProtos_GroupChangeChatUpdate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GroupChangeChatUpdate"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "updates"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.updates) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.updates.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.updates, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: BackupProtos_GroupChangeChatUpdate, rhs: BackupProtos_GroupChangeChatUpdate) -> Bool {
    if lhs.updates != rhs.updates {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProtos_GroupChangeChatUpdate.Update: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = BackupProtos_GroupChangeChatUpdate.protoMessageName + ".Update"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "genericGroupUpdate"),
    2: .same(proto: "groupCreationUpdate"),
    3: .same(proto: "groupNameUpdate"),
    4: .same(proto: "groupAvatarUpdate"),
    5: .same(proto: "groupDescriptionUpdate"),
    6: .same(proto: "groupMembershipAccessLevelChangeUpdate"),
    7: .same(proto: "groupAttributesAccessLevelChangeUpdate"),
    8: .same(proto: "groupAnnouncementOnlyChangeUpdate"),
    9: .same(proto: "groupAdminStatusUpdate"),
    10: .same(proto: "groupMemberLeftUpdate"),
    11: .same(proto: "groupMemberRemovedUpdate"),
    12: .same(proto: "selfInvitedToGroupUpdate"),
    13: .same(proto: "selfInvitedOtherUserToGroupUpdate"),
    14: .same(proto: "groupUnknownInviteeUpdate"),
    15: .same(proto: "groupInvitationAcceptedUpdate"),
    16: .same(proto: "groupInvitationDeclinedUpdate"),
    17: .same(proto: "groupMemberJoinedUpdate"),
    18: .same(proto: "groupMemberAddedUpdate"),
    19: .same(proto: "groupSelfInvitationRevokedUpdate"),
    20: .same(proto: "groupInvitationRevokedUpdate"),
    21: .same(proto: "groupJoinRequestUpdate"),
    22: .same(proto: "groupJoinRequestApprovalUpdate"),
    23: .same(proto: "groupJoinRequestCanceledUpdate"),
    24: .same(proto: "groupInviteLinkResetUpdate"),
    25: .same(proto: "groupInviteLinkEnabledUpdate"),
    26: .same(proto: "groupInviteLinkAdminApprovalUpdate"),
    27: .same(proto: "groupInviteLinkDisabledUpdate"),
    28: .same(proto: "groupMemberJoinedByLinkUpdate"),
    29: .same(proto: "groupV2MigrationUpdate"),
    30: .same(proto: "groupV2MigrationSelfInvitedUpdate"),
    31: .same(proto: "groupV2MigrationInvitedMembersUpdate"),
    32: .same(proto: "groupV2MigrationDroppedMembersUpdate"),
    33: .same(proto: "groupSequenceOfRequestsAndCancelsUpdate"),
    34: .same(proto: "groupExpirationTimerUpdate"),
  ]

  fileprivate class _StorageClass {
    var _genericGroupUpdate: BackupProtos_GenericGroupUpdate? = nil
    var _groupCreationUpdate: BackupProtos_GroupCreationUpdate? = nil
    var _groupNameUpdate: BackupProtos_GroupNameUpdate? = nil
    var _groupAvatarUpdate: BackupProtos_GroupAvatarUpdate? = nil
    var _groupDescriptionUpdate: BackupProtos_GroupDescriptionUpdate? = nil
    var _groupMembershipAccessLevelChangeUpdate: BackupProtos_GroupMembershipAccessLevelChangeUpdate? = nil
    var _groupAttributesAccessLevelChangeUpdate: BackupProtos_GroupAttributesAccessLevelChangeUpdate? = nil
    var _groupAnnouncementOnlyChangeUpdate: BackupProtos_GroupAnnouncementOnlyChangeUpdate? = nil
    var _groupAdminStatusUpdate: BackupProtos_GroupAdminStatusUpdate? = nil
    var _groupMemberLeftUpdate: BackupProtos_GroupMemberLeftUpdate? = nil
    var _groupMemberRemovedUpdate: BackupProtos_GroupMemberRemovedUpdate? = nil
    var _selfInvitedToGroupUpdate: BackupProtos_SelfInvitedToGroupUpdate? = nil
    var _selfInvitedOtherUserToGroupUpdate: BackupProtos_SelfInvitedOtherUserToGroupUpdate? = nil
    var _groupUnknownInviteeUpdate: BackupProtos_GroupUnknownInviteeUpdate? = nil
    var _groupInvitationAcceptedUpdate: BackupProtos_GroupInvitationAcceptedUpdate? = nil
    var _groupInvitationDeclinedUpdate: BackupProtos_GroupInvitationDeclinedUpdate? = nil
    var _groupMemberJoinedUpdate: BackupProtos_GroupMemberJoinedUpdate? = nil
    var _groupMemberAddedUpdate: BackupProtos_GroupMemberAddedUpdate? = nil
    var _groupSelfInvitationRevokedUpdate: BackupProtos_GroupSelfInvitationRevokedUpdate? = nil
    var _groupInvitationRevokedUpdate: BackupProtos_GroupInvitationRevokedUpdate? = nil
    var _groupJoinRequestUpdate: BackupProtos_GroupJoinRequestUpdate? = nil
    var _groupJoinRequestApprovalUpdate: BackupProtos_GroupJoinRequestApprovalUpdate? = nil
    var _groupJoinRequestCanceledUpdate: BackupProtos_GroupJoinRequestCanceledUpdate? = nil
    var _groupInviteLinkResetUpdate: BackupProtos_GroupInviteLinkResetUpdate? = nil
    var _groupInviteLinkEnabledUpdate: BackupProtos_GroupInviteLinkEnabledUpdate? = nil
    var _groupInviteLinkAdminApprovalUpdate: BackupProtos_GroupInviteLinkAdminApprovalUpdate? = nil
    var _groupInviteLinkDisabledUpdate: BackupProtos_GroupInviteLinkDisabledUpdate? = nil
    var _groupMemberJoinedByLinkUpdate: BackupProtos_GroupMemberJoinedByLinkUpdate? = nil
    var _groupV2MigrationUpdate: BackupProtos_GroupV2MigrationUpdate? = nil
    var _groupV2MigrationSelfInvitedUpdate: BackupProtos_GroupV2MigrationSelfInvitedUpdate? = nil
    var _groupV2MigrationInvitedMembersUpdate: BackupProtos_GroupV2MigrationInvitedMembersUpdate? = nil
    var _groupV2MigrationDroppedMembersUpdate: BackupProtos_GroupV2MigrationDroppedMembersUpdate? = nil
    var _groupSequenceOfRequestsAndCancelsUpdate: BackupProtos_GroupSequenceOfRequestsAndCancelsUpdate? = nil
    var _groupExpirationTimerUpdate: BackupProtos_GroupExpirationTimerUpdate? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _genericGroupUpdate = source._genericGroupUpdate
      _groupCreationUpdate = source._groupCreationUpdate
      _groupNameUpdate = source._groupNameUpdate
      _groupAvatarUpdate = source._groupAvatarUpdate
      _groupDescriptionUpdate = source._groupDescriptionUpdate
      _groupMembershipAccessLevelChangeUpdate = source._groupMembershipAccessLevelChangeUpdate
      _groupAttributesAccessLevelChangeUpdate = source._groupAttributesAccessLevelChangeUpdate
      _groupAnnouncementOnlyChangeUpdate = source._groupAnnouncementOnlyChangeUpdate
      _groupAdminStatusUpdate = source._groupAdminStatusUpdate
      _groupMemberLeftUpdate = source._groupMemberLeftUpdate
      _groupMemberRemovedUpdate = source._groupMemberRemovedUpdate
      _selfInvitedToGroupUpdate = source._selfInvitedToGroupUpdate
      _selfInvitedOtherUserToGroupUpdate = source._selfInvitedOtherUserToGroupUpdate
      _groupUnknownInviteeUpdate = source._groupUnknownInviteeUpdate
      _groupInvitationAcceptedUpdate = source._groupInvitationAcceptedUpdate
      _groupInvitationDeclinedUpdate = source._groupInvitationDeclinedUpdate
      _groupMemberJoinedUpdate = source._groupMemberJoinedUpdate
      _groupMemberAddedUpdate = source._groupMemberAddedUpdate
      _groupSelfInvitationRevokedUpdate = source._groupSelfInvitationRevokedUpdate
      _groupInvitationRevokedUpdate = source._groupInvitationRevokedUpdate
      _groupJoinRequestUpdate = source._groupJoinRequestUpdate
      _groupJoinRequestApprovalUpdate = source._groupJoinRequestApprovalUpdate
      _groupJoinRequestCanceledUpdate = source._groupJoinRequestCanceledUpdate
      _groupInviteLinkResetUpdate = source._groupInviteLinkResetUpdate
      _groupInviteLinkEnabledUpdate = source._groupInviteLinkEnabledUpdate
      _groupInviteLinkAdminApprovalUpdate = source._groupInviteLinkAdminApprovalUpdate
      _groupInviteLinkDisabledUpdate = source._groupInviteLinkDisabledUpdate
      _groupMemberJoinedByLinkUpdate = source._groupMemberJoinedByLinkUpdate
      _groupV2MigrationUpdate = source._groupV2MigrationUpdate
      _groupV2MigrationSelfInvitedUpdate = source._groupV2MigrationSelfInvitedUpdate
      _groupV2MigrationInvitedMembersUpdate = source._groupV2MigrationInvitedMembersUpdate
      _groupV2MigrationDroppedMembersUpdate = source._groupV2MigrationDroppedMembersUpdate
      _groupSequenceOfRequestsAndCancelsUpdate = source._groupSequenceOfRequestsAndCancelsUpdate
      _groupExpirationTimerUpdate = source._groupExpirationTimerUpdate
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._genericGroupUpdate) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._groupCreationUpdate) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._groupNameUpdate) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._groupAvatarUpdate) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._groupDescriptionUpdate) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._groupMembershipAccessLevelChangeUpdate) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._groupAttributesAccessLevelChangeUpdate) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._groupAnnouncementOnlyChangeUpdate) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._groupAdminStatusUpdate) }()
        case 10: try { try decoder.decodeSingularMessageField(value: &_storage._groupMemberLeftUpdate) }()
        case 11: try { try decoder.decodeSingularMessageField(value: &_storage._groupMemberRemovedUpdate) }()
        case 12: try { try decoder.decodeSingularMessageField(value: &_storage._selfInvitedToGroupUpdate) }()
        case 13: try { try decoder.decodeSingularMessageField(value: &_storage._selfInvitedOtherUserToGroupUpdate) }()
        case 14: try { try decoder.decodeSingularMessageField(value: &_storage._groupUnknownInviteeUpdate) }()
        case 15: try { try decoder.decodeSingularMessageField(value: &_storage._groupInvitationAcceptedUpdate) }()
        case 16: try { try decoder.decodeSingularMessageField(value: &_storage._groupInvitationDeclinedUpdate) }()
        case 17: try { try decoder.decodeSingularMessageField(value: &_storage._groupMemberJoinedUpdate) }()
        case 18: try { try decoder.decodeSingularMessageField(value: &_storage._groupMemberAddedUpdate) }()
        case 19: try { try decoder.decodeSingularMessageField(value: &_storage._groupSelfInvitationRevokedUpdate) }()
        case 20: try { try decoder.decodeSingularMessageField(value: &_storage._groupInvitationRevokedUpdate) }()
        case 21: try { try decoder.decodeSingularMessageField(value: &_storage._groupJoinRequestUpdate) }()
        case 22: try { try decoder.decodeSingularMessageField(value: &_storage._groupJoinRequestApprovalUpdate) }()
        case 23: try { try decoder.decodeSingularMessageField(value: &_storage._groupJoinRequestCanceledUpdate) }()
        case 24: try { try decoder.decodeSingularMessageField(value: &_storage._groupInviteLinkResetUpdate) }()
        case 25: try { try decoder.decodeSingularMessageField(value: &_storage._groupInviteLinkEnabledUpdate) }()
        case 26: try { try decoder.decodeSingularMessageField(value: &_storage._groupInviteLinkAdminApprovalUpdate) }()
        case 27: try { try decoder.decodeSingularMessageField(value: &_storage._groupInviteLinkDisabledUpdate) }()
        case 28: try { try decoder.decodeSingularMessageField(value: &_storage._groupMemberJoinedByLinkUpdate) }()
        case 29: try { try decoder.decodeSingularMessageField(value: &_storage._groupV2MigrationUpdate) }()
        case 30: try { try decoder.decodeSingularMessageField(value: &_storage._groupV2MigrationSelfInvitedUpdate) }()
        case 31: try { try decoder.decodeSingularMessageField(value: &_storage._groupV2MigrationInvitedMembersUpdate) }()
        case 32: try { try decoder.decodeSingularMessageField(value: &_storage._groupV2MigrationDroppedMembersUpdate) }()
        case 33: try { try decoder.decodeSingularMessageField(value: &_storage._groupSequenceOfRequestsAndCancelsUpdate) }()
        case 34: try { try decoder.decodeSingularMessageField(value: &_storage._groupExpirationTimerUpdate) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._genericGroupUpdate {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._groupCreationUpdate {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._groupNameUpdate {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._groupAvatarUpdate {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._groupDescriptionUpdate {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._groupMembershipAccessLevelChangeUpdate {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._groupAttributesAccessLevelChangeUpdate {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._groupAnnouncementOnlyChangeUpdate {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
      try { if let v = _storage._groupAdminStatusUpdate {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      } }()
      try { if let v = _storage._groupMemberLeftUpdate {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      } }()
      try { if let v = _storage._groupMemberRemovedUpdate {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      } }()
      try { if let v = _storage._selfInvitedToGroupUpdate {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      } }()
      try { if let v = _storage._selfInvitedOtherUserToGroupUpdate {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
      } }()
      try { if let v = _storage._groupUnknownInviteeUpdate {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
      } }()
      try { if let v = _storage._groupInvitationAcceptedUpdate {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
      } }()
      try { if let v = _storage._groupInvitationDeclinedUpdate {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
      } }()
      try { if let v = _storage._groupMemberJoinedUpdate {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
      } }()
      try { if let v = _storage._groupMemberAddedUpdate {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 18)
      } }()
      try { if let v = _storage._groupSelfInvitationRevokedUpdate {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 19)
      } }()
      try { if let v = _storage._groupInvitationRevokedUpdate {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 20)
      } }()
      try { if let v = _storage._groupJoinRequestUpdate {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 21)
      } }()
      try { if let v = _storage._groupJoinRequestApprovalUpdate {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 22)
      } }()
      try { if let v = _storage._groupJoinRequestCanceledUpdate {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 23)
      } }()
      try { if let v = _storage._groupInviteLinkResetUpdate {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 24)
      } }()
      try { if let v = _storage._groupInviteLinkEnabledUpdate {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 25)
      } }()
      try { if let v = _storage._groupInviteLinkAdminApprovalUpdate {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 26)
      } }()
      try { if let v = _storage._groupInviteLinkDisabledUpdate {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 27)
      } }()
      try { if let v = _storage._groupMemberJoinedByLinkUpdate {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 28)
      } }()
      try { if let v = _storage._groupV2MigrationUpdate {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 29)
      } }()
      try { if let v = _storage._groupV2MigrationSelfInvitedUpdate {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 30)
      } }()
      try { if let v = _storage._groupV2MigrationInvitedMembersUpdate {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 31)
      } }()
      try { if let v = _storage._groupV2MigrationDroppedMembersUpdate {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 32)
      } }()
      try { if let v = _storage._groupSequenceOfRequestsAndCancelsUpdate {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 33)
      } }()
      try { if let v = _storage._groupExpirationTimerUpdate {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 34)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: BackupProtos_GroupChangeChatUpdate.Update, rhs: BackupProtos_GroupChangeChatUpdate.Update) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._genericGroupUpdate != rhs_storage._genericGroupUpdate {return false}
        if _storage._groupCreationUpdate != rhs_storage._groupCreationUpdate {return false}
        if _storage._groupNameUpdate != rhs_storage._groupNameUpdate {return false}
        if _storage._groupAvatarUpdate != rhs_storage._groupAvatarUpdate {return false}
        if _storage._groupDescriptionUpdate != rhs_storage._groupDescriptionUpdate {return false}
        if _storage._groupMembershipAccessLevelChangeUpdate != rhs_storage._groupMembershipAccessLevelChangeUpdate {return false}
        if _storage._groupAttributesAccessLevelChangeUpdate != rhs_storage._groupAttributesAccessLevelChangeUpdate {return false}
        if _storage._groupAnnouncementOnlyChangeUpdate != rhs_storage._groupAnnouncementOnlyChangeUpdate {return false}
        if _storage._groupAdminStatusUpdate != rhs_storage._groupAdminStatusUpdate {return false}
        if _storage._groupMemberLeftUpdate != rhs_storage._groupMemberLeftUpdate {return false}
        if _storage._groupMemberRemovedUpdate != rhs_storage._groupMemberRemovedUpdate {return false}
        if _storage._selfInvitedToGroupUpdate != rhs_storage._selfInvitedToGroupUpdate {return false}
        if _storage._selfInvitedOtherUserToGroupUpdate != rhs_storage._selfInvitedOtherUserToGroupUpdate {return false}
        if _storage._groupUnknownInviteeUpdate != rhs_storage._groupUnknownInviteeUpdate {return false}
        if _storage._groupInvitationAcceptedUpdate != rhs_storage._groupInvitationAcceptedUpdate {return false}
        if _storage._groupInvitationDeclinedUpdate != rhs_storage._groupInvitationDeclinedUpdate {return false}
        if _storage._groupMemberJoinedUpdate != rhs_storage._groupMemberJoinedUpdate {return false}
        if _storage._groupMemberAddedUpdate != rhs_storage._groupMemberAddedUpdate {return false}
        if _storage._groupSelfInvitationRevokedUpdate != rhs_storage._groupSelfInvitationRevokedUpdate {return false}
        if _storage._groupInvitationRevokedUpdate != rhs_storage._groupInvitationRevokedUpdate {return false}
        if _storage._groupJoinRequestUpdate != rhs_storage._groupJoinRequestUpdate {return false}
        if _storage._groupJoinRequestApprovalUpdate != rhs_storage._groupJoinRequestApprovalUpdate {return false}
        if _storage._groupJoinRequestCanceledUpdate != rhs_storage._groupJoinRequestCanceledUpdate {return false}
        if _storage._groupInviteLinkResetUpdate != rhs_storage._groupInviteLinkResetUpdate {return false}
        if _storage._groupInviteLinkEnabledUpdate != rhs_storage._groupInviteLinkEnabledUpdate {return false}
        if _storage._groupInviteLinkAdminApprovalUpdate != rhs_storage._groupInviteLinkAdminApprovalUpdate {return false}
        if _storage._groupInviteLinkDisabledUpdate != rhs_storage._groupInviteLinkDisabledUpdate {return false}
        if _storage._groupMemberJoinedByLinkUpdate != rhs_storage._groupMemberJoinedByLinkUpdate {return false}
        if _storage._groupV2MigrationUpdate != rhs_storage._groupV2MigrationUpdate {return false}
        if _storage._groupV2MigrationSelfInvitedUpdate != rhs_storage._groupV2MigrationSelfInvitedUpdate {return false}
        if _storage._groupV2MigrationInvitedMembersUpdate != rhs_storage._groupV2MigrationInvitedMembersUpdate {return false}
        if _storage._groupV2MigrationDroppedMembersUpdate != rhs_storage._groupV2MigrationDroppedMembersUpdate {return false}
        if _storage._groupSequenceOfRequestsAndCancelsUpdate != rhs_storage._groupSequenceOfRequestsAndCancelsUpdate {return false}
        if _storage._groupExpirationTimerUpdate != rhs_storage._groupExpirationTimerUpdate {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProtos_GenericGroupUpdate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GenericGroupUpdate"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "updaterAci"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self._updaterAci) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._updaterAci {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: BackupProtos_GenericGroupUpdate, rhs: BackupProtos_GenericGroupUpdate) -> Bool {
    if lhs._updaterAci != rhs._updaterAci {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProtos_GroupCreationUpdate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GroupCreationUpdate"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "updaterAci"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self._updaterAci) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._updaterAci {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: BackupProtos_GroupCreationUpdate, rhs: BackupProtos_GroupCreationUpdate) -> Bool {
    if lhs._updaterAci != rhs._updaterAci {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProtos_GroupNameUpdate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GroupNameUpdate"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "updaterAci"),
    2: .same(proto: "newGroupName"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self._updaterAci) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._newGroupName) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._updaterAci {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._newGroupName {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: BackupProtos_GroupNameUpdate, rhs: BackupProtos_GroupNameUpdate) -> Bool {
    if lhs._updaterAci != rhs._updaterAci {return false}
    if lhs._newGroupName != rhs._newGroupName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProtos_GroupAvatarUpdate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GroupAvatarUpdate"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "updaterAci"),
    2: .same(proto: "wasRemoved"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self._updaterAci) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self._wasRemoved) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._updaterAci {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._wasRemoved {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: BackupProtos_GroupAvatarUpdate, rhs: BackupProtos_GroupAvatarUpdate) -> Bool {
    if lhs._updaterAci != rhs._updaterAci {return false}
    if lhs._wasRemoved != rhs._wasRemoved {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProtos_GroupDescriptionUpdate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GroupDescriptionUpdate"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "updaterAci"),
    2: .same(proto: "newDescription"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self._updaterAci) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._newDescription) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._updaterAci {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._newDescription {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: BackupProtos_GroupDescriptionUpdate, rhs: BackupProtos_GroupDescriptionUpdate) -> Bool {
    if lhs._updaterAci != rhs._updaterAci {return false}
    if lhs._newDescription != rhs._newDescription {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProtos_GroupMembershipAccessLevelChangeUpdate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GroupMembershipAccessLevelChangeUpdate"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "updaterAci"),
    2: .same(proto: "accessLevel"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self._updaterAci) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self._accessLevel) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._updaterAci {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._accessLevel {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: BackupProtos_GroupMembershipAccessLevelChangeUpdate, rhs: BackupProtos_GroupMembershipAccessLevelChangeUpdate) -> Bool {
    if lhs._updaterAci != rhs._updaterAci {return false}
    if lhs._accessLevel != rhs._accessLevel {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProtos_GroupAttributesAccessLevelChangeUpdate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GroupAttributesAccessLevelChangeUpdate"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "updaterAci"),
    2: .same(proto: "accessLevel"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self._updaterAci) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self._accessLevel) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._updaterAci {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._accessLevel {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: BackupProtos_GroupAttributesAccessLevelChangeUpdate, rhs: BackupProtos_GroupAttributesAccessLevelChangeUpdate) -> Bool {
    if lhs._updaterAci != rhs._updaterAci {return false}
    if lhs._accessLevel != rhs._accessLevel {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProtos_GroupAnnouncementOnlyChangeUpdate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GroupAnnouncementOnlyChangeUpdate"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "updaterAci"),
    2: .same(proto: "isAnnouncementOnly"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self._updaterAci) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self._isAnnouncementOnly) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._updaterAci {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._isAnnouncementOnly {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: BackupProtos_GroupAnnouncementOnlyChangeUpdate, rhs: BackupProtos_GroupAnnouncementOnlyChangeUpdate) -> Bool {
    if lhs._updaterAci != rhs._updaterAci {return false}
    if lhs._isAnnouncementOnly != rhs._isAnnouncementOnly {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProtos_GroupAdminStatusUpdate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GroupAdminStatusUpdate"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "updaterAci"),
    2: .same(proto: "memberAci"),
    3: .same(proto: "wasAdminStatusGranted"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self._updaterAci) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self._memberAci) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self._wasAdminStatusGranted) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._updaterAci {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._memberAci {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._wasAdminStatusGranted {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: BackupProtos_GroupAdminStatusUpdate, rhs: BackupProtos_GroupAdminStatusUpdate) -> Bool {
    if lhs._updaterAci != rhs._updaterAci {return false}
    if lhs._memberAci != rhs._memberAci {return false}
    if lhs._wasAdminStatusGranted != rhs._wasAdminStatusGranted {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProtos_GroupMemberLeftUpdate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GroupMemberLeftUpdate"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "aci"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self._aci) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._aci {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: BackupProtos_GroupMemberLeftUpdate, rhs: BackupProtos_GroupMemberLeftUpdate) -> Bool {
    if lhs._aci != rhs._aci {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProtos_GroupMemberRemovedUpdate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GroupMemberRemovedUpdate"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "removerAci"),
    2: .same(proto: "removedAci"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self._removerAci) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self._removedAci) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._removerAci {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._removedAci {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: BackupProtos_GroupMemberRemovedUpdate, rhs: BackupProtos_GroupMemberRemovedUpdate) -> Bool {
    if lhs._removerAci != rhs._removerAci {return false}
    if lhs._removedAci != rhs._removedAci {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProtos_SelfInvitedToGroupUpdate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SelfInvitedToGroupUpdate"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "inviterAci"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self._inviterAci) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._inviterAci {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: BackupProtos_SelfInvitedToGroupUpdate, rhs: BackupProtos_SelfInvitedToGroupUpdate) -> Bool {
    if lhs._inviterAci != rhs._inviterAci {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProtos_SelfInvitedOtherUserToGroupUpdate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SelfInvitedOtherUserToGroupUpdate"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "inviteeServiceId"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self._inviteeServiceID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._inviteeServiceID {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: BackupProtos_SelfInvitedOtherUserToGroupUpdate, rhs: BackupProtos_SelfInvitedOtherUserToGroupUpdate) -> Bool {
    if lhs._inviteeServiceID != rhs._inviteeServiceID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProtos_GroupUnknownInviteeUpdate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GroupUnknownInviteeUpdate"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "inviterAci"),
    2: .same(proto: "inviteeCount"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self._inviterAci) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self._inviteeCount) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._inviterAci {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._inviteeCount {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: BackupProtos_GroupUnknownInviteeUpdate, rhs: BackupProtos_GroupUnknownInviteeUpdate) -> Bool {
    if lhs._inviterAci != rhs._inviterAci {return false}
    if lhs._inviteeCount != rhs._inviteeCount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProtos_GroupInvitationAcceptedUpdate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GroupInvitationAcceptedUpdate"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "inviterAci"),
    2: .same(proto: "newMemberAci"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self._inviterAci) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self._newMemberAci) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._inviterAci {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._newMemberAci {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: BackupProtos_GroupInvitationAcceptedUpdate, rhs: BackupProtos_GroupInvitationAcceptedUpdate) -> Bool {
    if lhs._inviterAci != rhs._inviterAci {return false}
    if lhs._newMemberAci != rhs._newMemberAci {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProtos_GroupInvitationDeclinedUpdate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GroupInvitationDeclinedUpdate"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "inviterAci"),
    2: .same(proto: "inviteeAci"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self._inviterAci) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self._inviteeAci) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._inviterAci {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._inviteeAci {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: BackupProtos_GroupInvitationDeclinedUpdate, rhs: BackupProtos_GroupInvitationDeclinedUpdate) -> Bool {
    if lhs._inviterAci != rhs._inviterAci {return false}
    if lhs._inviteeAci != rhs._inviteeAci {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProtos_GroupMemberJoinedUpdate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GroupMemberJoinedUpdate"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "newMemberAci"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self._newMemberAci) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._newMemberAci {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: BackupProtos_GroupMemberJoinedUpdate, rhs: BackupProtos_GroupMemberJoinedUpdate) -> Bool {
    if lhs._newMemberAci != rhs._newMemberAci {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProtos_GroupMemberAddedUpdate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GroupMemberAddedUpdate"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "updaterAci"),
    2: .same(proto: "newMemberAci"),
    3: .same(proto: "hadOpenInvitation"),
    4: .same(proto: "inviterAci"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self._updaterAci) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self._newMemberAci) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self._hadOpenInvitation) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self._inviterAci) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._updaterAci {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._newMemberAci {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._hadOpenInvitation {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._inviterAci {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: BackupProtos_GroupMemberAddedUpdate, rhs: BackupProtos_GroupMemberAddedUpdate) -> Bool {
    if lhs._updaterAci != rhs._updaterAci {return false}
    if lhs._newMemberAci != rhs._newMemberAci {return false}
    if lhs._hadOpenInvitation != rhs._hadOpenInvitation {return false}
    if lhs._inviterAci != rhs._inviterAci {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProtos_GroupSelfInvitationRevokedUpdate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GroupSelfInvitationRevokedUpdate"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "revokerAci"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self._revokerAci) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._revokerAci {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: BackupProtos_GroupSelfInvitationRevokedUpdate, rhs: BackupProtos_GroupSelfInvitationRevokedUpdate) -> Bool {
    if lhs._revokerAci != rhs._revokerAci {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProtos_GroupInvitationRevokedUpdate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GroupInvitationRevokedUpdate"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "updaterAci"),
    2: .same(proto: "invitees"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self._updaterAci) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.invitees) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._updaterAci {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 1)
    } }()
    if !self.invitees.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.invitees, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: BackupProtos_GroupInvitationRevokedUpdate, rhs: BackupProtos_GroupInvitationRevokedUpdate) -> Bool {
    if lhs._updaterAci != rhs._updaterAci {return false}
    if lhs.invitees != rhs.invitees {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProtos_GroupInvitationRevokedUpdate.Invitee: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = BackupProtos_GroupInvitationRevokedUpdate.protoMessageName + ".Invitee"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "inviterAci"),
    2: .same(proto: "inviteeAci"),
    3: .same(proto: "inviteePni"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self._inviterAci) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self._inviteeAci) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self._inviteePni) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._inviterAci {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._inviteeAci {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._inviteePni {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: BackupProtos_GroupInvitationRevokedUpdate.Invitee, rhs: BackupProtos_GroupInvitationRevokedUpdate.Invitee) -> Bool {
    if lhs._inviterAci != rhs._inviterAci {return false}
    if lhs._inviteeAci != rhs._inviteeAci {return false}
    if lhs._inviteePni != rhs._inviteePni {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProtos_GroupJoinRequestUpdate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GroupJoinRequestUpdate"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "requestorAci"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self._requestorAci) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._requestorAci {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: BackupProtos_GroupJoinRequestUpdate, rhs: BackupProtos_GroupJoinRequestUpdate) -> Bool {
    if lhs._requestorAci != rhs._requestorAci {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProtos_GroupJoinRequestApprovalUpdate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GroupJoinRequestApprovalUpdate"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "requestorAci"),
    2: .same(proto: "updaterAci"),
    3: .same(proto: "wasApproved"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self._requestorAci) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self._updaterAci) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self._wasApproved) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._requestorAci {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._updaterAci {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._wasApproved {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: BackupProtos_GroupJoinRequestApprovalUpdate, rhs: BackupProtos_GroupJoinRequestApprovalUpdate) -> Bool {
    if lhs._requestorAci != rhs._requestorAci {return false}
    if lhs._updaterAci != rhs._updaterAci {return false}
    if lhs._wasApproved != rhs._wasApproved {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProtos_GroupJoinRequestCanceledUpdate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GroupJoinRequestCanceledUpdate"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "requestorAci"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self._requestorAci) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._requestorAci {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: BackupProtos_GroupJoinRequestCanceledUpdate, rhs: BackupProtos_GroupJoinRequestCanceledUpdate) -> Bool {
    if lhs._requestorAci != rhs._requestorAci {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProtos_GroupSequenceOfRequestsAndCancelsUpdate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GroupSequenceOfRequestsAndCancelsUpdate"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "requestorAci"),
    2: .same(proto: "count"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self._requestorAci) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self._count) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._requestorAci {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._count {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: BackupProtos_GroupSequenceOfRequestsAndCancelsUpdate, rhs: BackupProtos_GroupSequenceOfRequestsAndCancelsUpdate) -> Bool {
    if lhs._requestorAci != rhs._requestorAci {return false}
    if lhs._count != rhs._count {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProtos_GroupInviteLinkResetUpdate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GroupInviteLinkResetUpdate"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "updaterAci"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self._updaterAci) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._updaterAci {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: BackupProtos_GroupInviteLinkResetUpdate, rhs: BackupProtos_GroupInviteLinkResetUpdate) -> Bool {
    if lhs._updaterAci != rhs._updaterAci {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProtos_GroupInviteLinkEnabledUpdate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GroupInviteLinkEnabledUpdate"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "updaterAci"),
    2: .same(proto: "linkRequiresAdminApproval"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self._updaterAci) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self._linkRequiresAdminApproval) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._updaterAci {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._linkRequiresAdminApproval {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: BackupProtos_GroupInviteLinkEnabledUpdate, rhs: BackupProtos_GroupInviteLinkEnabledUpdate) -> Bool {
    if lhs._updaterAci != rhs._updaterAci {return false}
    if lhs._linkRequiresAdminApproval != rhs._linkRequiresAdminApproval {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProtos_GroupInviteLinkAdminApprovalUpdate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GroupInviteLinkAdminApprovalUpdate"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "updaterAci"),
    2: .same(proto: "linkRequiresAdminApproval"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self._updaterAci) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self._linkRequiresAdminApproval) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._updaterAci {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._linkRequiresAdminApproval {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: BackupProtos_GroupInviteLinkAdminApprovalUpdate, rhs: BackupProtos_GroupInviteLinkAdminApprovalUpdate) -> Bool {
    if lhs._updaterAci != rhs._updaterAci {return false}
    if lhs._linkRequiresAdminApproval != rhs._linkRequiresAdminApproval {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProtos_GroupInviteLinkDisabledUpdate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GroupInviteLinkDisabledUpdate"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "updaterAci"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self._updaterAci) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._updaterAci {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: BackupProtos_GroupInviteLinkDisabledUpdate, rhs: BackupProtos_GroupInviteLinkDisabledUpdate) -> Bool {
    if lhs._updaterAci != rhs._updaterAci {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProtos_GroupMemberJoinedByLinkUpdate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GroupMemberJoinedByLinkUpdate"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "newMemberAci"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self._newMemberAci) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._newMemberAci {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: BackupProtos_GroupMemberJoinedByLinkUpdate, rhs: BackupProtos_GroupMemberJoinedByLinkUpdate) -> Bool {
    if lhs._newMemberAci != rhs._newMemberAci {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProtos_GroupV2MigrationUpdate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GroupV2MigrationUpdate"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: BackupProtos_GroupV2MigrationUpdate, rhs: BackupProtos_GroupV2MigrationUpdate) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProtos_GroupV2MigrationSelfInvitedUpdate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GroupV2MigrationSelfInvitedUpdate"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: BackupProtos_GroupV2MigrationSelfInvitedUpdate, rhs: BackupProtos_GroupV2MigrationSelfInvitedUpdate) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProtos_GroupV2MigrationInvitedMembersUpdate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GroupV2MigrationInvitedMembersUpdate"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "invitedMembersCount"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self._invitedMembersCount) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._invitedMembersCount {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: BackupProtos_GroupV2MigrationInvitedMembersUpdate, rhs: BackupProtos_GroupV2MigrationInvitedMembersUpdate) -> Bool {
    if lhs._invitedMembersCount != rhs._invitedMembersCount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProtos_GroupV2MigrationDroppedMembersUpdate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GroupV2MigrationDroppedMembersUpdate"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "droppedMembersCount"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self._droppedMembersCount) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._droppedMembersCount {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: BackupProtos_GroupV2MigrationDroppedMembersUpdate, rhs: BackupProtos_GroupV2MigrationDroppedMembersUpdate) -> Bool {
    if lhs._droppedMembersCount != rhs._droppedMembersCount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProtos_GroupExpirationTimerUpdate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GroupExpirationTimerUpdate"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "expiresInMs"),
    2: .same(proto: "updaterAci"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self._expiresInMs) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self._updaterAci) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._expiresInMs {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._updaterAci {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: BackupProtos_GroupExpirationTimerUpdate, rhs: BackupProtos_GroupExpirationTimerUpdate) -> Bool {
    if lhs._expiresInMs != rhs._expiresInMs {return false}
    if lhs._updaterAci != rhs._updaterAci {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProtos_StickerPack: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".StickerPack"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "key"),
    3: .same(proto: "title"),
    4: .same(proto: "author"),
    5: .same(proto: "stickers"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self._id) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self._key) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._title) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self._author) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.stickers) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._id {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._key {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._title {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._author {
      try visitor.visitSingularStringField(value: v, fieldNumber: 4)
    } }()
    if !self.stickers.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.stickers, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: BackupProtos_StickerPack, rhs: BackupProtos_StickerPack) -> Bool {
    if lhs._id != rhs._id {return false}
    if lhs._key != rhs._key {return false}
    if lhs._title != rhs._title {return false}
    if lhs._author != rhs._author {return false}
    if lhs.stickers != rhs.stickers {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProtos_StickerPackSticker: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".StickerPackSticker"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "data"),
    2: .same(proto: "emoji"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._data) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._emoji) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._data {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._emoji {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: BackupProtos_StickerPackSticker, rhs: BackupProtos_StickerPackSticker) -> Bool {
    if lhs._data != rhs._data {return false}
    if lhs._emoji != rhs._emoji {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
