//
//  Copyright (c) 2019 Open Whisper Systems. All rights reserved.
//

#import "TSGroupThread.h"
#import "TSAttachmentStream.h"
#import <SignalCoreKit/NSData+OWS.h>
#import <SignalServiceKit/SignalServiceKit-Swift.h>
#import <SignalServiceKit/TSAccountManager.h>

NS_ASSUME_NONNULL_BEGIN

NSString *const TSGroupThreadAvatarChangedNotification = @"TSGroupThreadAvatarChangedNotification";
NSString *const TSGroupThread_NotificationKey_UniqueId = @"TSGroupThread_NotificationKey_UniqueId";

@implementation TSGroupThread

#define TSGroupThreadPrefix @"g"

// --- CODE GENERATION MARKER

// This snippet is generated by /Scripts/sds_codegen/sds_generate.py. Do not manually edit it, instead run `sds_codegen.sh`.

// clang-format off

- (instancetype)initWithUniqueId:(NSString *)uniqueId
                    archivalDate:(nullable NSDate *)archivalDate
       archivedAsOfMessageSortId:(nullable NSNumber *)archivedAsOfMessageSortId
           conversationColorName:(ConversationColorName)conversationColorName
                    creationDate:(nullable NSDate *)creationDate
isArchivedByLegacyTimestampForSorting:(BOOL)isArchivedByLegacyTimestampForSorting
                 lastMessageDate:(nullable NSDate *)lastMessageDate
                    messageDraft:(nullable NSString *)messageDraft
                  mutedUntilDate:(nullable NSDate *)mutedUntilDate
                           rowId:(int64_t)rowId
           shouldThreadBeVisible:(BOOL)shouldThreadBeVisible
                      groupModel:(TSGroupModel *)groupModel
{
    self = [super initWithUniqueId:uniqueId
                      archivalDate:archivalDate
         archivedAsOfMessageSortId:archivedAsOfMessageSortId
             conversationColorName:conversationColorName
                      creationDate:creationDate
isArchivedByLegacyTimestampForSorting:isArchivedByLegacyTimestampForSorting
                   lastMessageDate:lastMessageDate
                      messageDraft:messageDraft
                    mutedUntilDate:mutedUntilDate
                             rowId:rowId
             shouldThreadBeVisible:shouldThreadBeVisible];

    if (!self) {
        return self;
    }

    _groupModel = groupModel;

    return self;
}

// clang-format on

// --- CODE GENERATION MARKER

- (instancetype)initWithGroupModel:(TSGroupModel *)groupModel
{
    OWSAssertDebug(groupModel);
    OWSAssertDebug(groupModel.groupId.length > 0);
    OWSAssertDebug(groupModel.groupMembers.count > 0);
    for (SignalServiceAddress *address in groupModel.groupMembers) {
        OWSAssertDebug(address.isValid);
    }

    NSString *uniqueIdentifier = [[self class] threadIdFromGroupId:groupModel.groupId];
    self = [super initWithUniqueId:uniqueIdentifier];
    if (!self) {
        return self;
    }

    _groupModel = groupModel;

    return self;
}

- (instancetype)initWithGroupId:(NSData *)groupId
{
    OWSAssertDebug(groupId.length > 0);

    SignalServiceAddress *localAddress = TSAccountManager.localAddress;
    OWSAssertDebug(localAddress.isValid);

    TSGroupModel *groupModel = [[TSGroupModel alloc] initWithTitle:nil
                                                           members:@[ localAddress ]
                                                             image:nil
                                                           groupId:groupId];

    self = [self initWithGroupModel:groupModel];
    if (!self) {
        return self;
    }

    return self;
}

+ (nullable instancetype)threadWithUniqueId:(NSString *)uniqueId transaction:(SDSAnyReadTransaction *)transaction
{
    OWSAssertDebug(uniqueId.length > 0);

    TSThread *_Nullable thread = [self anyFetchWithUniqueId:uniqueId transaction:transaction];
    if (thread && ![thread isKindOfClass:[TSGroupThread class]]) {
        OWSFailDebug(@"Thread has unexpected type.");
        return nil;
    }
    return (TSGroupThread *)thread;
}

+ (nullable instancetype)threadWithGroupId:(NSData *)groupId transaction:(SDSAnyReadTransaction *)transaction
{
    OWSAssertDebug(groupId.length > 0);

    NSString *uniqueId = [self threadIdFromGroupId:groupId];
    return [self threadWithUniqueId:uniqueId transaction:transaction];
}

+ (instancetype)getOrCreateThreadWithGroupId:(NSData *)groupId transaction:(SDSAnyWriteTransaction *)transaction
{
    OWSAssertDebug(groupId.length > 0);
    OWSAssertDebug(transaction);

    NSString *uniqueId = [self threadIdFromGroupId:groupId];
    TSGroupThread *thread = [self threadWithUniqueId:uniqueId transaction:transaction];
    if (!thread) {
        thread = [[self alloc] initWithGroupId:groupId];
        [thread anyInsertWithTransaction:transaction];
    }
    return thread;
}

+ (instancetype)getOrCreateThreadWithGroupId:(NSData *)groupId
{
    OWSAssertDebug(groupId.length > 0);

    __block TSGroupThread *thread;
    [self.databaseStorage writeWithBlock:^(SDSAnyWriteTransaction *transaction) {
        thread = [self getOrCreateThreadWithGroupId:groupId transaction:transaction];
    }];
    return thread;
}

+ (instancetype)getOrCreateThreadWithGroupModel:(TSGroupModel *)groupModel
                                    transaction:(SDSAnyWriteTransaction *)transaction
{
    OWSAssertDebug(groupModel);
    OWSAssertDebug(groupModel.groupId.length > 0);
    OWSAssertDebug(transaction);

    TSGroupThread *thread = (TSGroupThread *)[self anyFetchWithUniqueId:[self threadIdFromGroupId:groupModel.groupId]
                                                            transaction:transaction];

    if (!thread) {
        thread = [[TSGroupThread alloc] initWithGroupModel:groupModel];
        [thread anyInsertWithTransaction:transaction];
    }
    return thread;
}

+ (instancetype)getOrCreateThreadWithGroupModel:(TSGroupModel *)groupModel
{
    OWSAssertDebug(groupModel);
    OWSAssertDebug(groupModel.groupId.length > 0);

    __block TSGroupThread *thread;
    [self.databaseStorage writeWithBlock:^(SDSAnyWriteTransaction *transaction) {
        thread = [self getOrCreateThreadWithGroupModel:groupModel transaction:transaction];
    }];
    return thread;
}

+ (NSString *)threadIdFromGroupId:(NSData *)groupId
{
    OWSAssertDebug(groupId.length > 0);

    return [TSGroupThreadPrefix stringByAppendingString:[groupId base64EncodedString]];
}

+ (NSData *)groupIdFromThreadId:(NSString *)threadId
{
    OWSAssertDebug(threadId.length > 0);

    return [NSData dataFromBase64String:[threadId substringWithRange:NSMakeRange(1, threadId.length - 1)]];
}

- (NSArray<SignalServiceAddress *> *)recipientAddresses
{
    NSMutableArray<SignalServiceAddress *> *groupMembers = [self.groupModel.groupMembers mutableCopy];
    if (groupMembers == nil) {
        return @[];
    }

    [groupMembers removeObject:TSAccountManager.localAddress];

    return [groupMembers copy];
}

// @returns all threads to which the recipient is a member.
//
// @note If this becomes a hotspot we can extract into a YapDB View.
// As is, the number of groups should be small (dozens, *maybe* hundreds), and we only enumerate them upon SN changes.
+ (NSArray<TSGroupThread *> *)groupThreadsWithAddress:(SignalServiceAddress *)address
                                          transaction:(SDSAnyReadTransaction *)transaction
{
    OWSAssertDebug(address.isValid);
    OWSAssertDebug(transaction);

    NSMutableArray<TSGroupThread *> *groupThreads = [NSMutableArray new];

    [TSThread anyEnumerateWithTransaction:transaction
                                    block:^(TSThread *thread, BOOL *stop) {
                                        if ([thread isKindOfClass:[TSGroupThread class]]) {
                                            TSGroupThread *groupThread = (TSGroupThread *)thread;
                                            if ([groupThread.groupModel.groupMembers containsObject:address]) {
                                                [groupThreads addObject:groupThread];
                                            }
                                        }
                                    }];

    return [groupThreads copy];
}

- (BOOL)isGroupThread
{
    return true;
}

- (BOOL)isLocalUserInGroup
{
    SignalServiceAddress *_Nullable localAddress = TSAccountManager.localAddress;
    if (localAddress == nil) {
        return NO;
    }

    return [self.groupModel.groupMembers containsObject:localAddress];
}

- (NSString *)name
{
    // TODO sometimes groupName is set to the empty string. I'm hesitent to change
    // the semantics here until we have time to thouroughly test the fallout.
    // Instead, see the `groupNameOrDefault` which is appropriate for use when displaying
    // text corresponding to a group.
    return self.groupModel.groupName ?: self.class.defaultGroupName;
}

+ (NSString *)defaultGroupName
{
    return NSLocalizedString(@"NEW_GROUP_DEFAULT_TITLE", @"");
}

- (void)leaveGroupWithSneakyTransaction
{
    [self.databaseStorage writeWithBlock:^(SDSAnyWriteTransaction *transaction) {
        [self leaveGroupWithTransaction:transaction];
    }];
}

- (void)leaveGroupWithTransaction:(SDSAnyWriteTransaction *)transaction
{
    SignalServiceAddress *_Nullable localAddress = TSAccountManager.localAddress;
    OWSAssertDebug(localAddress);

    [self anyUpdateWithTransaction:transaction
                             block:^(TSThread *thread) {
                                 if (![thread isKindOfClass:[TSGroupThread class]]) {
                                     OWSFailDebug(@"Object has unexpected type: %@", thread.class);
                                     return;
                                 }
                                 TSGroupThread *groupThread = (TSGroupThread *)thread;
                                 NSMutableArray<SignalServiceAddress *> *newGroupMembers =
                                     [groupThread.groupModel.groupMembers mutableCopy];
                                 [newGroupMembers removeObject:localAddress];

                                 groupThread.groupModel.groupMembers = newGroupMembers;
                             }];
}

- (void)softDeleteGroupThreadWithTransaction:(SDSAnyWriteTransaction *)transaction
{
    [self removeAllThreadInteractionsWithTransaction:transaction];

    [self anyUpdateWithTransaction:transaction
                             block:^(TSThread *thread) {
                                 if (![thread isKindOfClass:[TSGroupThread class]]) {
                                     OWSFailDebug(@"Object has unexpected type: %@", thread.class);
                                     return;
                                 }
                                 TSGroupThread *groupThread = (TSGroupThread *)thread;
                                 groupThread.shouldThreadBeVisible = NO;
                             }];
}

#pragma mark - Avatar

- (void)updateAvatarWithAttachmentStream:(TSAttachmentStream *)attachmentStream
{
    [self.databaseStorage writeWithBlock:^(SDSAnyWriteTransaction *transaction) {
        [self updateAvatarWithAttachmentStream:attachmentStream transaction:transaction];
    }];
}

- (void)updateAvatarWithAttachmentStream:(TSAttachmentStream *)attachmentStream
                             transaction:(SDSAnyWriteTransaction *)transaction
{
    OWSAssertDebug(attachmentStream);
    OWSAssertDebug(transaction);

    [self anyUpdateWithTransaction:transaction
                             block:^(TSThread *thread) {
                                 if (![thread isKindOfClass:[TSGroupThread class]]) {
                                     OWSFailDebug(@"Unexpected object type: %@", [thread class]);
                                     return;
                                 }
                                 TSGroupThread *groupThread = (TSGroupThread *)thread;
                                 groupThread.groupModel.groupImage = [attachmentStream thumbnailImageSmallSync];
                             }];

    [transaction addCompletionWithBlock:^{
        [self fireAvatarChangedNotification];
    }];

    // Avatars are stored directly in the database, so there's no need
    // to keep the attachment around after assigning the image.
    [attachmentStream anyRemoveWithTransaction:transaction];
}

- (void)fireAvatarChangedNotification
{
    OWSAssertIsOnMainThread();

    NSDictionary *userInfo = @{ TSGroupThread_NotificationKey_UniqueId : self.uniqueId };

    [[NSNotificationCenter defaultCenter] postNotificationName:TSGroupThreadAvatarChangedNotification
                                                        object:self.uniqueId
                                                      userInfo:userInfo];
}

+ (ConversationColorName)defaultConversationColorNameForGroupId:(NSData *)groupId
{
    OWSAssertDebug(groupId.length > 0);

    return [self.class stableColorNameForNewConversationWithString:[self threadIdFromGroupId:groupId]];
}

@end

NS_ASSUME_NONNULL_END
