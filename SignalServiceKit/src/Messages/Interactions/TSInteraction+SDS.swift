//
//  Copyright (c) 2019 Open Whisper Systems. All rights reserved.
//

import Foundation
import GRDBCipher
import SignalCoreKit

// NOTE: This file is generated by /Scripts/sds_codegen/sds_generate.py.
// Do not manually edit it, instead run `sds_codegen.sh`.

// MARK: - Record

public struct InteractionRecord: SDSRecord {
    public var tableMetadata: SDSTableMetadata {
        return TSInteractionSerializer.table
    }

    public static let databaseTableName: String = TSInteractionSerializer.table.tableName

    public var id: Int64?

    // This defines all of the columns used in the table
    // where this model (and any subclasses) are persisted.
    public let recordType: SDSRecordType
    public let uniqueId: String

    // Base class properties
    public let receivedAtTimestamp: UInt64
    public let timestamp: UInt64
    public let threadUniqueId: String

    // Subclass properties
    public let attachmentFilenameMap: Data?
    public let attachmentIds: Data?
    public let authorId: String?
    public let beforeInteractionId: String?
    public let body: String?
    public let callSchemaVersion: UInt?
    public let callType: RPRecentCallType?
    public let configurationDurationSeconds: UInt32?
    public let configurationIsEnabled: Bool?
    public let contactId: String?
    public let contactShare: Data?
    public let createdByRemoteName: String?
    public let createdInExistingGroup: Bool?
    public let customMessage: String?
    public let envelopeData: Data?
    public let errorMessageSchemaVersion: UInt?
    public let errorType: TSErrorMessageType?
    public let expireStartedAt: UInt64?
    public let expiresAt: UInt64?
    public let expiresInSeconds: UInt32?
    public let groupMetaMessage: TSGroupMetaMessage?
    public let hasAddToContactsOffer: Bool?
    public let hasAddToProfileWhitelistOffer: Bool?
    public let hasBlockOffer: Bool?
    public let hasLegacyMessageState: Bool?
    public let hasSyncedTranscript: Bool?
    public let infoMessageSchemaVersion: UInt?
    public let isFromLinkedDevice: Bool?
    public let isLocalChange: Bool?
    public let isVoiceMessage: Bool?
    public let legacyMessageState: TSOutgoingMessageState?
    public let legacyWasDelivered: Bool?
    public let linkPreview: Data?
    public let messageId: String?
    public let messageSticker: Data?
    public let messageType: TSInfoMessageType?
    public let mostRecentFailureText: String?
    public let perMessageExpirationDurationSeconds: UInt32?
    public let perMessageExpirationHasExpired: Bool?
    public let perMessageExpireStartedAt: UInt64?
    public let preKeyBundle: Data?
    public let protocolVersion: UInt?
    public let quotedMessage: Data?
    public let read: Bool?
    public let recipientId: String?
    public let recipientStateMap: Data?
    public let schemaVersion: UInt?
    public let senderId: String?
    public let serverTimestamp: UInt64?
    public let sourceDeviceId: UInt32?
    public let unregisteredRecipientId: String?
    public let verificationState: OWSVerificationState?
    public let wasReceivedByUD: Bool?

    public enum CodingKeys: String, CodingKey, ColumnExpression, CaseIterable {
        case id
        case recordType
        case uniqueId
        case receivedAtTimestamp
        case timestamp
        case threadUniqueId = "uniqueThreadId"
        case attachmentFilenameMap
        case attachmentIds
        case authorId
        case beforeInteractionId
        case body
        case callSchemaVersion
        case callType
        case configurationDurationSeconds
        case configurationIsEnabled
        case contactId
        case contactShare
        case createdByRemoteName
        case createdInExistingGroup
        case customMessage
        case envelopeData
        case errorMessageSchemaVersion
        case errorType
        case expireStartedAt
        case expiresAt
        case expiresInSeconds
        case groupMetaMessage
        case hasAddToContactsOffer
        case hasAddToProfileWhitelistOffer
        case hasBlockOffer
        case hasLegacyMessageState
        case hasSyncedTranscript
        case infoMessageSchemaVersion
        case isFromLinkedDevice
        case isLocalChange
        case isVoiceMessage
        case legacyMessageState
        case legacyWasDelivered
        case linkPreview
        case messageId
        case messageSticker
        case messageType
        case mostRecentFailureText
        case perMessageExpirationDurationSeconds
        case perMessageExpirationHasExpired
        case perMessageExpireStartedAt
        case preKeyBundle
        case protocolVersion
        case quotedMessage
        case read
        case recipientId
        case recipientStateMap
        case schemaVersion
        case senderId
        case serverTimestamp
        case sourceDeviceId
        case unregisteredRecipientId
        case verificationState
        case wasReceivedByUD
    }

    public static func columnName(_ column: InteractionRecord.CodingKeys, fullyQualified: Bool = false) -> String {
        return fullyQualified ? "\(databaseTableName).\(column.rawValue)" : column.rawValue
    }
}

// MARK: - StringInterpolation

public extension String.StringInterpolation {
    mutating func appendInterpolation(interactionColumn column: InteractionRecord.CodingKeys) {
        appendLiteral(InteractionRecord.columnName(column))
    }
    mutating func appendInterpolation(interactionColumnFullyQualified column: InteractionRecord.CodingKeys) {
        appendLiteral(InteractionRecord.columnName(column, fullyQualified: true))
    }
}

// MARK: - Deserialization

// TODO: Rework metadata to not include, for example, columns, column indices.
extension TSInteraction {
    // This method defines how to deserialize a model, given a
    // database row.  The recordType column is used to determine
    // the corresponding model class.
    class func fromRecord(_ record: InteractionRecord) throws -> TSInteraction {

        guard let recordId = record.id else {
            throw SDSError.invalidValue
        }

        switch record.recordType {
        case .addToContactsOfferMessage:

            let uniqueId: String = record.uniqueId
            let receivedAtTimestamp: UInt64 = record.receivedAtTimestamp
            let sortId: UInt64 = UInt64(recordId)
            let timestamp: UInt64 = record.timestamp
            let uniqueThreadId: String = record.threadUniqueId
            let attachmentIdsSerialized: Data? = record.attachmentIds
            let attachmentIds: [String] = try SDSDeserialization.unarchive(attachmentIdsSerialized, name: "attachmentIds")
            let body: String? = record.body
            let contactShareSerialized: Data? = record.contactShare
            let contactShare: OWSContact? = try SDSDeserialization.optionalUnarchive(contactShareSerialized, name: "contactShare")
            let expireStartedAt: UInt64 = try SDSDeserialization.required(record.expireStartedAt, name: "expireStartedAt")
            let expiresAt: UInt64 = try SDSDeserialization.required(record.expiresAt, name: "expiresAt")
            let expiresInSeconds: UInt32 = try SDSDeserialization.required(record.expiresInSeconds, name: "expiresInSeconds")
            let linkPreviewSerialized: Data? = record.linkPreview
            let linkPreview: OWSLinkPreview? = try SDSDeserialization.optionalUnarchive(linkPreviewSerialized, name: "linkPreview")
            let messageStickerSerialized: Data? = record.messageSticker
            let messageSticker: MessageSticker? = try SDSDeserialization.optionalUnarchive(messageStickerSerialized, name: "messageSticker")
            let perMessageExpirationDurationSeconds: UInt32 = try SDSDeserialization.required(record.perMessageExpirationDurationSeconds, name: "perMessageExpirationDurationSeconds")
            let perMessageExpirationHasExpired: Bool = try SDSDeserialization.required(record.perMessageExpirationHasExpired, name: "perMessageExpirationHasExpired")
            let perMessageExpireStartedAt: UInt64 = try SDSDeserialization.required(record.perMessageExpireStartedAt, name: "perMessageExpireStartedAt")
            let quotedMessageSerialized: Data? = record.quotedMessage
            let quotedMessage: TSQuotedMessage? = try SDSDeserialization.optionalUnarchive(quotedMessageSerialized, name: "quotedMessage")
            let schemaVersion: UInt = try SDSDeserialization.required(record.schemaVersion, name: "schemaVersion")
            let customMessage: String? = record.customMessage
            let infoMessageSchemaVersion: UInt = try SDSDeserialization.required(record.infoMessageSchemaVersion, name: "infoMessageSchemaVersion")
            guard let messageType: TSInfoMessageType = record.messageType else {
               throw SDSError.missingRequiredField
            }
            let read: Bool = try SDSDeserialization.required(record.read, name: "read")
            let unregisteredRecipientId: String? = record.unregisteredRecipientId
            let contactId: String = try SDSDeserialization.required(record.contactId, name: "contactId")

            return OWSAddToContactsOfferMessage(uniqueId: uniqueId,
                                                receivedAtTimestamp: receivedAtTimestamp,
                                                sortId: sortId,
                                                timestamp: timestamp,
                                                uniqueThreadId: uniqueThreadId,
                                                attachmentIds: attachmentIds,
                                                body: body,
                                                contactShare: contactShare,
                                                expireStartedAt: expireStartedAt,
                                                expiresAt: expiresAt,
                                                expiresInSeconds: expiresInSeconds,
                                                linkPreview: linkPreview,
                                                messageSticker: messageSticker,
                                                perMessageExpirationDurationSeconds: perMessageExpirationDurationSeconds,
                                                perMessageExpirationHasExpired: perMessageExpirationHasExpired,
                                                perMessageExpireStartedAt: perMessageExpireStartedAt,
                                                quotedMessage: quotedMessage,
                                                schemaVersion: schemaVersion,
                                                customMessage: customMessage,
                                                infoMessageSchemaVersion: infoMessageSchemaVersion,
                                                messageType: messageType,
                                                read: read,
                                                unregisteredRecipientId: unregisteredRecipientId,
                                                contactId: contactId)

        case .addToProfileWhitelistOfferMessage:

            let uniqueId: String = record.uniqueId
            let receivedAtTimestamp: UInt64 = record.receivedAtTimestamp
            let sortId: UInt64 = UInt64(recordId)
            let timestamp: UInt64 = record.timestamp
            let uniqueThreadId: String = record.threadUniqueId
            let attachmentIdsSerialized: Data? = record.attachmentIds
            let attachmentIds: [String] = try SDSDeserialization.unarchive(attachmentIdsSerialized, name: "attachmentIds")
            let body: String? = record.body
            let contactShareSerialized: Data? = record.contactShare
            let contactShare: OWSContact? = try SDSDeserialization.optionalUnarchive(contactShareSerialized, name: "contactShare")
            let expireStartedAt: UInt64 = try SDSDeserialization.required(record.expireStartedAt, name: "expireStartedAt")
            let expiresAt: UInt64 = try SDSDeserialization.required(record.expiresAt, name: "expiresAt")
            let expiresInSeconds: UInt32 = try SDSDeserialization.required(record.expiresInSeconds, name: "expiresInSeconds")
            let linkPreviewSerialized: Data? = record.linkPreview
            let linkPreview: OWSLinkPreview? = try SDSDeserialization.optionalUnarchive(linkPreviewSerialized, name: "linkPreview")
            let messageStickerSerialized: Data? = record.messageSticker
            let messageSticker: MessageSticker? = try SDSDeserialization.optionalUnarchive(messageStickerSerialized, name: "messageSticker")
            let perMessageExpirationDurationSeconds: UInt32 = try SDSDeserialization.required(record.perMessageExpirationDurationSeconds, name: "perMessageExpirationDurationSeconds")
            let perMessageExpirationHasExpired: Bool = try SDSDeserialization.required(record.perMessageExpirationHasExpired, name: "perMessageExpirationHasExpired")
            let perMessageExpireStartedAt: UInt64 = try SDSDeserialization.required(record.perMessageExpireStartedAt, name: "perMessageExpireStartedAt")
            let quotedMessageSerialized: Data? = record.quotedMessage
            let quotedMessage: TSQuotedMessage? = try SDSDeserialization.optionalUnarchive(quotedMessageSerialized, name: "quotedMessage")
            let schemaVersion: UInt = try SDSDeserialization.required(record.schemaVersion, name: "schemaVersion")
            let customMessage: String? = record.customMessage
            let infoMessageSchemaVersion: UInt = try SDSDeserialization.required(record.infoMessageSchemaVersion, name: "infoMessageSchemaVersion")
            guard let messageType: TSInfoMessageType = record.messageType else {
               throw SDSError.missingRequiredField
            }
            let read: Bool = try SDSDeserialization.required(record.read, name: "read")
            let unregisteredRecipientId: String? = record.unregisteredRecipientId
            let contactId: String = try SDSDeserialization.required(record.contactId, name: "contactId")

            return OWSAddToProfileWhitelistOfferMessage(uniqueId: uniqueId,
                                                        receivedAtTimestamp: receivedAtTimestamp,
                                                        sortId: sortId,
                                                        timestamp: timestamp,
                                                        uniqueThreadId: uniqueThreadId,
                                                        attachmentIds: attachmentIds,
                                                        body: body,
                                                        contactShare: contactShare,
                                                        expireStartedAt: expireStartedAt,
                                                        expiresAt: expiresAt,
                                                        expiresInSeconds: expiresInSeconds,
                                                        linkPreview: linkPreview,
                                                        messageSticker: messageSticker,
                                                        perMessageExpirationDurationSeconds: perMessageExpirationDurationSeconds,
                                                        perMessageExpirationHasExpired: perMessageExpirationHasExpired,
                                                        perMessageExpireStartedAt: perMessageExpireStartedAt,
                                                        quotedMessage: quotedMessage,
                                                        schemaVersion: schemaVersion,
                                                        customMessage: customMessage,
                                                        infoMessageSchemaVersion: infoMessageSchemaVersion,
                                                        messageType: messageType,
                                                        read: read,
                                                        unregisteredRecipientId: unregisteredRecipientId,
                                                        contactId: contactId)

        case .contactOffersInteraction:

            let uniqueId: String = record.uniqueId
            let receivedAtTimestamp: UInt64 = record.receivedAtTimestamp
            let sortId: UInt64 = UInt64(recordId)
            let timestamp: UInt64 = record.timestamp
            let uniqueThreadId: String = record.threadUniqueId
            let beforeInteractionId: String = try SDSDeserialization.required(record.beforeInteractionId, name: "beforeInteractionId")
            let hasAddToContactsOffer: Bool = try SDSDeserialization.required(record.hasAddToContactsOffer, name: "hasAddToContactsOffer")
            let hasAddToProfileWhitelistOffer: Bool = try SDSDeserialization.required(record.hasAddToProfileWhitelistOffer, name: "hasAddToProfileWhitelistOffer")
            let hasBlockOffer: Bool = try SDSDeserialization.required(record.hasBlockOffer, name: "hasBlockOffer")
            let recipientId: String = try SDSDeserialization.required(record.recipientId, name: "recipientId")

            return OWSContactOffersInteraction(uniqueId: uniqueId,
                                               receivedAtTimestamp: receivedAtTimestamp,
                                               sortId: sortId,
                                               timestamp: timestamp,
                                               uniqueThreadId: uniqueThreadId,
                                               beforeInteractionId: beforeInteractionId,
                                               hasAddToContactsOffer: hasAddToContactsOffer,
                                               hasAddToProfileWhitelistOffer: hasAddToProfileWhitelistOffer,
                                               hasBlockOffer: hasBlockOffer,
                                               recipientId: recipientId)

        case .disappearingConfigurationUpdateInfoMessage:

            let uniqueId: String = record.uniqueId
            let receivedAtTimestamp: UInt64 = record.receivedAtTimestamp
            let sortId: UInt64 = UInt64(recordId)
            let timestamp: UInt64 = record.timestamp
            let uniqueThreadId: String = record.threadUniqueId
            let attachmentIdsSerialized: Data? = record.attachmentIds
            let attachmentIds: [String] = try SDSDeserialization.unarchive(attachmentIdsSerialized, name: "attachmentIds")
            let body: String? = record.body
            let contactShareSerialized: Data? = record.contactShare
            let contactShare: OWSContact? = try SDSDeserialization.optionalUnarchive(contactShareSerialized, name: "contactShare")
            let expireStartedAt: UInt64 = try SDSDeserialization.required(record.expireStartedAt, name: "expireStartedAt")
            let expiresAt: UInt64 = try SDSDeserialization.required(record.expiresAt, name: "expiresAt")
            let expiresInSeconds: UInt32 = try SDSDeserialization.required(record.expiresInSeconds, name: "expiresInSeconds")
            let linkPreviewSerialized: Data? = record.linkPreview
            let linkPreview: OWSLinkPreview? = try SDSDeserialization.optionalUnarchive(linkPreviewSerialized, name: "linkPreview")
            let messageStickerSerialized: Data? = record.messageSticker
            let messageSticker: MessageSticker? = try SDSDeserialization.optionalUnarchive(messageStickerSerialized, name: "messageSticker")
            let perMessageExpirationDurationSeconds: UInt32 = try SDSDeserialization.required(record.perMessageExpirationDurationSeconds, name: "perMessageExpirationDurationSeconds")
            let perMessageExpirationHasExpired: Bool = try SDSDeserialization.required(record.perMessageExpirationHasExpired, name: "perMessageExpirationHasExpired")
            let perMessageExpireStartedAt: UInt64 = try SDSDeserialization.required(record.perMessageExpireStartedAt, name: "perMessageExpireStartedAt")
            let quotedMessageSerialized: Data? = record.quotedMessage
            let quotedMessage: TSQuotedMessage? = try SDSDeserialization.optionalUnarchive(quotedMessageSerialized, name: "quotedMessage")
            let schemaVersion: UInt = try SDSDeserialization.required(record.schemaVersion, name: "schemaVersion")
            let customMessage: String? = record.customMessage
            let infoMessageSchemaVersion: UInt = try SDSDeserialization.required(record.infoMessageSchemaVersion, name: "infoMessageSchemaVersion")
            guard let messageType: TSInfoMessageType = record.messageType else {
               throw SDSError.missingRequiredField
            }
            let read: Bool = try SDSDeserialization.required(record.read, name: "read")
            let unregisteredRecipientId: String? = record.unregisteredRecipientId
            let configurationDurationSeconds: UInt32 = try SDSDeserialization.required(record.configurationDurationSeconds, name: "configurationDurationSeconds")
            let configurationIsEnabled: Bool = try SDSDeserialization.required(record.configurationIsEnabled, name: "configurationIsEnabled")
            let createdByRemoteName: String? = record.createdByRemoteName
            let createdInExistingGroup: Bool = try SDSDeserialization.required(record.createdInExistingGroup, name: "createdInExistingGroup")

            return OWSDisappearingConfigurationUpdateInfoMessage(uniqueId: uniqueId,
                                                                 receivedAtTimestamp: receivedAtTimestamp,
                                                                 sortId: sortId,
                                                                 timestamp: timestamp,
                                                                 uniqueThreadId: uniqueThreadId,
                                                                 attachmentIds: attachmentIds,
                                                                 body: body,
                                                                 contactShare: contactShare,
                                                                 expireStartedAt: expireStartedAt,
                                                                 expiresAt: expiresAt,
                                                                 expiresInSeconds: expiresInSeconds,
                                                                 linkPreview: linkPreview,
                                                                 messageSticker: messageSticker,
                                                                 perMessageExpirationDurationSeconds: perMessageExpirationDurationSeconds,
                                                                 perMessageExpirationHasExpired: perMessageExpirationHasExpired,
                                                                 perMessageExpireStartedAt: perMessageExpireStartedAt,
                                                                 quotedMessage: quotedMessage,
                                                                 schemaVersion: schemaVersion,
                                                                 customMessage: customMessage,
                                                                 infoMessageSchemaVersion: infoMessageSchemaVersion,
                                                                 messageType: messageType,
                                                                 read: read,
                                                                 unregisteredRecipientId: unregisteredRecipientId,
                                                                 configurationDurationSeconds: configurationDurationSeconds,
                                                                 configurationIsEnabled: configurationIsEnabled,
                                                                 createdByRemoteName: createdByRemoteName,
                                                                 createdInExistingGroup: createdInExistingGroup)

        case .unknownContactBlockOfferMessage:

            let uniqueId: String = record.uniqueId
            let receivedAtTimestamp: UInt64 = record.receivedAtTimestamp
            let sortId: UInt64 = UInt64(recordId)
            let timestamp: UInt64 = record.timestamp
            let uniqueThreadId: String = record.threadUniqueId
            let attachmentIdsSerialized: Data? = record.attachmentIds
            let attachmentIds: [String] = try SDSDeserialization.unarchive(attachmentIdsSerialized, name: "attachmentIds")
            let body: String? = record.body
            let contactShareSerialized: Data? = record.contactShare
            let contactShare: OWSContact? = try SDSDeserialization.optionalUnarchive(contactShareSerialized, name: "contactShare")
            let expireStartedAt: UInt64 = try SDSDeserialization.required(record.expireStartedAt, name: "expireStartedAt")
            let expiresAt: UInt64 = try SDSDeserialization.required(record.expiresAt, name: "expiresAt")
            let expiresInSeconds: UInt32 = try SDSDeserialization.required(record.expiresInSeconds, name: "expiresInSeconds")
            let linkPreviewSerialized: Data? = record.linkPreview
            let linkPreview: OWSLinkPreview? = try SDSDeserialization.optionalUnarchive(linkPreviewSerialized, name: "linkPreview")
            let messageStickerSerialized: Data? = record.messageSticker
            let messageSticker: MessageSticker? = try SDSDeserialization.optionalUnarchive(messageStickerSerialized, name: "messageSticker")
            let perMessageExpirationDurationSeconds: UInt32 = try SDSDeserialization.required(record.perMessageExpirationDurationSeconds, name: "perMessageExpirationDurationSeconds")
            let perMessageExpirationHasExpired: Bool = try SDSDeserialization.required(record.perMessageExpirationHasExpired, name: "perMessageExpirationHasExpired")
            let perMessageExpireStartedAt: UInt64 = try SDSDeserialization.required(record.perMessageExpireStartedAt, name: "perMessageExpireStartedAt")
            let quotedMessageSerialized: Data? = record.quotedMessage
            let quotedMessage: TSQuotedMessage? = try SDSDeserialization.optionalUnarchive(quotedMessageSerialized, name: "quotedMessage")
            let schemaVersion: UInt = try SDSDeserialization.required(record.schemaVersion, name: "schemaVersion")
            let errorMessageSchemaVersion: UInt = try SDSDeserialization.required(record.errorMessageSchemaVersion, name: "errorMessageSchemaVersion")
            guard let errorType: TSErrorMessageType = record.errorType else {
               throw SDSError.missingRequiredField
            }
            let read: Bool = try SDSDeserialization.required(record.read, name: "read")
            let recipientId: String? = record.recipientId
            let contactId: String = try SDSDeserialization.required(record.contactId, name: "contactId")

            return OWSUnknownContactBlockOfferMessage(uniqueId: uniqueId,
                                                      receivedAtTimestamp: receivedAtTimestamp,
                                                      sortId: sortId,
                                                      timestamp: timestamp,
                                                      uniqueThreadId: uniqueThreadId,
                                                      attachmentIds: attachmentIds,
                                                      body: body,
                                                      contactShare: contactShare,
                                                      expireStartedAt: expireStartedAt,
                                                      expiresAt: expiresAt,
                                                      expiresInSeconds: expiresInSeconds,
                                                      linkPreview: linkPreview,
                                                      messageSticker: messageSticker,
                                                      perMessageExpirationDurationSeconds: perMessageExpirationDurationSeconds,
                                                      perMessageExpirationHasExpired: perMessageExpirationHasExpired,
                                                      perMessageExpireStartedAt: perMessageExpireStartedAt,
                                                      quotedMessage: quotedMessage,
                                                      schemaVersion: schemaVersion,
                                                      errorMessageSchemaVersion: errorMessageSchemaVersion,
                                                      errorType: errorType,
                                                      read: read,
                                                      recipientId: recipientId,
                                                      contactId: contactId)

        case .unknownProtocolVersionMessage:

            let uniqueId: String = record.uniqueId
            let receivedAtTimestamp: UInt64 = record.receivedAtTimestamp
            let sortId: UInt64 = UInt64(recordId)
            let timestamp: UInt64 = record.timestamp
            let uniqueThreadId: String = record.threadUniqueId
            let attachmentIdsSerialized: Data? = record.attachmentIds
            let attachmentIds: [String] = try SDSDeserialization.unarchive(attachmentIdsSerialized, name: "attachmentIds")
            let body: String? = record.body
            let contactShareSerialized: Data? = record.contactShare
            let contactShare: OWSContact? = try SDSDeserialization.optionalUnarchive(contactShareSerialized, name: "contactShare")
            let expireStartedAt: UInt64 = try SDSDeserialization.required(record.expireStartedAt, name: "expireStartedAt")
            let expiresAt: UInt64 = try SDSDeserialization.required(record.expiresAt, name: "expiresAt")
            let expiresInSeconds: UInt32 = try SDSDeserialization.required(record.expiresInSeconds, name: "expiresInSeconds")
            let linkPreviewSerialized: Data? = record.linkPreview
            let linkPreview: OWSLinkPreview? = try SDSDeserialization.optionalUnarchive(linkPreviewSerialized, name: "linkPreview")
            let messageStickerSerialized: Data? = record.messageSticker
            let messageSticker: MessageSticker? = try SDSDeserialization.optionalUnarchive(messageStickerSerialized, name: "messageSticker")
            let perMessageExpirationDurationSeconds: UInt32 = try SDSDeserialization.required(record.perMessageExpirationDurationSeconds, name: "perMessageExpirationDurationSeconds")
            let perMessageExpirationHasExpired: Bool = try SDSDeserialization.required(record.perMessageExpirationHasExpired, name: "perMessageExpirationHasExpired")
            let perMessageExpireStartedAt: UInt64 = try SDSDeserialization.required(record.perMessageExpireStartedAt, name: "perMessageExpireStartedAt")
            let quotedMessageSerialized: Data? = record.quotedMessage
            let quotedMessage: TSQuotedMessage? = try SDSDeserialization.optionalUnarchive(quotedMessageSerialized, name: "quotedMessage")
            let schemaVersion: UInt = try SDSDeserialization.required(record.schemaVersion, name: "schemaVersion")
            let customMessage: String? = record.customMessage
            let infoMessageSchemaVersion: UInt = try SDSDeserialization.required(record.infoMessageSchemaVersion, name: "infoMessageSchemaVersion")
            guard let messageType: TSInfoMessageType = record.messageType else {
               throw SDSError.missingRequiredField
            }
            let read: Bool = try SDSDeserialization.required(record.read, name: "read")
            let unregisteredRecipientId: String? = record.unregisteredRecipientId
            let protocolVersion: UInt = try SDSDeserialization.required(record.protocolVersion, name: "protocolVersion")
            let senderId: String? = record.senderId

            return OWSUnknownProtocolVersionMessage(uniqueId: uniqueId,
                                                    receivedAtTimestamp: receivedAtTimestamp,
                                                    sortId: sortId,
                                                    timestamp: timestamp,
                                                    uniqueThreadId: uniqueThreadId,
                                                    attachmentIds: attachmentIds,
                                                    body: body,
                                                    contactShare: contactShare,
                                                    expireStartedAt: expireStartedAt,
                                                    expiresAt: expiresAt,
                                                    expiresInSeconds: expiresInSeconds,
                                                    linkPreview: linkPreview,
                                                    messageSticker: messageSticker,
                                                    perMessageExpirationDurationSeconds: perMessageExpirationDurationSeconds,
                                                    perMessageExpirationHasExpired: perMessageExpirationHasExpired,
                                                    perMessageExpireStartedAt: perMessageExpireStartedAt,
                                                    quotedMessage: quotedMessage,
                                                    schemaVersion: schemaVersion,
                                                    customMessage: customMessage,
                                                    infoMessageSchemaVersion: infoMessageSchemaVersion,
                                                    messageType: messageType,
                                                    read: read,
                                                    unregisteredRecipientId: unregisteredRecipientId,
                                                    protocolVersion: protocolVersion,
                                                    senderId: senderId)

        case .verificationStateChangeMessage:

            let uniqueId: String = record.uniqueId
            let receivedAtTimestamp: UInt64 = record.receivedAtTimestamp
            let sortId: UInt64 = UInt64(recordId)
            let timestamp: UInt64 = record.timestamp
            let uniqueThreadId: String = record.threadUniqueId
            let attachmentIdsSerialized: Data? = record.attachmentIds
            let attachmentIds: [String] = try SDSDeserialization.unarchive(attachmentIdsSerialized, name: "attachmentIds")
            let body: String? = record.body
            let contactShareSerialized: Data? = record.contactShare
            let contactShare: OWSContact? = try SDSDeserialization.optionalUnarchive(contactShareSerialized, name: "contactShare")
            let expireStartedAt: UInt64 = try SDSDeserialization.required(record.expireStartedAt, name: "expireStartedAt")
            let expiresAt: UInt64 = try SDSDeserialization.required(record.expiresAt, name: "expiresAt")
            let expiresInSeconds: UInt32 = try SDSDeserialization.required(record.expiresInSeconds, name: "expiresInSeconds")
            let linkPreviewSerialized: Data? = record.linkPreview
            let linkPreview: OWSLinkPreview? = try SDSDeserialization.optionalUnarchive(linkPreviewSerialized, name: "linkPreview")
            let messageStickerSerialized: Data? = record.messageSticker
            let messageSticker: MessageSticker? = try SDSDeserialization.optionalUnarchive(messageStickerSerialized, name: "messageSticker")
            let perMessageExpirationDurationSeconds: UInt32 = try SDSDeserialization.required(record.perMessageExpirationDurationSeconds, name: "perMessageExpirationDurationSeconds")
            let perMessageExpirationHasExpired: Bool = try SDSDeserialization.required(record.perMessageExpirationHasExpired, name: "perMessageExpirationHasExpired")
            let perMessageExpireStartedAt: UInt64 = try SDSDeserialization.required(record.perMessageExpireStartedAt, name: "perMessageExpireStartedAt")
            let quotedMessageSerialized: Data? = record.quotedMessage
            let quotedMessage: TSQuotedMessage? = try SDSDeserialization.optionalUnarchive(quotedMessageSerialized, name: "quotedMessage")
            let schemaVersion: UInt = try SDSDeserialization.required(record.schemaVersion, name: "schemaVersion")
            let customMessage: String? = record.customMessage
            let infoMessageSchemaVersion: UInt = try SDSDeserialization.required(record.infoMessageSchemaVersion, name: "infoMessageSchemaVersion")
            guard let messageType: TSInfoMessageType = record.messageType else {
               throw SDSError.missingRequiredField
            }
            let read: Bool = try SDSDeserialization.required(record.read, name: "read")
            let unregisteredRecipientId: String? = record.unregisteredRecipientId
            let isLocalChange: Bool = try SDSDeserialization.required(record.isLocalChange, name: "isLocalChange")
            let recipientId: String = try SDSDeserialization.required(record.recipientId, name: "recipientId")
            guard let verificationState: OWSVerificationState = record.verificationState else {
               throw SDSError.missingRequiredField
            }

            return OWSVerificationStateChangeMessage(uniqueId: uniqueId,
                                                     receivedAtTimestamp: receivedAtTimestamp,
                                                     sortId: sortId,
                                                     timestamp: timestamp,
                                                     uniqueThreadId: uniqueThreadId,
                                                     attachmentIds: attachmentIds,
                                                     body: body,
                                                     contactShare: contactShare,
                                                     expireStartedAt: expireStartedAt,
                                                     expiresAt: expiresAt,
                                                     expiresInSeconds: expiresInSeconds,
                                                     linkPreview: linkPreview,
                                                     messageSticker: messageSticker,
                                                     perMessageExpirationDurationSeconds: perMessageExpirationDurationSeconds,
                                                     perMessageExpirationHasExpired: perMessageExpirationHasExpired,
                                                     perMessageExpireStartedAt: perMessageExpireStartedAt,
                                                     quotedMessage: quotedMessage,
                                                     schemaVersion: schemaVersion,
                                                     customMessage: customMessage,
                                                     infoMessageSchemaVersion: infoMessageSchemaVersion,
                                                     messageType: messageType,
                                                     read: read,
                                                     unregisteredRecipientId: unregisteredRecipientId,
                                                     isLocalChange: isLocalChange,
                                                     recipientId: recipientId,
                                                     verificationState: verificationState)

        case .call:

            let uniqueId: String = record.uniqueId
            let receivedAtTimestamp: UInt64 = record.receivedAtTimestamp
            let sortId: UInt64 = UInt64(recordId)
            let timestamp: UInt64 = record.timestamp
            let uniqueThreadId: String = record.threadUniqueId
            let callSchemaVersion: UInt = try SDSDeserialization.required(record.callSchemaVersion, name: "callSchemaVersion")
            guard let callType: RPRecentCallType = record.callType else {
               throw SDSError.missingRequiredField
            }
            let read: Bool = try SDSDeserialization.required(record.read, name: "read")

            return TSCall(uniqueId: uniqueId,
                          receivedAtTimestamp: receivedAtTimestamp,
                          sortId: sortId,
                          timestamp: timestamp,
                          uniqueThreadId: uniqueThreadId,
                          callSchemaVersion: callSchemaVersion,
                          callType: callType,
                          read: read)

        case .errorMessage:

            let uniqueId: String = record.uniqueId
            let receivedAtTimestamp: UInt64 = record.receivedAtTimestamp
            let sortId: UInt64 = UInt64(recordId)
            let timestamp: UInt64 = record.timestamp
            let uniqueThreadId: String = record.threadUniqueId
            let attachmentIdsSerialized: Data? = record.attachmentIds
            let attachmentIds: [String] = try SDSDeserialization.unarchive(attachmentIdsSerialized, name: "attachmentIds")
            let body: String? = record.body
            let contactShareSerialized: Data? = record.contactShare
            let contactShare: OWSContact? = try SDSDeserialization.optionalUnarchive(contactShareSerialized, name: "contactShare")
            let expireStartedAt: UInt64 = try SDSDeserialization.required(record.expireStartedAt, name: "expireStartedAt")
            let expiresAt: UInt64 = try SDSDeserialization.required(record.expiresAt, name: "expiresAt")
            let expiresInSeconds: UInt32 = try SDSDeserialization.required(record.expiresInSeconds, name: "expiresInSeconds")
            let linkPreviewSerialized: Data? = record.linkPreview
            let linkPreview: OWSLinkPreview? = try SDSDeserialization.optionalUnarchive(linkPreviewSerialized, name: "linkPreview")
            let messageStickerSerialized: Data? = record.messageSticker
            let messageSticker: MessageSticker? = try SDSDeserialization.optionalUnarchive(messageStickerSerialized, name: "messageSticker")
            let perMessageExpirationDurationSeconds: UInt32 = try SDSDeserialization.required(record.perMessageExpirationDurationSeconds, name: "perMessageExpirationDurationSeconds")
            let perMessageExpirationHasExpired: Bool = try SDSDeserialization.required(record.perMessageExpirationHasExpired, name: "perMessageExpirationHasExpired")
            let perMessageExpireStartedAt: UInt64 = try SDSDeserialization.required(record.perMessageExpireStartedAt, name: "perMessageExpireStartedAt")
            let quotedMessageSerialized: Data? = record.quotedMessage
            let quotedMessage: TSQuotedMessage? = try SDSDeserialization.optionalUnarchive(quotedMessageSerialized, name: "quotedMessage")
            let schemaVersion: UInt = try SDSDeserialization.required(record.schemaVersion, name: "schemaVersion")
            let errorMessageSchemaVersion: UInt = try SDSDeserialization.required(record.errorMessageSchemaVersion, name: "errorMessageSchemaVersion")
            guard let errorType: TSErrorMessageType = record.errorType else {
               throw SDSError.missingRequiredField
            }
            let read: Bool = try SDSDeserialization.required(record.read, name: "read")
            let recipientId: String? = record.recipientId

            return TSErrorMessage(uniqueId: uniqueId,
                                  receivedAtTimestamp: receivedAtTimestamp,
                                  sortId: sortId,
                                  timestamp: timestamp,
                                  uniqueThreadId: uniqueThreadId,
                                  attachmentIds: attachmentIds,
                                  body: body,
                                  contactShare: contactShare,
                                  expireStartedAt: expireStartedAt,
                                  expiresAt: expiresAt,
                                  expiresInSeconds: expiresInSeconds,
                                  linkPreview: linkPreview,
                                  messageSticker: messageSticker,
                                  perMessageExpirationDurationSeconds: perMessageExpirationDurationSeconds,
                                  perMessageExpirationHasExpired: perMessageExpirationHasExpired,
                                  perMessageExpireStartedAt: perMessageExpireStartedAt,
                                  quotedMessage: quotedMessage,
                                  schemaVersion: schemaVersion,
                                  errorMessageSchemaVersion: errorMessageSchemaVersion,
                                  errorType: errorType,
                                  read: read,
                                  recipientId: recipientId)

        case .incomingMessage:

            let uniqueId: String = record.uniqueId
            let receivedAtTimestamp: UInt64 = record.receivedAtTimestamp
            let sortId: UInt64 = UInt64(recordId)
            let timestamp: UInt64 = record.timestamp
            let uniqueThreadId: String = record.threadUniqueId
            let attachmentIdsSerialized: Data? = record.attachmentIds
            let attachmentIds: [String] = try SDSDeserialization.unarchive(attachmentIdsSerialized, name: "attachmentIds")
            let body: String? = record.body
            let contactShareSerialized: Data? = record.contactShare
            let contactShare: OWSContact? = try SDSDeserialization.optionalUnarchive(contactShareSerialized, name: "contactShare")
            let expireStartedAt: UInt64 = try SDSDeserialization.required(record.expireStartedAt, name: "expireStartedAt")
            let expiresAt: UInt64 = try SDSDeserialization.required(record.expiresAt, name: "expiresAt")
            let expiresInSeconds: UInt32 = try SDSDeserialization.required(record.expiresInSeconds, name: "expiresInSeconds")
            let linkPreviewSerialized: Data? = record.linkPreview
            let linkPreview: OWSLinkPreview? = try SDSDeserialization.optionalUnarchive(linkPreviewSerialized, name: "linkPreview")
            let messageStickerSerialized: Data? = record.messageSticker
            let messageSticker: MessageSticker? = try SDSDeserialization.optionalUnarchive(messageStickerSerialized, name: "messageSticker")
            let perMessageExpirationDurationSeconds: UInt32 = try SDSDeserialization.required(record.perMessageExpirationDurationSeconds, name: "perMessageExpirationDurationSeconds")
            let perMessageExpirationHasExpired: Bool = try SDSDeserialization.required(record.perMessageExpirationHasExpired, name: "perMessageExpirationHasExpired")
            let perMessageExpireStartedAt: UInt64 = try SDSDeserialization.required(record.perMessageExpireStartedAt, name: "perMessageExpireStartedAt")
            let quotedMessageSerialized: Data? = record.quotedMessage
            let quotedMessage: TSQuotedMessage? = try SDSDeserialization.optionalUnarchive(quotedMessageSerialized, name: "quotedMessage")
            let schemaVersion: UInt = try SDSDeserialization.required(record.schemaVersion, name: "schemaVersion")
            let authorId: String = try SDSDeserialization.required(record.authorId, name: "authorId")
            let read: Bool = try SDSDeserialization.required(record.read, name: "read")
            let serverTimestamp: NSNumber? = SDSDeserialization.optionalNumericAsNSNumber(record.serverTimestamp, name: "serverTimestamp", conversion: { NSNumber(value: $0) })
            let sourceDeviceId: UInt32 = try SDSDeserialization.required(record.sourceDeviceId, name: "sourceDeviceId")
            let wasReceivedByUD: Bool = try SDSDeserialization.required(record.wasReceivedByUD, name: "wasReceivedByUD")

            return TSIncomingMessage(uniqueId: uniqueId,
                                     receivedAtTimestamp: receivedAtTimestamp,
                                     sortId: sortId,
                                     timestamp: timestamp,
                                     uniqueThreadId: uniqueThreadId,
                                     attachmentIds: attachmentIds,
                                     body: body,
                                     contactShare: contactShare,
                                     expireStartedAt: expireStartedAt,
                                     expiresAt: expiresAt,
                                     expiresInSeconds: expiresInSeconds,
                                     linkPreview: linkPreview,
                                     messageSticker: messageSticker,
                                     perMessageExpirationDurationSeconds: perMessageExpirationDurationSeconds,
                                     perMessageExpirationHasExpired: perMessageExpirationHasExpired,
                                     perMessageExpireStartedAt: perMessageExpireStartedAt,
                                     quotedMessage: quotedMessage,
                                     schemaVersion: schemaVersion,
                                     authorId: authorId,
                                     read: read,
                                     serverTimestamp: serverTimestamp,
                                     sourceDeviceId: sourceDeviceId,
                                     wasReceivedByUD: wasReceivedByUD)

        case .infoMessage:

            let uniqueId: String = record.uniqueId
            let receivedAtTimestamp: UInt64 = record.receivedAtTimestamp
            let sortId: UInt64 = UInt64(recordId)
            let timestamp: UInt64 = record.timestamp
            let uniqueThreadId: String = record.threadUniqueId
            let attachmentIdsSerialized: Data? = record.attachmentIds
            let attachmentIds: [String] = try SDSDeserialization.unarchive(attachmentIdsSerialized, name: "attachmentIds")
            let body: String? = record.body
            let contactShareSerialized: Data? = record.contactShare
            let contactShare: OWSContact? = try SDSDeserialization.optionalUnarchive(contactShareSerialized, name: "contactShare")
            let expireStartedAt: UInt64 = try SDSDeserialization.required(record.expireStartedAt, name: "expireStartedAt")
            let expiresAt: UInt64 = try SDSDeserialization.required(record.expiresAt, name: "expiresAt")
            let expiresInSeconds: UInt32 = try SDSDeserialization.required(record.expiresInSeconds, name: "expiresInSeconds")
            let linkPreviewSerialized: Data? = record.linkPreview
            let linkPreview: OWSLinkPreview? = try SDSDeserialization.optionalUnarchive(linkPreviewSerialized, name: "linkPreview")
            let messageStickerSerialized: Data? = record.messageSticker
            let messageSticker: MessageSticker? = try SDSDeserialization.optionalUnarchive(messageStickerSerialized, name: "messageSticker")
            let perMessageExpirationDurationSeconds: UInt32 = try SDSDeserialization.required(record.perMessageExpirationDurationSeconds, name: "perMessageExpirationDurationSeconds")
            let perMessageExpirationHasExpired: Bool = try SDSDeserialization.required(record.perMessageExpirationHasExpired, name: "perMessageExpirationHasExpired")
            let perMessageExpireStartedAt: UInt64 = try SDSDeserialization.required(record.perMessageExpireStartedAt, name: "perMessageExpireStartedAt")
            let quotedMessageSerialized: Data? = record.quotedMessage
            let quotedMessage: TSQuotedMessage? = try SDSDeserialization.optionalUnarchive(quotedMessageSerialized, name: "quotedMessage")
            let schemaVersion: UInt = try SDSDeserialization.required(record.schemaVersion, name: "schemaVersion")
            let customMessage: String? = record.customMessage
            let infoMessageSchemaVersion: UInt = try SDSDeserialization.required(record.infoMessageSchemaVersion, name: "infoMessageSchemaVersion")
            guard let messageType: TSInfoMessageType = record.messageType else {
               throw SDSError.missingRequiredField
            }
            let read: Bool = try SDSDeserialization.required(record.read, name: "read")
            let unregisteredRecipientId: String? = record.unregisteredRecipientId

            return TSInfoMessage(uniqueId: uniqueId,
                                 receivedAtTimestamp: receivedAtTimestamp,
                                 sortId: sortId,
                                 timestamp: timestamp,
                                 uniqueThreadId: uniqueThreadId,
                                 attachmentIds: attachmentIds,
                                 body: body,
                                 contactShare: contactShare,
                                 expireStartedAt: expireStartedAt,
                                 expiresAt: expiresAt,
                                 expiresInSeconds: expiresInSeconds,
                                 linkPreview: linkPreview,
                                 messageSticker: messageSticker,
                                 perMessageExpirationDurationSeconds: perMessageExpirationDurationSeconds,
                                 perMessageExpirationHasExpired: perMessageExpirationHasExpired,
                                 perMessageExpireStartedAt: perMessageExpireStartedAt,
                                 quotedMessage: quotedMessage,
                                 schemaVersion: schemaVersion,
                                 customMessage: customMessage,
                                 infoMessageSchemaVersion: infoMessageSchemaVersion,
                                 messageType: messageType,
                                 read: read,
                                 unregisteredRecipientId: unregisteredRecipientId)

        case .interaction:

            let uniqueId: String = record.uniqueId
            let receivedAtTimestamp: UInt64 = record.receivedAtTimestamp
            let sortId: UInt64 = UInt64(recordId)
            let timestamp: UInt64 = record.timestamp
            let uniqueThreadId: String = record.threadUniqueId

            return TSInteraction(uniqueId: uniqueId,
                                 receivedAtTimestamp: receivedAtTimestamp,
                                 sortId: sortId,
                                 timestamp: timestamp,
                                 uniqueThreadId: uniqueThreadId)

        case .invalidIdentityKeyErrorMessage:

            let uniqueId: String = record.uniqueId
            let receivedAtTimestamp: UInt64 = record.receivedAtTimestamp
            let sortId: UInt64 = UInt64(recordId)
            let timestamp: UInt64 = record.timestamp
            let uniqueThreadId: String = record.threadUniqueId
            let attachmentIdsSerialized: Data? = record.attachmentIds
            let attachmentIds: [String] = try SDSDeserialization.unarchive(attachmentIdsSerialized, name: "attachmentIds")
            let body: String? = record.body
            let contactShareSerialized: Data? = record.contactShare
            let contactShare: OWSContact? = try SDSDeserialization.optionalUnarchive(contactShareSerialized, name: "contactShare")
            let expireStartedAt: UInt64 = try SDSDeserialization.required(record.expireStartedAt, name: "expireStartedAt")
            let expiresAt: UInt64 = try SDSDeserialization.required(record.expiresAt, name: "expiresAt")
            let expiresInSeconds: UInt32 = try SDSDeserialization.required(record.expiresInSeconds, name: "expiresInSeconds")
            let linkPreviewSerialized: Data? = record.linkPreview
            let linkPreview: OWSLinkPreview? = try SDSDeserialization.optionalUnarchive(linkPreviewSerialized, name: "linkPreview")
            let messageStickerSerialized: Data? = record.messageSticker
            let messageSticker: MessageSticker? = try SDSDeserialization.optionalUnarchive(messageStickerSerialized, name: "messageSticker")
            let perMessageExpirationDurationSeconds: UInt32 = try SDSDeserialization.required(record.perMessageExpirationDurationSeconds, name: "perMessageExpirationDurationSeconds")
            let perMessageExpirationHasExpired: Bool = try SDSDeserialization.required(record.perMessageExpirationHasExpired, name: "perMessageExpirationHasExpired")
            let perMessageExpireStartedAt: UInt64 = try SDSDeserialization.required(record.perMessageExpireStartedAt, name: "perMessageExpireStartedAt")
            let quotedMessageSerialized: Data? = record.quotedMessage
            let quotedMessage: TSQuotedMessage? = try SDSDeserialization.optionalUnarchive(quotedMessageSerialized, name: "quotedMessage")
            let schemaVersion: UInt = try SDSDeserialization.required(record.schemaVersion, name: "schemaVersion")
            let errorMessageSchemaVersion: UInt = try SDSDeserialization.required(record.errorMessageSchemaVersion, name: "errorMessageSchemaVersion")
            guard let errorType: TSErrorMessageType = record.errorType else {
               throw SDSError.missingRequiredField
            }
            let read: Bool = try SDSDeserialization.required(record.read, name: "read")
            let recipientId: String? = record.recipientId

            return TSInvalidIdentityKeyErrorMessage(uniqueId: uniqueId,
                                                    receivedAtTimestamp: receivedAtTimestamp,
                                                    sortId: sortId,
                                                    timestamp: timestamp,
                                                    uniqueThreadId: uniqueThreadId,
                                                    attachmentIds: attachmentIds,
                                                    body: body,
                                                    contactShare: contactShare,
                                                    expireStartedAt: expireStartedAt,
                                                    expiresAt: expiresAt,
                                                    expiresInSeconds: expiresInSeconds,
                                                    linkPreview: linkPreview,
                                                    messageSticker: messageSticker,
                                                    perMessageExpirationDurationSeconds: perMessageExpirationDurationSeconds,
                                                    perMessageExpirationHasExpired: perMessageExpirationHasExpired,
                                                    perMessageExpireStartedAt: perMessageExpireStartedAt,
                                                    quotedMessage: quotedMessage,
                                                    schemaVersion: schemaVersion,
                                                    errorMessageSchemaVersion: errorMessageSchemaVersion,
                                                    errorType: errorType,
                                                    read: read,
                                                    recipientId: recipientId)

        case .invalidIdentityKeyReceivingErrorMessage:

            let uniqueId: String = record.uniqueId
            let receivedAtTimestamp: UInt64 = record.receivedAtTimestamp
            let sortId: UInt64 = UInt64(recordId)
            let timestamp: UInt64 = record.timestamp
            let uniqueThreadId: String = record.threadUniqueId
            let attachmentIdsSerialized: Data? = record.attachmentIds
            let attachmentIds: [String] = try SDSDeserialization.unarchive(attachmentIdsSerialized, name: "attachmentIds")
            let body: String? = record.body
            let contactShareSerialized: Data? = record.contactShare
            let contactShare: OWSContact? = try SDSDeserialization.optionalUnarchive(contactShareSerialized, name: "contactShare")
            let expireStartedAt: UInt64 = try SDSDeserialization.required(record.expireStartedAt, name: "expireStartedAt")
            let expiresAt: UInt64 = try SDSDeserialization.required(record.expiresAt, name: "expiresAt")
            let expiresInSeconds: UInt32 = try SDSDeserialization.required(record.expiresInSeconds, name: "expiresInSeconds")
            let linkPreviewSerialized: Data? = record.linkPreview
            let linkPreview: OWSLinkPreview? = try SDSDeserialization.optionalUnarchive(linkPreviewSerialized, name: "linkPreview")
            let messageStickerSerialized: Data? = record.messageSticker
            let messageSticker: MessageSticker? = try SDSDeserialization.optionalUnarchive(messageStickerSerialized, name: "messageSticker")
            let perMessageExpirationDurationSeconds: UInt32 = try SDSDeserialization.required(record.perMessageExpirationDurationSeconds, name: "perMessageExpirationDurationSeconds")
            let perMessageExpirationHasExpired: Bool = try SDSDeserialization.required(record.perMessageExpirationHasExpired, name: "perMessageExpirationHasExpired")
            let perMessageExpireStartedAt: UInt64 = try SDSDeserialization.required(record.perMessageExpireStartedAt, name: "perMessageExpireStartedAt")
            let quotedMessageSerialized: Data? = record.quotedMessage
            let quotedMessage: TSQuotedMessage? = try SDSDeserialization.optionalUnarchive(quotedMessageSerialized, name: "quotedMessage")
            let schemaVersion: UInt = try SDSDeserialization.required(record.schemaVersion, name: "schemaVersion")
            let errorMessageSchemaVersion: UInt = try SDSDeserialization.required(record.errorMessageSchemaVersion, name: "errorMessageSchemaVersion")
            guard let errorType: TSErrorMessageType = record.errorType else {
               throw SDSError.missingRequiredField
            }
            let read: Bool = try SDSDeserialization.required(record.read, name: "read")
            let recipientId: String? = record.recipientId
            let authorId: String = try SDSDeserialization.required(record.authorId, name: "authorId")
            let envelopeData: Data? = SDSDeserialization.optionalData(record.envelopeData, name: "envelopeData")

            return TSInvalidIdentityKeyReceivingErrorMessage(uniqueId: uniqueId,
                                                             receivedAtTimestamp: receivedAtTimestamp,
                                                             sortId: sortId,
                                                             timestamp: timestamp,
                                                             uniqueThreadId: uniqueThreadId,
                                                             attachmentIds: attachmentIds,
                                                             body: body,
                                                             contactShare: contactShare,
                                                             expireStartedAt: expireStartedAt,
                                                             expiresAt: expiresAt,
                                                             expiresInSeconds: expiresInSeconds,
                                                             linkPreview: linkPreview,
                                                             messageSticker: messageSticker,
                                                             perMessageExpirationDurationSeconds: perMessageExpirationDurationSeconds,
                                                             perMessageExpirationHasExpired: perMessageExpirationHasExpired,
                                                             perMessageExpireStartedAt: perMessageExpireStartedAt,
                                                             quotedMessage: quotedMessage,
                                                             schemaVersion: schemaVersion,
                                                             errorMessageSchemaVersion: errorMessageSchemaVersion,
                                                             errorType: errorType,
                                                             read: read,
                                                             recipientId: recipientId,
                                                             authorId: authorId,
                                                             envelopeData: envelopeData)

        case .invalidIdentityKeySendingErrorMessage:

            let uniqueId: String = record.uniqueId
            let receivedAtTimestamp: UInt64 = record.receivedAtTimestamp
            let sortId: UInt64 = UInt64(recordId)
            let timestamp: UInt64 = record.timestamp
            let uniqueThreadId: String = record.threadUniqueId
            let attachmentIdsSerialized: Data? = record.attachmentIds
            let attachmentIds: [String] = try SDSDeserialization.unarchive(attachmentIdsSerialized, name: "attachmentIds")
            let body: String? = record.body
            let contactShareSerialized: Data? = record.contactShare
            let contactShare: OWSContact? = try SDSDeserialization.optionalUnarchive(contactShareSerialized, name: "contactShare")
            let expireStartedAt: UInt64 = try SDSDeserialization.required(record.expireStartedAt, name: "expireStartedAt")
            let expiresAt: UInt64 = try SDSDeserialization.required(record.expiresAt, name: "expiresAt")
            let expiresInSeconds: UInt32 = try SDSDeserialization.required(record.expiresInSeconds, name: "expiresInSeconds")
            let linkPreviewSerialized: Data? = record.linkPreview
            let linkPreview: OWSLinkPreview? = try SDSDeserialization.optionalUnarchive(linkPreviewSerialized, name: "linkPreview")
            let messageStickerSerialized: Data? = record.messageSticker
            let messageSticker: MessageSticker? = try SDSDeserialization.optionalUnarchive(messageStickerSerialized, name: "messageSticker")
            let perMessageExpirationDurationSeconds: UInt32 = try SDSDeserialization.required(record.perMessageExpirationDurationSeconds, name: "perMessageExpirationDurationSeconds")
            let perMessageExpirationHasExpired: Bool = try SDSDeserialization.required(record.perMessageExpirationHasExpired, name: "perMessageExpirationHasExpired")
            let perMessageExpireStartedAt: UInt64 = try SDSDeserialization.required(record.perMessageExpireStartedAt, name: "perMessageExpireStartedAt")
            let quotedMessageSerialized: Data? = record.quotedMessage
            let quotedMessage: TSQuotedMessage? = try SDSDeserialization.optionalUnarchive(quotedMessageSerialized, name: "quotedMessage")
            let schemaVersion: UInt = try SDSDeserialization.required(record.schemaVersion, name: "schemaVersion")
            let errorMessageSchemaVersion: UInt = try SDSDeserialization.required(record.errorMessageSchemaVersion, name: "errorMessageSchemaVersion")
            guard let errorType: TSErrorMessageType = record.errorType else {
               throw SDSError.missingRequiredField
            }
            let read: Bool = try SDSDeserialization.required(record.read, name: "read")
            let recipientId: String? = record.recipientId
            let messageId: String = try SDSDeserialization.required(record.messageId, name: "messageId")
            let preKeyBundleSerialized: Data? = record.preKeyBundle
            let preKeyBundle: PreKeyBundle = try SDSDeserialization.unarchive(preKeyBundleSerialized, name: "preKeyBundle")

            return TSInvalidIdentityKeySendingErrorMessage(uniqueId: uniqueId,
                                                           receivedAtTimestamp: receivedAtTimestamp,
                                                           sortId: sortId,
                                                           timestamp: timestamp,
                                                           uniqueThreadId: uniqueThreadId,
                                                           attachmentIds: attachmentIds,
                                                           body: body,
                                                           contactShare: contactShare,
                                                           expireStartedAt: expireStartedAt,
                                                           expiresAt: expiresAt,
                                                           expiresInSeconds: expiresInSeconds,
                                                           linkPreview: linkPreview,
                                                           messageSticker: messageSticker,
                                                           perMessageExpirationDurationSeconds: perMessageExpirationDurationSeconds,
                                                           perMessageExpirationHasExpired: perMessageExpirationHasExpired,
                                                           perMessageExpireStartedAt: perMessageExpireStartedAt,
                                                           quotedMessage: quotedMessage,
                                                           schemaVersion: schemaVersion,
                                                           errorMessageSchemaVersion: errorMessageSchemaVersion,
                                                           errorType: errorType,
                                                           read: read,
                                                           recipientId: recipientId,
                                                           messageId: messageId,
                                                           preKeyBundle: preKeyBundle)

        case .message:

            let uniqueId: String = record.uniqueId
            let receivedAtTimestamp: UInt64 = record.receivedAtTimestamp
            let sortId: UInt64 = UInt64(recordId)
            let timestamp: UInt64 = record.timestamp
            let uniqueThreadId: String = record.threadUniqueId
            let attachmentIdsSerialized: Data? = record.attachmentIds
            let attachmentIds: [String] = try SDSDeserialization.unarchive(attachmentIdsSerialized, name: "attachmentIds")
            let body: String? = record.body
            let contactShareSerialized: Data? = record.contactShare
            let contactShare: OWSContact? = try SDSDeserialization.optionalUnarchive(contactShareSerialized, name: "contactShare")
            let expireStartedAt: UInt64 = try SDSDeserialization.required(record.expireStartedAt, name: "expireStartedAt")
            let expiresAt: UInt64 = try SDSDeserialization.required(record.expiresAt, name: "expiresAt")
            let expiresInSeconds: UInt32 = try SDSDeserialization.required(record.expiresInSeconds, name: "expiresInSeconds")
            let linkPreviewSerialized: Data? = record.linkPreview
            let linkPreview: OWSLinkPreview? = try SDSDeserialization.optionalUnarchive(linkPreviewSerialized, name: "linkPreview")
            let messageStickerSerialized: Data? = record.messageSticker
            let messageSticker: MessageSticker? = try SDSDeserialization.optionalUnarchive(messageStickerSerialized, name: "messageSticker")
            let perMessageExpirationDurationSeconds: UInt32 = try SDSDeserialization.required(record.perMessageExpirationDurationSeconds, name: "perMessageExpirationDurationSeconds")
            let perMessageExpirationHasExpired: Bool = try SDSDeserialization.required(record.perMessageExpirationHasExpired, name: "perMessageExpirationHasExpired")
            let perMessageExpireStartedAt: UInt64 = try SDSDeserialization.required(record.perMessageExpireStartedAt, name: "perMessageExpireStartedAt")
            let quotedMessageSerialized: Data? = record.quotedMessage
            let quotedMessage: TSQuotedMessage? = try SDSDeserialization.optionalUnarchive(quotedMessageSerialized, name: "quotedMessage")
            let schemaVersion: UInt = try SDSDeserialization.required(record.schemaVersion, name: "schemaVersion")

            return TSMessage(uniqueId: uniqueId,
                             receivedAtTimestamp: receivedAtTimestamp,
                             sortId: sortId,
                             timestamp: timestamp,
                             uniqueThreadId: uniqueThreadId,
                             attachmentIds: attachmentIds,
                             body: body,
                             contactShare: contactShare,
                             expireStartedAt: expireStartedAt,
                             expiresAt: expiresAt,
                             expiresInSeconds: expiresInSeconds,
                             linkPreview: linkPreview,
                             messageSticker: messageSticker,
                             perMessageExpirationDurationSeconds: perMessageExpirationDurationSeconds,
                             perMessageExpirationHasExpired: perMessageExpirationHasExpired,
                             perMessageExpireStartedAt: perMessageExpireStartedAt,
                             quotedMessage: quotedMessage,
                             schemaVersion: schemaVersion)

        case .outgoingMessage:

            let uniqueId: String = record.uniqueId
            let receivedAtTimestamp: UInt64 = record.receivedAtTimestamp
            let sortId: UInt64 = UInt64(recordId)
            let timestamp: UInt64 = record.timestamp
            let uniqueThreadId: String = record.threadUniqueId
            let attachmentIdsSerialized: Data? = record.attachmentIds
            let attachmentIds: [String] = try SDSDeserialization.unarchive(attachmentIdsSerialized, name: "attachmentIds")
            let body: String? = record.body
            let contactShareSerialized: Data? = record.contactShare
            let contactShare: OWSContact? = try SDSDeserialization.optionalUnarchive(contactShareSerialized, name: "contactShare")
            let expireStartedAt: UInt64 = try SDSDeserialization.required(record.expireStartedAt, name: "expireStartedAt")
            let expiresAt: UInt64 = try SDSDeserialization.required(record.expiresAt, name: "expiresAt")
            let expiresInSeconds: UInt32 = try SDSDeserialization.required(record.expiresInSeconds, name: "expiresInSeconds")
            let linkPreviewSerialized: Data? = record.linkPreview
            let linkPreview: OWSLinkPreview? = try SDSDeserialization.optionalUnarchive(linkPreviewSerialized, name: "linkPreview")
            let messageStickerSerialized: Data? = record.messageSticker
            let messageSticker: MessageSticker? = try SDSDeserialization.optionalUnarchive(messageStickerSerialized, name: "messageSticker")
            let perMessageExpirationDurationSeconds: UInt32 = try SDSDeserialization.required(record.perMessageExpirationDurationSeconds, name: "perMessageExpirationDurationSeconds")
            let perMessageExpirationHasExpired: Bool = try SDSDeserialization.required(record.perMessageExpirationHasExpired, name: "perMessageExpirationHasExpired")
            let perMessageExpireStartedAt: UInt64 = try SDSDeserialization.required(record.perMessageExpireStartedAt, name: "perMessageExpireStartedAt")
            let quotedMessageSerialized: Data? = record.quotedMessage
            let quotedMessage: TSQuotedMessage? = try SDSDeserialization.optionalUnarchive(quotedMessageSerialized, name: "quotedMessage")
            let schemaVersion: UInt = try SDSDeserialization.required(record.schemaVersion, name: "schemaVersion")
            let attachmentFilenameMapSerialized: Data? = record.attachmentFilenameMap
            let attachmentFilenameMap: [String: String] = try SDSDeserialization.unarchive(attachmentFilenameMapSerialized, name: "attachmentFilenameMap")
            let customMessage: String? = record.customMessage
            guard let groupMetaMessage: TSGroupMetaMessage = record.groupMetaMessage else {
               throw SDSError.missingRequiredField
            }
            let hasLegacyMessageState: Bool = try SDSDeserialization.required(record.hasLegacyMessageState, name: "hasLegacyMessageState")
            let hasSyncedTranscript: Bool = try SDSDeserialization.required(record.hasSyncedTranscript, name: "hasSyncedTranscript")
            let isFromLinkedDevice: Bool = try SDSDeserialization.required(record.isFromLinkedDevice, name: "isFromLinkedDevice")
            let isVoiceMessage: Bool = try SDSDeserialization.required(record.isVoiceMessage, name: "isVoiceMessage")
            guard let legacyMessageState: TSOutgoingMessageState = record.legacyMessageState else {
               throw SDSError.missingRequiredField
            }
            let legacyWasDelivered: Bool = try SDSDeserialization.required(record.legacyWasDelivered, name: "legacyWasDelivered")
            let mostRecentFailureText: String? = record.mostRecentFailureText
            let recipientStateMapSerialized: Data? = record.recipientStateMap
            let recipientStateMap: [String: TSOutgoingMessageRecipientState]? = try SDSDeserialization.optionalUnarchive(recipientStateMapSerialized, name: "recipientStateMap")

            return TSOutgoingMessage(uniqueId: uniqueId,
                                     receivedAtTimestamp: receivedAtTimestamp,
                                     sortId: sortId,
                                     timestamp: timestamp,
                                     uniqueThreadId: uniqueThreadId,
                                     attachmentIds: attachmentIds,
                                     body: body,
                                     contactShare: contactShare,
                                     expireStartedAt: expireStartedAt,
                                     expiresAt: expiresAt,
                                     expiresInSeconds: expiresInSeconds,
                                     linkPreview: linkPreview,
                                     messageSticker: messageSticker,
                                     perMessageExpirationDurationSeconds: perMessageExpirationDurationSeconds,
                                     perMessageExpirationHasExpired: perMessageExpirationHasExpired,
                                     perMessageExpireStartedAt: perMessageExpireStartedAt,
                                     quotedMessage: quotedMessage,
                                     schemaVersion: schemaVersion,
                                     attachmentFilenameMap: attachmentFilenameMap,
                                     customMessage: customMessage,
                                     groupMetaMessage: groupMetaMessage,
                                     hasLegacyMessageState: hasLegacyMessageState,
                                     hasSyncedTranscript: hasSyncedTranscript,
                                     isFromLinkedDevice: isFromLinkedDevice,
                                     isVoiceMessage: isVoiceMessage,
                                     legacyMessageState: legacyMessageState,
                                     legacyWasDelivered: legacyWasDelivered,
                                     mostRecentFailureText: mostRecentFailureText,
                                     recipientStateMap: recipientStateMap)

        case .unreadIndicatorInteraction:

            let uniqueId: String = record.uniqueId
            let receivedAtTimestamp: UInt64 = record.receivedAtTimestamp
            let sortId: UInt64 = UInt64(recordId)
            let timestamp: UInt64 = record.timestamp
            let uniqueThreadId: String = record.threadUniqueId

            return TSUnreadIndicatorInteraction(uniqueId: uniqueId,
                                                receivedAtTimestamp: receivedAtTimestamp,
                                                sortId: sortId,
                                                timestamp: timestamp,
                                                uniqueThreadId: uniqueThreadId)

        default:
            owsFailDebug("Unexpected record type: \(record.recordType)")
            throw SDSError.invalidValue
        }
    }
}

// MARK: - SDSModel

extension TSInteraction: SDSModel {
    public var serializer: SDSSerializer {
        // Any subclass can be cast to it's superclass,
        // so the order of this switch statement matters.
        // We need to do a "depth first" search by type.
        switch self {
        case let model as TSUnreadIndicatorInteraction:
            assert(type(of: model) == TSUnreadIndicatorInteraction.self)
            return TSUnreadIndicatorInteractionSerializer(model: model)
        case let model as TSOutgoingMessage:
            assert(type(of: model) == TSOutgoingMessage.self)
            return TSOutgoingMessageSerializer(model: model)
        case let model as OWSVerificationStateChangeMessage:
            assert(type(of: model) == OWSVerificationStateChangeMessage.self)
            return OWSVerificationStateChangeMessageSerializer(model: model)
        case let model as OWSUnknownProtocolVersionMessage:
            assert(type(of: model) == OWSUnknownProtocolVersionMessage.self)
            return OWSUnknownProtocolVersionMessageSerializer(model: model)
        case let model as OWSDisappearingConfigurationUpdateInfoMessage:
            assert(type(of: model) == OWSDisappearingConfigurationUpdateInfoMessage.self)
            return OWSDisappearingConfigurationUpdateInfoMessageSerializer(model: model)
        case let model as OWSAddToProfileWhitelistOfferMessage:
            assert(type(of: model) == OWSAddToProfileWhitelistOfferMessage.self)
            return OWSAddToProfileWhitelistOfferMessageSerializer(model: model)
        case let model as OWSAddToContactsOfferMessage:
            assert(type(of: model) == OWSAddToContactsOfferMessage.self)
            return OWSAddToContactsOfferMessageSerializer(model: model)
        case let model as TSInfoMessage:
            assert(type(of: model) == TSInfoMessage.self)
            return TSInfoMessageSerializer(model: model)
        case let model as TSIncomingMessage:
            assert(type(of: model) == TSIncomingMessage.self)
            return TSIncomingMessageSerializer(model: model)
        case let model as TSInvalidIdentityKeySendingErrorMessage:
            assert(type(of: model) == TSInvalidIdentityKeySendingErrorMessage.self)
            return TSInvalidIdentityKeySendingErrorMessageSerializer(model: model)
        case let model as TSInvalidIdentityKeyReceivingErrorMessage:
            assert(type(of: model) == TSInvalidIdentityKeyReceivingErrorMessage.self)
            return TSInvalidIdentityKeyReceivingErrorMessageSerializer(model: model)
        case let model as TSInvalidIdentityKeyErrorMessage:
            assert(type(of: model) == TSInvalidIdentityKeyErrorMessage.self)
            return TSInvalidIdentityKeyErrorMessageSerializer(model: model)
        case let model as OWSUnknownContactBlockOfferMessage:
            assert(type(of: model) == OWSUnknownContactBlockOfferMessage.self)
            return OWSUnknownContactBlockOfferMessageSerializer(model: model)
        case let model as TSErrorMessage:
            assert(type(of: model) == TSErrorMessage.self)
            return TSErrorMessageSerializer(model: model)
        case let model as TSMessage:
            assert(type(of: model) == TSMessage.self)
            return TSMessageSerializer(model: model)
        case let model as TSCall:
            assert(type(of: model) == TSCall.self)
            return TSCallSerializer(model: model)
        case let model as OWSContactOffersInteraction:
            assert(type(of: model) == OWSContactOffersInteraction.self)
            return OWSContactOffersInteractionSerializer(model: model)
        default:
            return TSInteractionSerializer(model: self)
        }
    }

    public func asRecord() throws -> SDSRecord {
        return try serializer.asRecord()
    }
}

// MARK: - Table Metadata

extension TSInteractionSerializer {

    // This defines all of the columns used in the table
    // where this model (and any subclasses) are persisted.
    static let recordTypeColumn = SDSColumnMetadata(columnName: "recordType", columnType: .int, columnIndex: 0)
    static let idColumn = SDSColumnMetadata(columnName: "id", columnType: .primaryKey, columnIndex: 1)
    static let uniqueIdColumn = SDSColumnMetadata(columnName: "uniqueId", columnType: .unicodeString, columnIndex: 2)
    // Base class properties
    static let receivedAtTimestampColumn = SDSColumnMetadata(columnName: "receivedAtTimestamp", columnType: .int64, columnIndex: 3)
    static let timestampColumn = SDSColumnMetadata(columnName: "timestamp", columnType: .int64, columnIndex: 4)
    static let uniqueThreadIdColumn = SDSColumnMetadata(columnName: "uniqueThreadId", columnType: .unicodeString, columnIndex: 5)
    // Subclass properties
    static let attachmentFilenameMapColumn = SDSColumnMetadata(columnName: "attachmentFilenameMap", columnType: .blob, isOptional: true, columnIndex: 6)
    static let attachmentIdsColumn = SDSColumnMetadata(columnName: "attachmentIds", columnType: .blob, isOptional: true, columnIndex: 7)
    static let authorIdColumn = SDSColumnMetadata(columnName: "authorId", columnType: .unicodeString, isOptional: true, columnIndex: 8)
    static let beforeInteractionIdColumn = SDSColumnMetadata(columnName: "beforeInteractionId", columnType: .unicodeString, isOptional: true, columnIndex: 9)
    static let bodyColumn = SDSColumnMetadata(columnName: "body", columnType: .unicodeString, isOptional: true, columnIndex: 10)
    static let callSchemaVersionColumn = SDSColumnMetadata(columnName: "callSchemaVersion", columnType: .int64, isOptional: true, columnIndex: 11)
    static let callTypeColumn = SDSColumnMetadata(columnName: "callType", columnType: .int, isOptional: true, columnIndex: 12)
    static let configurationDurationSecondsColumn = SDSColumnMetadata(columnName: "configurationDurationSeconds", columnType: .int64, isOptional: true, columnIndex: 13)
    static let configurationIsEnabledColumn = SDSColumnMetadata(columnName: "configurationIsEnabled", columnType: .int, isOptional: true, columnIndex: 14)
    static let contactIdColumn = SDSColumnMetadata(columnName: "contactId", columnType: .unicodeString, isOptional: true, columnIndex: 15)
    static let contactShareColumn = SDSColumnMetadata(columnName: "contactShare", columnType: .blob, isOptional: true, columnIndex: 16)
    static let createdByRemoteNameColumn = SDSColumnMetadata(columnName: "createdByRemoteName", columnType: .unicodeString, isOptional: true, columnIndex: 17)
    static let createdInExistingGroupColumn = SDSColumnMetadata(columnName: "createdInExistingGroup", columnType: .int, isOptional: true, columnIndex: 18)
    static let customMessageColumn = SDSColumnMetadata(columnName: "customMessage", columnType: .unicodeString, isOptional: true, columnIndex: 19)
    static let envelopeDataColumn = SDSColumnMetadata(columnName: "envelopeData", columnType: .blob, isOptional: true, columnIndex: 20)
    static let errorMessageSchemaVersionColumn = SDSColumnMetadata(columnName: "errorMessageSchemaVersion", columnType: .int64, isOptional: true, columnIndex: 21)
    static let errorTypeColumn = SDSColumnMetadata(columnName: "errorType", columnType: .int, isOptional: true, columnIndex: 22)
    static let expireStartedAtColumn = SDSColumnMetadata(columnName: "expireStartedAt", columnType: .int64, isOptional: true, columnIndex: 23)
    static let expiresAtColumn = SDSColumnMetadata(columnName: "expiresAt", columnType: .int64, isOptional: true, columnIndex: 24)
    static let expiresInSecondsColumn = SDSColumnMetadata(columnName: "expiresInSeconds", columnType: .int64, isOptional: true, columnIndex: 25)
    static let groupMetaMessageColumn = SDSColumnMetadata(columnName: "groupMetaMessage", columnType: .int, isOptional: true, columnIndex: 26)
    static let hasAddToContactsOfferColumn = SDSColumnMetadata(columnName: "hasAddToContactsOffer", columnType: .int, isOptional: true, columnIndex: 27)
    static let hasAddToProfileWhitelistOfferColumn = SDSColumnMetadata(columnName: "hasAddToProfileWhitelistOffer", columnType: .int, isOptional: true, columnIndex: 28)
    static let hasBlockOfferColumn = SDSColumnMetadata(columnName: "hasBlockOffer", columnType: .int, isOptional: true, columnIndex: 29)
    static let hasLegacyMessageStateColumn = SDSColumnMetadata(columnName: "hasLegacyMessageState", columnType: .int, isOptional: true, columnIndex: 30)
    static let hasSyncedTranscriptColumn = SDSColumnMetadata(columnName: "hasSyncedTranscript", columnType: .int, isOptional: true, columnIndex: 31)
    static let infoMessageSchemaVersionColumn = SDSColumnMetadata(columnName: "infoMessageSchemaVersion", columnType: .int64, isOptional: true, columnIndex: 32)
    static let isFromLinkedDeviceColumn = SDSColumnMetadata(columnName: "isFromLinkedDevice", columnType: .int, isOptional: true, columnIndex: 33)
    static let isLocalChangeColumn = SDSColumnMetadata(columnName: "isLocalChange", columnType: .int, isOptional: true, columnIndex: 34)
    static let isVoiceMessageColumn = SDSColumnMetadata(columnName: "isVoiceMessage", columnType: .int, isOptional: true, columnIndex: 35)
    static let legacyMessageStateColumn = SDSColumnMetadata(columnName: "legacyMessageState", columnType: .int, isOptional: true, columnIndex: 36)
    static let legacyWasDeliveredColumn = SDSColumnMetadata(columnName: "legacyWasDelivered", columnType: .int, isOptional: true, columnIndex: 37)
    static let linkPreviewColumn = SDSColumnMetadata(columnName: "linkPreview", columnType: .blob, isOptional: true, columnIndex: 38)
    static let messageIdColumn = SDSColumnMetadata(columnName: "messageId", columnType: .unicodeString, isOptional: true, columnIndex: 39)
    static let messageStickerColumn = SDSColumnMetadata(columnName: "messageSticker", columnType: .blob, isOptional: true, columnIndex: 40)
    static let messageTypeColumn = SDSColumnMetadata(columnName: "messageType", columnType: .int, isOptional: true, columnIndex: 41)
    static let mostRecentFailureTextColumn = SDSColumnMetadata(columnName: "mostRecentFailureText", columnType: .unicodeString, isOptional: true, columnIndex: 42)
    static let perMessageExpirationDurationSecondsColumn = SDSColumnMetadata(columnName: "perMessageExpirationDurationSeconds", columnType: .int64, isOptional: true, columnIndex: 43)
    static let perMessageExpirationHasExpiredColumn = SDSColumnMetadata(columnName: "perMessageExpirationHasExpired", columnType: .int, isOptional: true, columnIndex: 44)
    static let perMessageExpireStartedAtColumn = SDSColumnMetadata(columnName: "perMessageExpireStartedAt", columnType: .int64, isOptional: true, columnIndex: 45)
    static let preKeyBundleColumn = SDSColumnMetadata(columnName: "preKeyBundle", columnType: .blob, isOptional: true, columnIndex: 46)
    static let protocolVersionColumn = SDSColumnMetadata(columnName: "protocolVersion", columnType: .int64, isOptional: true, columnIndex: 47)
    static let quotedMessageColumn = SDSColumnMetadata(columnName: "quotedMessage", columnType: .blob, isOptional: true, columnIndex: 48)
    static let readColumn = SDSColumnMetadata(columnName: "read", columnType: .int, isOptional: true, columnIndex: 49)
    static let recipientIdColumn = SDSColumnMetadata(columnName: "recipientId", columnType: .unicodeString, isOptional: true, columnIndex: 50)
    static let recipientStateMapColumn = SDSColumnMetadata(columnName: "recipientStateMap", columnType: .blob, isOptional: true, columnIndex: 51)
    static let schemaVersionColumn = SDSColumnMetadata(columnName: "schemaVersion", columnType: .int64, isOptional: true, columnIndex: 52)
    static let senderIdColumn = SDSColumnMetadata(columnName: "senderId", columnType: .unicodeString, isOptional: true, columnIndex: 53)
    static let serverTimestampColumn = SDSColumnMetadata(columnName: "serverTimestamp", columnType: .int64, isOptional: true, columnIndex: 54)
    static let sourceDeviceIdColumn = SDSColumnMetadata(columnName: "sourceDeviceId", columnType: .int64, isOptional: true, columnIndex: 55)
    static let unregisteredRecipientIdColumn = SDSColumnMetadata(columnName: "unregisteredRecipientId", columnType: .unicodeString, isOptional: true, columnIndex: 56)
    static let verificationStateColumn = SDSColumnMetadata(columnName: "verificationState", columnType: .int, isOptional: true, columnIndex: 57)
    static let wasReceivedByUDColumn = SDSColumnMetadata(columnName: "wasReceivedByUD", columnType: .int, isOptional: true, columnIndex: 58)

    // TODO: We should decide on a naming convention for
    //       tables that store models.
    public static let table = SDSTableMetadata(tableName: "model_TSInteraction", columns: [
        recordTypeColumn,
        idColumn,
        uniqueIdColumn,
        receivedAtTimestampColumn,
        timestampColumn,
        uniqueThreadIdColumn,
        attachmentFilenameMapColumn,
        attachmentIdsColumn,
        authorIdColumn,
        beforeInteractionIdColumn,
        bodyColumn,
        callSchemaVersionColumn,
        callTypeColumn,
        configurationDurationSecondsColumn,
        configurationIsEnabledColumn,
        contactIdColumn,
        contactShareColumn,
        createdByRemoteNameColumn,
        createdInExistingGroupColumn,
        customMessageColumn,
        envelopeDataColumn,
        errorMessageSchemaVersionColumn,
        errorTypeColumn,
        expireStartedAtColumn,
        expiresAtColumn,
        expiresInSecondsColumn,
        groupMetaMessageColumn,
        hasAddToContactsOfferColumn,
        hasAddToProfileWhitelistOfferColumn,
        hasBlockOfferColumn,
        hasLegacyMessageStateColumn,
        hasSyncedTranscriptColumn,
        infoMessageSchemaVersionColumn,
        isFromLinkedDeviceColumn,
        isLocalChangeColumn,
        isVoiceMessageColumn,
        legacyMessageStateColumn,
        legacyWasDeliveredColumn,
        linkPreviewColumn,
        messageIdColumn,
        messageStickerColumn,
        messageTypeColumn,
        mostRecentFailureTextColumn,
        perMessageExpirationDurationSecondsColumn,
        perMessageExpirationHasExpiredColumn,
        perMessageExpireStartedAtColumn,
        preKeyBundleColumn,
        protocolVersionColumn,
        quotedMessageColumn,
        readColumn,
        recipientIdColumn,
        recipientStateMapColumn,
        schemaVersionColumn,
        senderIdColumn,
        serverTimestampColumn,
        sourceDeviceIdColumn,
        unregisteredRecipientIdColumn,
        verificationStateColumn,
        wasReceivedByUDColumn
        ])
}

// MARK: - Save/Remove/Update

@objc
public extension TSInteraction {
    func anyInsert(transaction: SDSAnyWriteTransaction) {
        sdsSave(saveMode: .insert, transaction: transaction)
    }

    // This method is private; we should never use it directly.
    // Instead, use anyUpdate(transaction:block:), so that we
    // use the "update with" pattern.
    private func anyUpdate(transaction: SDSAnyWriteTransaction) {
        sdsSave(saveMode: .update, transaction: transaction)
    }

    @available(*, deprecated, message: "Use anyInsert() or anyUpdate() instead.")
    func anyUpsert(transaction: SDSAnyWriteTransaction) {
        let isInserting: Bool
        if let uniqueId = uniqueId {
            if TSInteraction.anyFetch(uniqueId: uniqueId, transaction: transaction) != nil {
                isInserting = false
            } else {
                isInserting = true
            }
        } else {
            owsFailDebug("Missing uniqueId: \(type(of: self))")
            isInserting = true
        }
        sdsSave(saveMode: isInserting ? .insert : .update, transaction: transaction)
    }

    // This method is used by "updateWith..." methods.
    //
    // This model may be updated from many threads. We don't want to save
    // our local copy (this instance) since it may be out of date.  We also
    // want to avoid re-saving a model that has been deleted.  Therefore, we
    // use "updateWith..." methods to:
    //
    // a) Update a property of this instance.
    // b) If a copy of this model exists in the database, load an up-to-date copy,
    //    and update and save that copy.
    // b) If a copy of this model _DOES NOT_ exist in the database, do _NOT_ save
    //    this local instance.
    //
    // After "updateWith...":
    //
    // a) Any copy of this model in the database will have been updated.
    // b) The local property on this instance will always have been updated.
    // c) Other properties on this instance may be out of date.
    //
    // All mutable properties of this class have been made read-only to
    // prevent accidentally modifying them directly.
    //
    // This isn't a perfect arrangement, but in practice this will prevent
    // data loss and will resolve all known issues.
    func anyUpdate(transaction: SDSAnyWriteTransaction, block: (TSInteraction) -> Void) {
        guard let uniqueId = uniqueId else {
            owsFailDebug("Missing uniqueId.")
            return
        }

        block(self)

        guard let dbCopy = type(of: self).anyFetch(uniqueId: uniqueId,
                                                   transaction: transaction) else {
            return
        }

        // Don't apply the block twice to the same instance.
        // It's at least unnecessary and actually wrong for some blocks.
        // e.g. `block: { $0 in $0.someField++ }`
        if dbCopy !== self {
            block(dbCopy)
        }

        dbCopy.anyUpdate(transaction: transaction)
    }

    func anyRemove(transaction: SDSAnyWriteTransaction) {
        anyWillRemove(with: transaction)

        switch transaction.writeTransaction {
        case .yapWrite(let ydbTransaction):
            ydb_remove(with: ydbTransaction)
        case .grdbWrite(let grdbTransaction):
            do {
                let record = try asRecord()
                record.sdsRemove(transaction: grdbTransaction)
            } catch {
                owsFail("Remove failed: \(error)")
            }
        }

        anyDidRemove(with: transaction)
    }

    func anyReload(transaction: SDSAnyReadTransaction) {
        anyReload(transaction: transaction, ignoreMissing: false)
    }

    func anyReload(transaction: SDSAnyReadTransaction, ignoreMissing: Bool) {
        guard let uniqueId = self.uniqueId else {
            owsFailDebug("uniqueId was unexpectedly nil")
            return
        }

        guard let latestVersion = type(of: self).anyFetch(uniqueId: uniqueId, transaction: transaction) else {
            if !ignoreMissing {
                owsFailDebug("`latest` was unexpectedly nil")
            }
            return
        }

        setValuesForKeys(latestVersion.dictionaryValue)
    }
}

// MARK: - TSInteractionCursor

@objc
public class TSInteractionCursor: NSObject {
    private let cursor: RecordCursor<InteractionRecord>?

    init(cursor: RecordCursor<InteractionRecord>?) {
        self.cursor = cursor
    }

    public func next() throws -> TSInteraction? {
        guard let cursor = cursor else {
            return nil
        }
        guard let record = try cursor.next() else {
            return nil
        }
        return try TSInteraction.fromRecord(record)
    }

    public func all() throws -> [TSInteraction] {
        var result = [TSInteraction]()
        while true {
            guard let model = try next() else {
                break
            }
            result.append(model)
        }
        return result
    }
}

// MARK: - Obj-C Fetch

// TODO: We may eventually want to define some combination of:
//
// * fetchCursor, fetchOne, fetchAll, etc. (ala GRDB)
// * Optional "where clause" parameters for filtering.
// * Async flavors with completions.
//
// TODO: I've defined flavors that take a read transaction.
//       Or we might take a "connection" if we end up having that class.
@objc
public extension TSInteraction {
    class func grdbFetchCursor(transaction: GRDBReadTransaction) -> TSInteractionCursor {
        let database = transaction.database
        do {
            let cursor = try InteractionRecord.fetchCursor(database)
            return TSInteractionCursor(cursor: cursor)
        } catch {
            owsFailDebug("Read failed: \(error)")
            return TSInteractionCursor(cursor: nil)
        }
    }

    // Fetches a single model by "unique id".
    class func anyFetch(uniqueId: String,
                        transaction: SDSAnyReadTransaction) -> TSInteraction? {
        assert(uniqueId.count > 0)

        switch transaction.readTransaction {
        case .yapRead(let ydbTransaction):
            return TSInteraction.ydb_fetch(uniqueId: uniqueId, transaction: ydbTransaction)
        case .grdbRead(let grdbTransaction):
            let sql = "SELECT * FROM \(InteractionRecord.databaseTableName) WHERE \(interactionColumn: .uniqueId) = ?"
            return grdbFetchOne(sql: sql, arguments: [uniqueId], transaction: grdbTransaction)
        }
    }

    // Traverses all records.
    // Records are not visited in any particular order.
    // Traversal aborts if the visitor returns false.
    class func anyEnumerate(transaction: SDSAnyReadTransaction, block: @escaping (TSInteraction, UnsafeMutablePointer<ObjCBool>) -> Void) {
        switch transaction.readTransaction {
        case .yapRead(let ydbTransaction):
            TSInteraction.ydb_enumerateCollectionObjects(with: ydbTransaction) { (object, stop) in
                guard let value = object as? TSInteraction else {
                    owsFailDebug("unexpected object: \(type(of: object))")
                    return
                }
                block(value, stop)
            }
        case .grdbRead(let grdbTransaction):
            do {
                let cursor = TSInteraction.grdbFetchCursor(transaction: grdbTransaction)
                var stop: ObjCBool = false
                while let value = try cursor.next() {
                    block(value, &stop)
                    guard !stop.boolValue else {
                        break
                    }
                }
            } catch let error as NSError {
                owsFailDebug("Couldn't fetch models: \(error)")
            }
        }
    }

    // Does not order the results.
    class func anyFetchAll(transaction: SDSAnyReadTransaction) -> [TSInteraction] {
        var result = [TSInteraction]()
        anyEnumerate(transaction: transaction) { (model, _) in
            result.append(model)
        }
        return result
    }

    class func anyCount(transaction: SDSAnyReadTransaction) -> UInt {
        switch transaction.readTransaction {
        case .yapRead(let ydbTransaction):
            return ydbTransaction.numberOfKeys(inCollection: TSInteraction.collection())
        case .grdbRead(let grdbTransaction):
            return InteractionRecord.ows_fetchCount(grdbTransaction.database)
        }
    }

    // WARNING: Do not use this method for any models which do cleanup
    //          in their anyWillRemove(), anyDidRemove() methods.
    class func anyRemoveAllWithoutInstantation(transaction: SDSAnyWriteTransaction) {
        switch transaction.writeTransaction {
        case .yapWrite(let ydbTransaction):
            ydbTransaction.removeAllObjects(inCollection: TSInteraction.collection())
        case .grdbWrite(let grdbTransaction):
            do {
                try InteractionRecord.deleteAll(grdbTransaction.database)
            } catch {
                owsFailDebug("deleteAll() failed: \(error)")
            }
        }
    }

    class func anyRemoveAllWithInstantation(transaction: SDSAnyWriteTransaction) {
        anyEnumerate(transaction: transaction) { (instance, _) in
            instance.anyRemove(transaction: transaction)
        }
    }
}

// MARK: - Swift Fetch

public extension TSInteraction {
    class func grdbFetchCursor(sql: String,
                               arguments: [DatabaseValueConvertible]?,
                               transaction: GRDBReadTransaction) -> TSInteractionCursor {
        var statementArguments: StatementArguments?
        if let arguments = arguments {
            guard let statementArgs = StatementArguments(arguments) else {
                owsFailDebug("Could not convert arguments.")
                return TSInteractionCursor(cursor: nil)
            }
            statementArguments = statementArgs
        }
        let database = transaction.database
        do {
            let statement: SelectStatement = try database.cachedSelectStatement(sql: sql)
            let cursor = try InteractionRecord.fetchCursor(statement, arguments: statementArguments)
            return TSInteractionCursor(cursor: cursor)
        } catch {
            Logger.error("sql: \(sql)")
            owsFailDebug("Read failed: \(error)")
            return TSInteractionCursor(cursor: nil)
        }
    }

    class func grdbFetchOne(sql: String,
                            arguments: StatementArguments,
                            transaction: GRDBReadTransaction) -> TSInteraction? {
        assert(sql.count > 0)

        do {
            guard let record = try InteractionRecord.fetchOne(transaction.database, sql: sql, arguments: arguments) else {
                return nil
            }

            return try TSInteraction.fromRecord(record)
        } catch {
            owsFailDebug("error: \(error)")
            return nil
        }
    }
}

// MARK: - SDSSerializer

// The SDSSerializer protocol specifies how to insert and update the
// row that corresponds to this model.
class TSInteractionSerializer: SDSSerializer {

    private let model: TSInteraction
    public required init(model: TSInteraction) {
        self.model = model
    }

    // MARK: - Record

    func asRecord() throws -> SDSRecord {
        let id: Int64? = nil

        let recordType: SDSRecordType = .interaction
        guard let uniqueId: String = model.uniqueId else {
            owsFailDebug("Missing uniqueId.")
            throw SDSError.missingRequiredField
        }

        // Base class properties
        let receivedAtTimestamp: UInt64 = model.receivedAtTimestamp
        let timestamp: UInt64 = model.timestamp
        let threadUniqueId: String = model.uniqueThreadId

        // Subclass properties
        let attachmentFilenameMap: Data? = nil
        let attachmentIds: Data? = nil
        let authorId: String? = nil
        let beforeInteractionId: String? = nil
        let body: String? = nil
        let callSchemaVersion: UInt? = nil
        let callType: RPRecentCallType? = nil
        let configurationDurationSeconds: UInt32? = nil
        let configurationIsEnabled: Bool? = nil
        let contactId: String? = nil
        let contactShare: Data? = nil
        let createdByRemoteName: String? = nil
        let createdInExistingGroup: Bool? = nil
        let customMessage: String? = nil
        let envelopeData: Data? = nil
        let errorMessageSchemaVersion: UInt? = nil
        let errorType: TSErrorMessageType? = nil
        let expireStartedAt: UInt64? = nil
        let expiresAt: UInt64? = nil
        let expiresInSeconds: UInt32? = nil
        let groupMetaMessage: TSGroupMetaMessage? = nil
        let hasAddToContactsOffer: Bool? = nil
        let hasAddToProfileWhitelistOffer: Bool? = nil
        let hasBlockOffer: Bool? = nil
        let hasLegacyMessageState: Bool? = nil
        let hasSyncedTranscript: Bool? = nil
        let infoMessageSchemaVersion: UInt? = nil
        let isFromLinkedDevice: Bool? = nil
        let isLocalChange: Bool? = nil
        let isVoiceMessage: Bool? = nil
        let legacyMessageState: TSOutgoingMessageState? = nil
        let legacyWasDelivered: Bool? = nil
        let linkPreview: Data? = nil
        let messageId: String? = nil
        let messageSticker: Data? = nil
        let messageType: TSInfoMessageType? = nil
        let mostRecentFailureText: String? = nil
        let perMessageExpirationDurationSeconds: UInt32? = nil
        let perMessageExpirationHasExpired: Bool? = nil
        let perMessageExpireStartedAt: UInt64? = nil
        let preKeyBundle: Data? = nil
        let protocolVersion: UInt? = nil
        let quotedMessage: Data? = nil
        let read: Bool? = nil
        let recipientId: String? = nil
        let recipientStateMap: Data? = nil
        let schemaVersion: UInt? = nil
        let senderId: String? = nil
        let serverTimestamp: UInt64? = nil
        let sourceDeviceId: UInt32? = nil
        let unregisteredRecipientId: String? = nil
        let verificationState: OWSVerificationState? = nil
        let wasReceivedByUD: Bool? = nil

        return InteractionRecord(id: id, recordType: recordType, uniqueId: uniqueId, receivedAtTimestamp: receivedAtTimestamp, timestamp: timestamp, threadUniqueId: threadUniqueId, attachmentFilenameMap: attachmentFilenameMap, attachmentIds: attachmentIds, authorId: authorId, beforeInteractionId: beforeInteractionId, body: body, callSchemaVersion: callSchemaVersion, callType: callType, configurationDurationSeconds: configurationDurationSeconds, configurationIsEnabled: configurationIsEnabled, contactId: contactId, contactShare: contactShare, createdByRemoteName: createdByRemoteName, createdInExistingGroup: createdInExistingGroup, customMessage: customMessage, envelopeData: envelopeData, errorMessageSchemaVersion: errorMessageSchemaVersion, errorType: errorType, expireStartedAt: expireStartedAt, expiresAt: expiresAt, expiresInSeconds: expiresInSeconds, groupMetaMessage: groupMetaMessage, hasAddToContactsOffer: hasAddToContactsOffer, hasAddToProfileWhitelistOffer: hasAddToProfileWhitelistOffer, hasBlockOffer: hasBlockOffer, hasLegacyMessageState: hasLegacyMessageState, hasSyncedTranscript: hasSyncedTranscript, infoMessageSchemaVersion: infoMessageSchemaVersion, isFromLinkedDevice: isFromLinkedDevice, isLocalChange: isLocalChange, isVoiceMessage: isVoiceMessage, legacyMessageState: legacyMessageState, legacyWasDelivered: legacyWasDelivered, linkPreview: linkPreview, messageId: messageId, messageSticker: messageSticker, messageType: messageType, mostRecentFailureText: mostRecentFailureText, perMessageExpirationDurationSeconds: perMessageExpirationDurationSeconds, perMessageExpirationHasExpired: perMessageExpirationHasExpired, perMessageExpireStartedAt: perMessageExpireStartedAt, preKeyBundle: preKeyBundle, protocolVersion: protocolVersion, quotedMessage: quotedMessage, read: read, recipientId: recipientId, recipientStateMap: recipientStateMap, schemaVersion: schemaVersion, senderId: senderId, serverTimestamp: serverTimestamp, sourceDeviceId: sourceDeviceId, unregisteredRecipientId: unregisteredRecipientId, verificationState: verificationState, wasReceivedByUD: wasReceivedByUD)
    }
}
