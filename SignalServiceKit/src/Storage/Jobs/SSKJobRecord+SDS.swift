//
// Copyright 2022 Signal Messenger, LLC
// SPDX-License-Identifier: AGPL-3.0-only
//

import Foundation
import GRDB
import SignalCoreKit

// NOTE: This file is generated by /Scripts/sds_codegen/sds_generate.py.
// Do not manually edit it, instead run `sds_codegen.sh`.

// MARK: - Record

public struct JobRecordRecord: SDSRecord {
    public weak var delegate: SDSRecordDelegate?

    public var tableMetadata: SDSTableMetadata {
        SSKJobRecordSerializer.table
    }

    public static var databaseTableName: String {
        SSKJobRecordSerializer.table.tableName
    }

    public var id: Int64?

    // This defines all of the columns used in the table
    // where this model (and any subclasses) are persisted.
    public let recordType: SDSRecordType
    public let uniqueId: String

    // Properties
    public let failureCount: UInt
    public let label: String
    public let status: SSKJobRecordStatus
    public let attachmentIdMap: Data?
    public let contactThreadId: String?
    public let envelopeData: Data?
    public let invisibleMessage: Data?
    public let messageId: String?
    public let removeMessageAfterSending: Bool?
    public let threadId: String?
    public let attachmentId: String?
    public let isMediaMessage: Bool?
    public let serverDeliveryTimestamp: UInt64?
    public let exclusiveProcessIdentifier: String?
    public let isHighPriority: Bool?
    public let receiptCredentailRequest: Data?
    public let receiptCredentailRequestContext: Data?
    public let priorSubscriptionLevel: UInt?
    public let subscriberID: Data?
    public let targetSubscriptionLevel: UInt?
    public let boostPaymentIntentID: String?
    public let isBoost: Bool?
    public let receiptCredentialPresentation: Data?
    public let amount: Data?
    public let currencyCode: String?
    public let unsavedMessagesToSend: Data?
    public let messageText: String?
    public let paymentIntentClientSecret: String?
    public let paymentMethodId: String?
    public let replacementAdminUuid: String?
    public let waitForMessageProcessing: Bool?
    public let isCompleteContactSync: Bool?

    public enum CodingKeys: String, CodingKey, ColumnExpression, CaseIterable {
        case id
        case recordType
        case uniqueId
        case failureCount
        case label
        case status
        case attachmentIdMap
        case contactThreadId
        case envelopeData
        case invisibleMessage
        case messageId
        case removeMessageAfterSending
        case threadId
        case attachmentId
        case isMediaMessage
        case serverDeliveryTimestamp
        case exclusiveProcessIdentifier
        case isHighPriority
        case receiptCredentailRequest
        case receiptCredentailRequestContext
        case priorSubscriptionLevel
        case subscriberID
        case targetSubscriptionLevel
        case boostPaymentIntentID
        case isBoost
        case receiptCredentialPresentation
        case amount
        case currencyCode
        case unsavedMessagesToSend
        case messageText
        case paymentIntentClientSecret
        case paymentMethodId
        case replacementAdminUuid
        case waitForMessageProcessing
        case isCompleteContactSync
    }

    public static func columnName(_ column: JobRecordRecord.CodingKeys, fullyQualified: Bool = false) -> String {
        fullyQualified ? "\(databaseTableName).\(column.rawValue)" : column.rawValue
    }

    public func didInsert(with rowID: Int64, for column: String?) {
        guard let delegate = delegate else {
            owsFailDebug("Missing delegate.")
            return
        }
        delegate.updateRowId(rowID)
    }
}

// MARK: - Row Initializer

public extension JobRecordRecord {
    static var databaseSelection: [SQLSelectable] {
        CodingKeys.allCases
    }

    init(row: Row) {
        id = row[0]
        recordType = row[1]
        uniqueId = row[2]
        failureCount = row[3]
        label = row[4]
        status = row[5]
        attachmentIdMap = row[6]
        contactThreadId = row[7]
        envelopeData = row[8]
        invisibleMessage = row[9]
        messageId = row[10]
        removeMessageAfterSending = row[11]
        threadId = row[12]
        attachmentId = row[13]
        isMediaMessage = row[14]
        serverDeliveryTimestamp = row[15]
        exclusiveProcessIdentifier = row[16]
        isHighPriority = row[17]
        receiptCredentailRequest = row[18]
        receiptCredentailRequestContext = row[19]
        priorSubscriptionLevel = row[20]
        subscriberID = row[21]
        targetSubscriptionLevel = row[22]
        boostPaymentIntentID = row[23]
        isBoost = row[24]
        receiptCredentialPresentation = row[25]
        amount = row[26]
        currencyCode = row[27]
        unsavedMessagesToSend = row[28]
        messageText = row[29]
        paymentIntentClientSecret = row[30]
        paymentMethodId = row[31]
        replacementAdminUuid = row[32]
        waitForMessageProcessing = row[33]
        isCompleteContactSync = row[34]
    }
}

// MARK: - StringInterpolation

public extension String.StringInterpolation {
    mutating func appendInterpolation(jobRecordColumn column: JobRecordRecord.CodingKeys) {
        appendLiteral(JobRecordRecord.columnName(column))
    }
    mutating func appendInterpolation(jobRecordColumnFullyQualified column: JobRecordRecord.CodingKeys) {
        appendLiteral(JobRecordRecord.columnName(column, fullyQualified: true))
    }
}

// MARK: - Deserialization

// TODO: Rework metadata to not include, for example, columns, column indices.
extension SSKJobRecord {
    // This method defines how to deserialize a model, given a
    // database row.  The recordType column is used to determine
    // the corresponding model class.
    class func fromRecord(_ record: JobRecordRecord) throws -> SSKJobRecord {

        guard let recordId = record.id else {
            throw SDSError.invalidValue
        }

        switch record.recordType {
        case .broadcastMediaMessageJobRecord:

            let uniqueId: String = record.uniqueId
            let exclusiveProcessIdentifier: String? = record.exclusiveProcessIdentifier
            let failureCount: UInt = record.failureCount
            let label: String = record.label
            let sortId: UInt64 = UInt64(recordId)
            let status: SSKJobRecordStatus = record.status
            let attachmentIdMapSerialized: Data? = record.attachmentIdMap
            let attachmentIdMap: [String: [String]] = try SDSDeserialization.unarchive(attachmentIdMapSerialized, name: "attachmentIdMap")
            let unsavedMessagesToSendSerialized: Data? = record.unsavedMessagesToSend
            let unsavedMessagesToSend: [TSOutgoingMessage]? = try SDSDeserialization.optionalUnarchive(unsavedMessagesToSendSerialized, name: "unsavedMessagesToSend")

            return OWSBroadcastMediaMessageJobRecord(grdbId: recordId,
                                                     uniqueId: uniqueId,
                                                     exclusiveProcessIdentifier: exclusiveProcessIdentifier,
                                                     failureCount: failureCount,
                                                     label: label,
                                                     sortId: sortId,
                                                     status: status,
                                                     attachmentIdMap: attachmentIdMap,
                                                     unsavedMessagesToSend: unsavedMessagesToSend)

        case .incomingContactSyncJobRecord:

            let uniqueId: String = record.uniqueId
            let exclusiveProcessIdentifier: String? = record.exclusiveProcessIdentifier
            let failureCount: UInt = record.failureCount
            let label: String = record.label
            let sortId: UInt64 = UInt64(recordId)
            let status: SSKJobRecordStatus = record.status
            let attachmentId: String = try SDSDeserialization.required(record.attachmentId, name: "attachmentId")
            let isCompleteContactSync: Bool = try SDSDeserialization.required(record.isCompleteContactSync, name: "isCompleteContactSync")

            return OWSIncomingContactSyncJobRecord(grdbId: recordId,
                                                   uniqueId: uniqueId,
                                                   exclusiveProcessIdentifier: exclusiveProcessIdentifier,
                                                   failureCount: failureCount,
                                                   label: label,
                                                   sortId: sortId,
                                                   status: status,
                                                   attachmentId: attachmentId,
                                                   isCompleteContactSync: isCompleteContactSync)

        case .incomingGroupSyncJobRecord:

            let uniqueId: String = record.uniqueId
            let exclusiveProcessIdentifier: String? = record.exclusiveProcessIdentifier
            let failureCount: UInt = record.failureCount
            let label: String = record.label
            let sortId: UInt64 = UInt64(recordId)
            let status: SSKJobRecordStatus = record.status
            let attachmentId: String = try SDSDeserialization.required(record.attachmentId, name: "attachmentId")

            return OWSIncomingGroupSyncJobRecord(grdbId: recordId,
                                                 uniqueId: uniqueId,
                                                 exclusiveProcessIdentifier: exclusiveProcessIdentifier,
                                                 failureCount: failureCount,
                                                 label: label,
                                                 sortId: sortId,
                                                 status: status,
                                                 attachmentId: attachmentId)

        case .localUserLeaveGroupJobRecord:

            let uniqueId: String = record.uniqueId
            let exclusiveProcessIdentifier: String? = record.exclusiveProcessIdentifier
            let failureCount: UInt = record.failureCount
            let label: String = record.label
            let sortId: UInt64 = UInt64(recordId)
            let status: SSKJobRecordStatus = record.status
            let replacementAdminUuid: String? = record.replacementAdminUuid
            let threadId: String = try SDSDeserialization.required(record.threadId, name: "threadId")
            let waitForMessageProcessing: Bool = try SDSDeserialization.required(record.waitForMessageProcessing, name: "waitForMessageProcessing")

            return OWSLocalUserLeaveGroupJobRecord(grdbId: recordId,
                                                   uniqueId: uniqueId,
                                                   exclusiveProcessIdentifier: exclusiveProcessIdentifier,
                                                   failureCount: failureCount,
                                                   label: label,
                                                   sortId: sortId,
                                                   status: status,
                                                   replacementAdminUuid: replacementAdminUuid,
                                                   threadId: threadId,
                                                   waitForMessageProcessing: waitForMessageProcessing)

        case .receiptCredentialRedemptionJobRecord:

            let uniqueId: String = record.uniqueId
            let exclusiveProcessIdentifier: String? = record.exclusiveProcessIdentifier
            let failureCount: UInt = record.failureCount
            let label: String = record.label
            let sortId: UInt64 = UInt64(recordId)
            let status: SSKJobRecordStatus = record.status
            let amountSerialized: Data? = record.amount
            let amount: NSDecimalNumber? = try SDSDeserialization.optionalUnarchive(amountSerialized, name: "amount")
            let boostPaymentIntentID: String = try SDSDeserialization.required(record.boostPaymentIntentID, name: "boostPaymentIntentID")
            let currencyCode: String? = record.currencyCode
            let isBoost: Bool = try SDSDeserialization.required(record.isBoost, name: "isBoost")
            let priorSubscriptionLevel: UInt = try SDSDeserialization.required(record.priorSubscriptionLevel, name: "priorSubscriptionLevel")
            let receiptCredentailRequest: Data = try SDSDeserialization.required(record.receiptCredentailRequest, name: "receiptCredentailRequest")
            let receiptCredentailRequestContext: Data = try SDSDeserialization.required(record.receiptCredentailRequestContext, name: "receiptCredentailRequestContext")
            let receiptCredentialPresentation: Data? = SDSDeserialization.optionalData(record.receiptCredentialPresentation, name: "receiptCredentialPresentation")
            let subscriberID: Data = try SDSDeserialization.required(record.subscriberID, name: "subscriberID")
            let targetSubscriptionLevel: UInt = try SDSDeserialization.required(record.targetSubscriptionLevel, name: "targetSubscriptionLevel")

            return OWSReceiptCredentialRedemptionJobRecord(grdbId: recordId,
                                                           uniqueId: uniqueId,
                                                           exclusiveProcessIdentifier: exclusiveProcessIdentifier,
                                                           failureCount: failureCount,
                                                           label: label,
                                                           sortId: sortId,
                                                           status: status,
                                                           amount: amount,
                                                           boostPaymentIntentID: boostPaymentIntentID,
                                                           currencyCode: currencyCode,
                                                           isBoost: isBoost,
                                                           priorSubscriptionLevel: priorSubscriptionLevel,
                                                           receiptCredentailRequest: receiptCredentailRequest,
                                                           receiptCredentailRequestContext: receiptCredentailRequestContext,
                                                           receiptCredentialPresentation: receiptCredentialPresentation,
                                                           subscriberID: subscriberID,
                                                           targetSubscriptionLevel: targetSubscriptionLevel)

        case .sendGiftBadgeJobRecord:

            let uniqueId: String = record.uniqueId
            let exclusiveProcessIdentifier: String? = record.exclusiveProcessIdentifier
            let failureCount: UInt = record.failureCount
            let label: String = record.label
            let sortId: UInt64 = UInt64(recordId)
            let status: SSKJobRecordStatus = record.status
            let amountSerialized: Data? = record.amount
            let amount: NSDecimalNumber = try SDSDeserialization.unarchive(amountSerialized, name: "amount")
            let boostPaymentIntentID: String = try SDSDeserialization.required(record.boostPaymentIntentID, name: "boostPaymentIntentID")
            let currencyCode: String = try SDSDeserialization.required(record.currencyCode, name: "currencyCode")
            let messageText: String = try SDSDeserialization.required(record.messageText, name: "messageText")
            let paymentIntentClientSecret: String = try SDSDeserialization.required(record.paymentIntentClientSecret, name: "paymentIntentClientSecret")
            let paymentMethodId: String = try SDSDeserialization.required(record.paymentMethodId, name: "paymentMethodId")
            let receiptCredentailRequest: Data = try SDSDeserialization.required(record.receiptCredentailRequest, name: "receiptCredentailRequest")
            let receiptCredentailRequestContext: Data = try SDSDeserialization.required(record.receiptCredentailRequestContext, name: "receiptCredentailRequestContext")
            let threadId: String = try SDSDeserialization.required(record.threadId, name: "threadId")

            return OWSSendGiftBadgeJobRecord(grdbId: recordId,
                                             uniqueId: uniqueId,
                                             exclusiveProcessIdentifier: exclusiveProcessIdentifier,
                                             failureCount: failureCount,
                                             label: label,
                                             sortId: sortId,
                                             status: status,
                                             amount: amount,
                                             boostPaymentIntentID: boostPaymentIntentID,
                                             currencyCode: currencyCode,
                                             messageText: messageText,
                                             paymentIntentClientSecret: paymentIntentClientSecret,
                                             paymentMethodId: paymentMethodId,
                                             receiptCredentailRequest: receiptCredentailRequest,
                                             receiptCredentailRequestContext: receiptCredentailRequestContext,
                                             threadId: threadId)

        case .sessionResetJobRecord:

            let uniqueId: String = record.uniqueId
            let exclusiveProcessIdentifier: String? = record.exclusiveProcessIdentifier
            let failureCount: UInt = record.failureCount
            let label: String = record.label
            let sortId: UInt64 = UInt64(recordId)
            let status: SSKJobRecordStatus = record.status
            let contactThreadId: String = try SDSDeserialization.required(record.contactThreadId, name: "contactThreadId")

            return OWSSessionResetJobRecord(grdbId: recordId,
                                            uniqueId: uniqueId,
                                            exclusiveProcessIdentifier: exclusiveProcessIdentifier,
                                            failureCount: failureCount,
                                            label: label,
                                            sortId: sortId,
                                            status: status,
                                            contactThreadId: contactThreadId)

        case .jobRecord:

            let uniqueId: String = record.uniqueId
            let exclusiveProcessIdentifier: String? = record.exclusiveProcessIdentifier
            let failureCount: UInt = record.failureCount
            let label: String = record.label
            let sortId: UInt64 = UInt64(recordId)
            let status: SSKJobRecordStatus = record.status

            return SSKJobRecord(grdbId: recordId,
                                uniqueId: uniqueId,
                                exclusiveProcessIdentifier: exclusiveProcessIdentifier,
                                failureCount: failureCount,
                                label: label,
                                sortId: sortId,
                                status: status)

        case .messageDecryptJobRecord:

            let uniqueId: String = record.uniqueId
            let exclusiveProcessIdentifier: String? = record.exclusiveProcessIdentifier
            let failureCount: UInt = record.failureCount
            let label: String = record.label
            let sortId: UInt64 = UInt64(recordId)
            let status: SSKJobRecordStatus = record.status
            let envelopeData: Data? = SDSDeserialization.optionalData(record.envelopeData, name: "envelopeData")
            let serverDeliveryTimestamp: UInt64 = try SDSDeserialization.required(record.serverDeliveryTimestamp, name: "serverDeliveryTimestamp")

            return SSKMessageDecryptJobRecord(grdbId: recordId,
                                              uniqueId: uniqueId,
                                              exclusiveProcessIdentifier: exclusiveProcessIdentifier,
                                              failureCount: failureCount,
                                              label: label,
                                              sortId: sortId,
                                              status: status,
                                              envelopeData: envelopeData,
                                              serverDeliveryTimestamp: serverDeliveryTimestamp)

        case .messageSenderJobRecord:

            let uniqueId: String = record.uniqueId
            let exclusiveProcessIdentifier: String? = record.exclusiveProcessIdentifier
            let failureCount: UInt = record.failureCount
            let label: String = record.label
            let sortId: UInt64 = UInt64(recordId)
            let status: SSKJobRecordStatus = record.status
            let invisibleMessageSerialized: Data? = record.invisibleMessage
            let invisibleMessage: TSOutgoingMessage? = try SDSDeserialization.optionalUnarchive(invisibleMessageSerialized, name: "invisibleMessage")
            let isHighPriority: Bool = try SDSDeserialization.required(record.isHighPriority, name: "isHighPriority")
            let isMediaMessage: Bool = try SDSDeserialization.required(record.isMediaMessage, name: "isMediaMessage")
            let messageId: String? = record.messageId
            let removeMessageAfterSending: Bool = try SDSDeserialization.required(record.removeMessageAfterSending, name: "removeMessageAfterSending")
            let threadId: String? = record.threadId

            return SSKMessageSenderJobRecord(grdbId: recordId,
                                             uniqueId: uniqueId,
                                             exclusiveProcessIdentifier: exclusiveProcessIdentifier,
                                             failureCount: failureCount,
                                             label: label,
                                             sortId: sortId,
                                             status: status,
                                             invisibleMessage: invisibleMessage,
                                             isHighPriority: isHighPriority,
                                             isMediaMessage: isMediaMessage,
                                             messageId: messageId,
                                             removeMessageAfterSending: removeMessageAfterSending,
                                             threadId: threadId)

        default:
            owsFailDebug("Unexpected record type: \(record.recordType)")
            throw SDSError.invalidValue
        }
    }
}

// MARK: - SDSModel

extension SSKJobRecord: SDSModel {
    public var serializer: SDSSerializer {
        // Any subclass can be cast to it's superclass,
        // so the order of this switch statement matters.
        // We need to do a "depth first" search by type.
        switch self {
        case let model as SSKMessageSenderJobRecord:
            assert(type(of: model) == SSKMessageSenderJobRecord.self)
            return SSKMessageSenderJobRecordSerializer(model: model)
        case let model as SSKMessageDecryptJobRecord:
            assert(type(of: model) == SSKMessageDecryptJobRecord.self)
            return SSKMessageDecryptJobRecordSerializer(model: model)
        case let model as OWSSessionResetJobRecord:
            assert(type(of: model) == OWSSessionResetJobRecord.self)
            return OWSSessionResetJobRecordSerializer(model: model)
        case let model as OWSSendGiftBadgeJobRecord:
            assert(type(of: model) == OWSSendGiftBadgeJobRecord.self)
            return OWSSendGiftBadgeJobRecordSerializer(model: model)
        case let model as OWSReceiptCredentialRedemptionJobRecord:
            assert(type(of: model) == OWSReceiptCredentialRedemptionJobRecord.self)
            return OWSReceiptCredentialRedemptionJobRecordSerializer(model: model)
        case let model as OWSLocalUserLeaveGroupJobRecord:
            assert(type(of: model) == OWSLocalUserLeaveGroupJobRecord.self)
            return OWSLocalUserLeaveGroupJobRecordSerializer(model: model)
        case let model as OWSIncomingGroupSyncJobRecord:
            assert(type(of: model) == OWSIncomingGroupSyncJobRecord.self)
            return OWSIncomingGroupSyncJobRecordSerializer(model: model)
        case let model as OWSIncomingContactSyncJobRecord:
            assert(type(of: model) == OWSIncomingContactSyncJobRecord.self)
            return OWSIncomingContactSyncJobRecordSerializer(model: model)
        case let model as OWSBroadcastMediaMessageJobRecord:
            assert(type(of: model) == OWSBroadcastMediaMessageJobRecord.self)
            return OWSBroadcastMediaMessageJobRecordSerializer(model: model)
        default:
            return SSKJobRecordSerializer(model: self)
        }
    }

    public func asRecord() throws -> SDSRecord {
        try serializer.asRecord()
    }

    public var sdsTableName: String {
        JobRecordRecord.databaseTableName
    }

    public static var table: SDSTableMetadata {
        SSKJobRecordSerializer.table
    }

    public class func anyEnumerateIndexable(
        transaction: SDSAnyReadTransaction,
        block: @escaping (SDSIndexableModel) -> Void
    ) {
        anyEnumerate(transaction: transaction, batched: false) { model, _ in
            block(model)
        }
    }
}

// MARK: - DeepCopyable

extension SSKJobRecord: DeepCopyable {

    public func deepCopy() throws -> AnyObject {
        // Any subclass can be cast to it's superclass,
        // so the order of this switch statement matters.
        // We need to do a "depth first" search by type.
        guard let id = self.grdbId?.int64Value else {
            throw OWSAssertionError("Model missing grdbId.")
        }

        if let modelToCopy = self as? SSKMessageSenderJobRecord {
            assert(type(of: modelToCopy) == SSKMessageSenderJobRecord.self)
            let uniqueId: String = modelToCopy.uniqueId
            let exclusiveProcessIdentifier: String? = modelToCopy.exclusiveProcessIdentifier
            let failureCount: UInt = modelToCopy.failureCount
            let label: String = modelToCopy.label
            let sortId: UInt64 = modelToCopy.sortId
            let status: SSKJobRecordStatus = modelToCopy.status
            // NOTE: If this generates build errors, you made need to
            // modify DeepCopy.swift to support this type.
            //
            // That might mean:
            //
            // * Implement DeepCopyable for this type (e.g. a model).
            // * Modify DeepCopies.deepCopy() to support this type (e.g. a collection).
            let invisibleMessage: TSOutgoingMessage?
            if let invisibleMessageForCopy = modelToCopy.invisibleMessage {
               invisibleMessage = try DeepCopies.deepCopy(invisibleMessageForCopy)
            } else {
               invisibleMessage = nil
            }
            let isHighPriority: Bool = modelToCopy.isHighPriority
            let isMediaMessage: Bool = modelToCopy.isMediaMessage
            let messageId: String? = modelToCopy.messageId
            let removeMessageAfterSending: Bool = modelToCopy.removeMessageAfterSending
            let threadId: String? = modelToCopy.threadId

            return SSKMessageSenderJobRecord(grdbId: id,
                                             uniqueId: uniqueId,
                                             exclusiveProcessIdentifier: exclusiveProcessIdentifier,
                                             failureCount: failureCount,
                                             label: label,
                                             sortId: sortId,
                                             status: status,
                                             invisibleMessage: invisibleMessage,
                                             isHighPriority: isHighPriority,
                                             isMediaMessage: isMediaMessage,
                                             messageId: messageId,
                                             removeMessageAfterSending: removeMessageAfterSending,
                                             threadId: threadId)
        }

        if let modelToCopy = self as? SSKMessageDecryptJobRecord {
            assert(type(of: modelToCopy) == SSKMessageDecryptJobRecord.self)
            let uniqueId: String = modelToCopy.uniqueId
            let exclusiveProcessIdentifier: String? = modelToCopy.exclusiveProcessIdentifier
            let failureCount: UInt = modelToCopy.failureCount
            let label: String = modelToCopy.label
            let sortId: UInt64 = modelToCopy.sortId
            let status: SSKJobRecordStatus = modelToCopy.status
            let envelopeData: Data? = modelToCopy.envelopeData
            let serverDeliveryTimestamp: UInt64 = modelToCopy.serverDeliveryTimestamp

            return SSKMessageDecryptJobRecord(grdbId: id,
                                              uniqueId: uniqueId,
                                              exclusiveProcessIdentifier: exclusiveProcessIdentifier,
                                              failureCount: failureCount,
                                              label: label,
                                              sortId: sortId,
                                              status: status,
                                              envelopeData: envelopeData,
                                              serverDeliveryTimestamp: serverDeliveryTimestamp)
        }

        if let modelToCopy = self as? OWSSessionResetJobRecord {
            assert(type(of: modelToCopy) == OWSSessionResetJobRecord.self)
            let uniqueId: String = modelToCopy.uniqueId
            let exclusiveProcessIdentifier: String? = modelToCopy.exclusiveProcessIdentifier
            let failureCount: UInt = modelToCopy.failureCount
            let label: String = modelToCopy.label
            let sortId: UInt64 = modelToCopy.sortId
            let status: SSKJobRecordStatus = modelToCopy.status
            let contactThreadId: String = modelToCopy.contactThreadId

            return OWSSessionResetJobRecord(grdbId: id,
                                            uniqueId: uniqueId,
                                            exclusiveProcessIdentifier: exclusiveProcessIdentifier,
                                            failureCount: failureCount,
                                            label: label,
                                            sortId: sortId,
                                            status: status,
                                            contactThreadId: contactThreadId)
        }

        if let modelToCopy = self as? OWSSendGiftBadgeJobRecord {
            assert(type(of: modelToCopy) == OWSSendGiftBadgeJobRecord.self)
            let uniqueId: String = modelToCopy.uniqueId
            let exclusiveProcessIdentifier: String? = modelToCopy.exclusiveProcessIdentifier
            let failureCount: UInt = modelToCopy.failureCount
            let label: String = modelToCopy.label
            let sortId: UInt64 = modelToCopy.sortId
            let status: SSKJobRecordStatus = modelToCopy.status
            // NOTE: If this generates build errors, you made need to
            // implement DeepCopyable for this type in DeepCopy.swift.
            let amount: NSDecimalNumber = try DeepCopies.deepCopy(modelToCopy.amount)
            let boostPaymentIntentID: String = modelToCopy.boostPaymentIntentID
            let currencyCode: String = modelToCopy.currencyCode
            let messageText: String = modelToCopy.messageText
            let paymentIntentClientSecret: String = modelToCopy.paymentIntentClientSecret
            let paymentMethodId: String = modelToCopy.paymentMethodId
            let receiptCredentailRequest: Data = modelToCopy.receiptCredentailRequest
            let receiptCredentailRequestContext: Data = modelToCopy.receiptCredentailRequestContext
            let threadId: String = modelToCopy.threadId

            return OWSSendGiftBadgeJobRecord(grdbId: id,
                                             uniqueId: uniqueId,
                                             exclusiveProcessIdentifier: exclusiveProcessIdentifier,
                                             failureCount: failureCount,
                                             label: label,
                                             sortId: sortId,
                                             status: status,
                                             amount: amount,
                                             boostPaymentIntentID: boostPaymentIntentID,
                                             currencyCode: currencyCode,
                                             messageText: messageText,
                                             paymentIntentClientSecret: paymentIntentClientSecret,
                                             paymentMethodId: paymentMethodId,
                                             receiptCredentailRequest: receiptCredentailRequest,
                                             receiptCredentailRequestContext: receiptCredentailRequestContext,
                                             threadId: threadId)
        }

        if let modelToCopy = self as? OWSReceiptCredentialRedemptionJobRecord {
            assert(type(of: modelToCopy) == OWSReceiptCredentialRedemptionJobRecord.self)
            let uniqueId: String = modelToCopy.uniqueId
            let exclusiveProcessIdentifier: String? = modelToCopy.exclusiveProcessIdentifier
            let failureCount: UInt = modelToCopy.failureCount
            let label: String = modelToCopy.label
            let sortId: UInt64 = modelToCopy.sortId
            let status: SSKJobRecordStatus = modelToCopy.status
            // NOTE: If this generates build errors, you made need to
            // modify DeepCopy.swift to support this type.
            //
            // That might mean:
            //
            // * Implement DeepCopyable for this type (e.g. a model).
            // * Modify DeepCopies.deepCopy() to support this type (e.g. a collection).
            let amount: NSDecimalNumber?
            if let amountForCopy = modelToCopy.amount {
               amount = try DeepCopies.deepCopy(amountForCopy)
            } else {
               amount = nil
            }
            let boostPaymentIntentID: String = modelToCopy.boostPaymentIntentID
            let currencyCode: String? = modelToCopy.currencyCode
            let isBoost: Bool = modelToCopy.isBoost
            let priorSubscriptionLevel: UInt = modelToCopy.priorSubscriptionLevel
            let receiptCredentailRequest: Data = modelToCopy.receiptCredentailRequest
            let receiptCredentailRequestContext: Data = modelToCopy.receiptCredentailRequestContext
            let receiptCredentialPresentation: Data? = modelToCopy.receiptCredentialPresentation
            let subscriberID: Data = modelToCopy.subscriberID
            let targetSubscriptionLevel: UInt = modelToCopy.targetSubscriptionLevel

            return OWSReceiptCredentialRedemptionJobRecord(grdbId: id,
                                                           uniqueId: uniqueId,
                                                           exclusiveProcessIdentifier: exclusiveProcessIdentifier,
                                                           failureCount: failureCount,
                                                           label: label,
                                                           sortId: sortId,
                                                           status: status,
                                                           amount: amount,
                                                           boostPaymentIntentID: boostPaymentIntentID,
                                                           currencyCode: currencyCode,
                                                           isBoost: isBoost,
                                                           priorSubscriptionLevel: priorSubscriptionLevel,
                                                           receiptCredentailRequest: receiptCredentailRequest,
                                                           receiptCredentailRequestContext: receiptCredentailRequestContext,
                                                           receiptCredentialPresentation: receiptCredentialPresentation,
                                                           subscriberID: subscriberID,
                                                           targetSubscriptionLevel: targetSubscriptionLevel)
        }

        if let modelToCopy = self as? OWSLocalUserLeaveGroupJobRecord {
            assert(type(of: modelToCopy) == OWSLocalUserLeaveGroupJobRecord.self)
            let uniqueId: String = modelToCopy.uniqueId
            let exclusiveProcessIdentifier: String? = modelToCopy.exclusiveProcessIdentifier
            let failureCount: UInt = modelToCopy.failureCount
            let label: String = modelToCopy.label
            let sortId: UInt64 = modelToCopy.sortId
            let status: SSKJobRecordStatus = modelToCopy.status
            let replacementAdminUuid: String? = modelToCopy.replacementAdminUuid
            let threadId: String = modelToCopy.threadId
            let waitForMessageProcessing: Bool = modelToCopy.waitForMessageProcessing

            return OWSLocalUserLeaveGroupJobRecord(grdbId: id,
                                                   uniqueId: uniqueId,
                                                   exclusiveProcessIdentifier: exclusiveProcessIdentifier,
                                                   failureCount: failureCount,
                                                   label: label,
                                                   sortId: sortId,
                                                   status: status,
                                                   replacementAdminUuid: replacementAdminUuid,
                                                   threadId: threadId,
                                                   waitForMessageProcessing: waitForMessageProcessing)
        }

        if let modelToCopy = self as? OWSIncomingGroupSyncJobRecord {
            assert(type(of: modelToCopy) == OWSIncomingGroupSyncJobRecord.self)
            let uniqueId: String = modelToCopy.uniqueId
            let exclusiveProcessIdentifier: String? = modelToCopy.exclusiveProcessIdentifier
            let failureCount: UInt = modelToCopy.failureCount
            let label: String = modelToCopy.label
            let sortId: UInt64 = modelToCopy.sortId
            let status: SSKJobRecordStatus = modelToCopy.status
            let attachmentId: String = modelToCopy.attachmentId

            return OWSIncomingGroupSyncJobRecord(grdbId: id,
                                                 uniqueId: uniqueId,
                                                 exclusiveProcessIdentifier: exclusiveProcessIdentifier,
                                                 failureCount: failureCount,
                                                 label: label,
                                                 sortId: sortId,
                                                 status: status,
                                                 attachmentId: attachmentId)
        }

        if let modelToCopy = self as? OWSIncomingContactSyncJobRecord {
            assert(type(of: modelToCopy) == OWSIncomingContactSyncJobRecord.self)
            let uniqueId: String = modelToCopy.uniqueId
            let exclusiveProcessIdentifier: String? = modelToCopy.exclusiveProcessIdentifier
            let failureCount: UInt = modelToCopy.failureCount
            let label: String = modelToCopy.label
            let sortId: UInt64 = modelToCopy.sortId
            let status: SSKJobRecordStatus = modelToCopy.status
            let attachmentId: String = modelToCopy.attachmentId
            let isCompleteContactSync: Bool = modelToCopy.isCompleteContactSync

            return OWSIncomingContactSyncJobRecord(grdbId: id,
                                                   uniqueId: uniqueId,
                                                   exclusiveProcessIdentifier: exclusiveProcessIdentifier,
                                                   failureCount: failureCount,
                                                   label: label,
                                                   sortId: sortId,
                                                   status: status,
                                                   attachmentId: attachmentId,
                                                   isCompleteContactSync: isCompleteContactSync)
        }

        if let modelToCopy = self as? OWSBroadcastMediaMessageJobRecord {
            assert(type(of: modelToCopy) == OWSBroadcastMediaMessageJobRecord.self)
            let uniqueId: String = modelToCopy.uniqueId
            let exclusiveProcessIdentifier: String? = modelToCopy.exclusiveProcessIdentifier
            let failureCount: UInt = modelToCopy.failureCount
            let label: String = modelToCopy.label
            let sortId: UInt64 = modelToCopy.sortId
            let status: SSKJobRecordStatus = modelToCopy.status
            // NOTE: If this generates build errors, you made need to
            // implement DeepCopyable for this type in DeepCopy.swift.
            let attachmentIdMap: [String: [String]] = try DeepCopies.deepCopy(modelToCopy.attachmentIdMap)
            // NOTE: If this generates build errors, you made need to
            // modify DeepCopy.swift to support this type.
            //
            // That might mean:
            //
            // * Implement DeepCopyable for this type (e.g. a model).
            // * Modify DeepCopies.deepCopy() to support this type (e.g. a collection).
            let unsavedMessagesToSend: [TSOutgoingMessage]?
            if let unsavedMessagesToSendForCopy = modelToCopy.unsavedMessagesToSend {
               unsavedMessagesToSend = try DeepCopies.deepCopy(unsavedMessagesToSendForCopy)
            } else {
               unsavedMessagesToSend = nil
            }

            return OWSBroadcastMediaMessageJobRecord(grdbId: id,
                                                     uniqueId: uniqueId,
                                                     exclusiveProcessIdentifier: exclusiveProcessIdentifier,
                                                     failureCount: failureCount,
                                                     label: label,
                                                     sortId: sortId,
                                                     status: status,
                                                     attachmentIdMap: attachmentIdMap,
                                                     unsavedMessagesToSend: unsavedMessagesToSend)
        }

        do {
            let modelToCopy = self
            assert(type(of: modelToCopy) == SSKJobRecord.self)
            let uniqueId: String = modelToCopy.uniqueId
            let exclusiveProcessIdentifier: String? = modelToCopy.exclusiveProcessIdentifier
            let failureCount: UInt = modelToCopy.failureCount
            let label: String = modelToCopy.label
            let sortId: UInt64 = modelToCopy.sortId
            let status: SSKJobRecordStatus = modelToCopy.status

            return SSKJobRecord(grdbId: id,
                                uniqueId: uniqueId,
                                exclusiveProcessIdentifier: exclusiveProcessIdentifier,
                                failureCount: failureCount,
                                label: label,
                                sortId: sortId,
                                status: status)
        }

    }
}

// MARK: - Table Metadata

extension SSKJobRecordSerializer {

    // This defines all of the columns used in the table
    // where this model (and any subclasses) are persisted.
    static var idColumn: SDSColumnMetadata { SDSColumnMetadata(columnName: "id", columnType: .primaryKey) }
    static var recordTypeColumn: SDSColumnMetadata { SDSColumnMetadata(columnName: "recordType", columnType: .int64) }
    static var uniqueIdColumn: SDSColumnMetadata { SDSColumnMetadata(columnName: "uniqueId", columnType: .unicodeString, isUnique: true) }
    // Properties
    static var failureCountColumn: SDSColumnMetadata { SDSColumnMetadata(columnName: "failureCount", columnType: .int64) }
    static var labelColumn: SDSColumnMetadata { SDSColumnMetadata(columnName: "label", columnType: .unicodeString) }
    static var statusColumn: SDSColumnMetadata { SDSColumnMetadata(columnName: "status", columnType: .int) }
    static var attachmentIdMapColumn: SDSColumnMetadata { SDSColumnMetadata(columnName: "attachmentIdMap", columnType: .blob, isOptional: true) }
    static var contactThreadIdColumn: SDSColumnMetadata { SDSColumnMetadata(columnName: "contactThreadId", columnType: .unicodeString, isOptional: true) }
    static var envelopeDataColumn: SDSColumnMetadata { SDSColumnMetadata(columnName: "envelopeData", columnType: .blob, isOptional: true) }
    static var invisibleMessageColumn: SDSColumnMetadata { SDSColumnMetadata(columnName: "invisibleMessage", columnType: .blob, isOptional: true) }
    static var messageIdColumn: SDSColumnMetadata { SDSColumnMetadata(columnName: "messageId", columnType: .unicodeString, isOptional: true) }
    static var removeMessageAfterSendingColumn: SDSColumnMetadata { SDSColumnMetadata(columnName: "removeMessageAfterSending", columnType: .int, isOptional: true) }
    static var threadIdColumn: SDSColumnMetadata { SDSColumnMetadata(columnName: "threadId", columnType: .unicodeString, isOptional: true) }
    static var attachmentIdColumn: SDSColumnMetadata { SDSColumnMetadata(columnName: "attachmentId", columnType: .unicodeString, isOptional: true) }
    static var isMediaMessageColumn: SDSColumnMetadata { SDSColumnMetadata(columnName: "isMediaMessage", columnType: .int, isOptional: true) }
    static var serverDeliveryTimestampColumn: SDSColumnMetadata { SDSColumnMetadata(columnName: "serverDeliveryTimestamp", columnType: .int64, isOptional: true) }
    static var exclusiveProcessIdentifierColumn: SDSColumnMetadata { SDSColumnMetadata(columnName: "exclusiveProcessIdentifier", columnType: .unicodeString, isOptional: true) }
    static var isHighPriorityColumn: SDSColumnMetadata { SDSColumnMetadata(columnName: "isHighPriority", columnType: .int, isOptional: true) }
    static var receiptCredentailRequestColumn: SDSColumnMetadata { SDSColumnMetadata(columnName: "receiptCredentailRequest", columnType: .blob, isOptional: true) }
    static var receiptCredentailRequestContextColumn: SDSColumnMetadata { SDSColumnMetadata(columnName: "receiptCredentailRequestContext", columnType: .blob, isOptional: true) }
    static var priorSubscriptionLevelColumn: SDSColumnMetadata { SDSColumnMetadata(columnName: "priorSubscriptionLevel", columnType: .int64, isOptional: true) }
    static var subscriberIDColumn: SDSColumnMetadata { SDSColumnMetadata(columnName: "subscriberID", columnType: .blob, isOptional: true) }
    static var targetSubscriptionLevelColumn: SDSColumnMetadata { SDSColumnMetadata(columnName: "targetSubscriptionLevel", columnType: .int64, isOptional: true) }
    static var boostPaymentIntentIDColumn: SDSColumnMetadata { SDSColumnMetadata(columnName: "boostPaymentIntentID", columnType: .unicodeString, isOptional: true) }
    static var isBoostColumn: SDSColumnMetadata { SDSColumnMetadata(columnName: "isBoost", columnType: .int, isOptional: true) }
    static var receiptCredentialPresentationColumn: SDSColumnMetadata { SDSColumnMetadata(columnName: "receiptCredentialPresentation", columnType: .blob, isOptional: true) }
    static var amountColumn: SDSColumnMetadata { SDSColumnMetadata(columnName: "amount", columnType: .blob, isOptional: true) }
    static var currencyCodeColumn: SDSColumnMetadata { SDSColumnMetadata(columnName: "currencyCode", columnType: .unicodeString, isOptional: true) }
    static var unsavedMessagesToSendColumn: SDSColumnMetadata { SDSColumnMetadata(columnName: "unsavedMessagesToSend", columnType: .blob, isOptional: true) }
    static var messageTextColumn: SDSColumnMetadata { SDSColumnMetadata(columnName: "messageText", columnType: .unicodeString, isOptional: true) }
    static var paymentIntentClientSecretColumn: SDSColumnMetadata { SDSColumnMetadata(columnName: "paymentIntentClientSecret", columnType: .unicodeString, isOptional: true) }
    static var paymentMethodIdColumn: SDSColumnMetadata { SDSColumnMetadata(columnName: "paymentMethodId", columnType: .unicodeString, isOptional: true) }
    static var replacementAdminUuidColumn: SDSColumnMetadata { SDSColumnMetadata(columnName: "replacementAdminUuid", columnType: .unicodeString, isOptional: true) }
    static var waitForMessageProcessingColumn: SDSColumnMetadata { SDSColumnMetadata(columnName: "waitForMessageProcessing", columnType: .int, isOptional: true) }
    static var isCompleteContactSyncColumn: SDSColumnMetadata { SDSColumnMetadata(columnName: "isCompleteContactSync", columnType: .int, isOptional: true) }

    // TODO: We should decide on a naming convention for
    //       tables that store models.
    public static var table: SDSTableMetadata {
        SDSTableMetadata(collection: SSKJobRecord.collection(),
                         tableName: "model_SSKJobRecord",
                         columns: [
        idColumn,
        recordTypeColumn,
        uniqueIdColumn,
        failureCountColumn,
        labelColumn,
        statusColumn,
        attachmentIdMapColumn,
        contactThreadIdColumn,
        envelopeDataColumn,
        invisibleMessageColumn,
        messageIdColumn,
        removeMessageAfterSendingColumn,
        threadIdColumn,
        attachmentIdColumn,
        isMediaMessageColumn,
        serverDeliveryTimestampColumn,
        exclusiveProcessIdentifierColumn,
        isHighPriorityColumn,
        receiptCredentailRequestColumn,
        receiptCredentailRequestContextColumn,
        priorSubscriptionLevelColumn,
        subscriberIDColumn,
        targetSubscriptionLevelColumn,
        boostPaymentIntentIDColumn,
        isBoostColumn,
        receiptCredentialPresentationColumn,
        amountColumn,
        currencyCodeColumn,
        unsavedMessagesToSendColumn,
        messageTextColumn,
        paymentIntentClientSecretColumn,
        paymentMethodIdColumn,
        replacementAdminUuidColumn,
        waitForMessageProcessingColumn,
        isCompleteContactSyncColumn
        ])
    }
}

// MARK: - Save/Remove/Update

@objc
public extension SSKJobRecord {
    func anyInsert(transaction: SDSAnyWriteTransaction) {
        sdsSave(saveMode: .insert, transaction: transaction)
    }

    // Avoid this method whenever feasible.
    //
    // If the record has previously been saved, this method does an overwriting
    // update of the corresponding row, otherwise if it's a new record, this
    // method inserts a new row.
    //
    // For performance, when possible, you should explicitly specify whether
    // you are inserting or updating rather than calling this method.
    func anyUpsert(transaction: SDSAnyWriteTransaction) {
        let isInserting: Bool
        if SSKJobRecord.anyFetch(uniqueId: uniqueId, transaction: transaction) != nil {
            isInserting = false
        } else {
            isInserting = true
        }
        sdsSave(saveMode: isInserting ? .insert : .update, transaction: transaction)
    }

    // This method is used by "updateWith..." methods.
    //
    // This model may be updated from many threads. We don't want to save
    // our local copy (this instance) since it may be out of date.  We also
    // want to avoid re-saving a model that has been deleted.  Therefore, we
    // use "updateWith..." methods to:
    //
    // a) Update a property of this instance.
    // b) If a copy of this model exists in the database, load an up-to-date copy,
    //    and update and save that copy.
    // b) If a copy of this model _DOES NOT_ exist in the database, do _NOT_ save
    //    this local instance.
    //
    // After "updateWith...":
    //
    // a) Any copy of this model in the database will have been updated.
    // b) The local property on this instance will always have been updated.
    // c) Other properties on this instance may be out of date.
    //
    // All mutable properties of this class have been made read-only to
    // prevent accidentally modifying them directly.
    //
    // This isn't a perfect arrangement, but in practice this will prevent
    // data loss and will resolve all known issues.
    func anyUpdate(transaction: SDSAnyWriteTransaction, block: (SSKJobRecord) -> Void) {

        block(self)

        guard let dbCopy = type(of: self).anyFetch(uniqueId: uniqueId,
                                                   transaction: transaction) else {
            return
        }

        // Don't apply the block twice to the same instance.
        // It's at least unnecessary and actually wrong for some blocks.
        // e.g. `block: { $0 in $0.someField++ }`
        if dbCopy !== self {
            block(dbCopy)
        }

        dbCopy.sdsSave(saveMode: .update, transaction: transaction)
    }

    // This method is an alternative to `anyUpdate(transaction:block:)` methods.
    //
    // We should generally use `anyUpdate` to ensure we're not unintentionally
    // clobbering other columns in the database when another concurrent update
    // has occurred.
    //
    // There are cases when this doesn't make sense, e.g. when  we know we've
    // just loaded the model in the same transaction. In those cases it is
    // safe and faster to do a "overwriting" update
    func anyOverwritingUpdate(transaction: SDSAnyWriteTransaction) {
        sdsSave(saveMode: .update, transaction: transaction)
    }

    func anyRemove(transaction: SDSAnyWriteTransaction) {
        sdsRemove(transaction: transaction)
    }

    func anyReload(transaction: SDSAnyReadTransaction) {
        anyReload(transaction: transaction, ignoreMissing: false)
    }

    func anyReload(transaction: SDSAnyReadTransaction, ignoreMissing: Bool) {
        guard let latestVersion = type(of: self).anyFetch(uniqueId: uniqueId, transaction: transaction) else {
            if !ignoreMissing {
                owsFailDebug("`latest` was unexpectedly nil")
            }
            return
        }

        setValuesForKeys(latestVersion.dictionaryValue)
    }
}

// MARK: - SSKJobRecordCursor

@objc
public class SSKJobRecordCursor: NSObject, SDSCursor {
    private let transaction: GRDBReadTransaction
    private let cursor: RecordCursor<JobRecordRecord>?

    init(transaction: GRDBReadTransaction, cursor: RecordCursor<JobRecordRecord>?) {
        self.transaction = transaction
        self.cursor = cursor
    }

    public func next() throws -> SSKJobRecord? {
        guard let cursor = cursor else {
            return nil
        }
        guard let record = try cursor.next() else {
            return nil
        }
        return try SSKJobRecord.fromRecord(record)
    }

    public func all() throws -> [SSKJobRecord] {
        var result = [SSKJobRecord]()
        while true {
            guard let model = try next() else {
                break
            }
            result.append(model)
        }
        return result
    }
}

// MARK: - Obj-C Fetch

// TODO: We may eventually want to define some combination of:
//
// * fetchCursor, fetchOne, fetchAll, etc. (ala GRDB)
// * Optional "where clause" parameters for filtering.
// * Async flavors with completions.
//
// TODO: I've defined flavors that take a read transaction.
//       Or we might take a "connection" if we end up having that class.
@objc
public extension SSKJobRecord {
    class func grdbFetchCursor(transaction: GRDBReadTransaction) -> SSKJobRecordCursor {
        let database = transaction.database
        do {
            let cursor = try JobRecordRecord.fetchCursor(database)
            return SSKJobRecordCursor(transaction: transaction, cursor: cursor)
        } catch {
            owsFailDebug("Read failed: \(error)")
            return SSKJobRecordCursor(transaction: transaction, cursor: nil)
        }
    }

    // Fetches a single model by "unique id".
    class func anyFetch(uniqueId: String,
                        transaction: SDSAnyReadTransaction) -> SSKJobRecord? {
        assert(!uniqueId.isEmpty)

        switch transaction.readTransaction {
        case .grdbRead(let grdbTransaction):
            let sql = "SELECT * FROM \(JobRecordRecord.databaseTableName) WHERE \(jobRecordColumn: .uniqueId) = ?"
            return grdbFetchOne(sql: sql, arguments: [uniqueId], transaction: grdbTransaction)
        }
    }

    // Traverses all records.
    // Records are not visited in any particular order.
    class func anyEnumerate(transaction: SDSAnyReadTransaction,
                            block: @escaping (SSKJobRecord, UnsafeMutablePointer<ObjCBool>) -> Void) {
        anyEnumerate(transaction: transaction, batched: false, block: block)
    }

    // Traverses all records.
    // Records are not visited in any particular order.
    class func anyEnumerate(transaction: SDSAnyReadTransaction,
                            batched: Bool = false,
                            block: @escaping (SSKJobRecord, UnsafeMutablePointer<ObjCBool>) -> Void) {
        let batchSize = batched ? Batching.kDefaultBatchSize : 0
        anyEnumerate(transaction: transaction, batchSize: batchSize, block: block)
    }

    // Traverses all records.
    // Records are not visited in any particular order.
    //
    // If batchSize > 0, the enumeration is performed in autoreleased batches.
    class func anyEnumerate(transaction: SDSAnyReadTransaction,
                            batchSize: UInt,
                            block: @escaping (SSKJobRecord, UnsafeMutablePointer<ObjCBool>) -> Void) {
        switch transaction.readTransaction {
        case .grdbRead(let grdbTransaction):
            let cursor = SSKJobRecord.grdbFetchCursor(transaction: grdbTransaction)
            Batching.loop(batchSize: batchSize,
                          loopBlock: { stop in
                                do {
                                    guard let value = try cursor.next() else {
                                        stop.pointee = true
                                        return
                                    }
                                    block(value, stop)
                                } catch let error {
                                    owsFailDebug("Couldn't fetch model: \(error)")
                                }
                              })
        }
    }

    // Traverses all records' unique ids.
    // Records are not visited in any particular order.
    class func anyEnumerateUniqueIds(transaction: SDSAnyReadTransaction,
                                     block: @escaping (String, UnsafeMutablePointer<ObjCBool>) -> Void) {
        anyEnumerateUniqueIds(transaction: transaction, batched: false, block: block)
    }

    // Traverses all records' unique ids.
    // Records are not visited in any particular order.
    class func anyEnumerateUniqueIds(transaction: SDSAnyReadTransaction,
                                     batched: Bool = false,
                                     block: @escaping (String, UnsafeMutablePointer<ObjCBool>) -> Void) {
        let batchSize = batched ? Batching.kDefaultBatchSize : 0
        anyEnumerateUniqueIds(transaction: transaction, batchSize: batchSize, block: block)
    }

    // Traverses all records' unique ids.
    // Records are not visited in any particular order.
    //
    // If batchSize > 0, the enumeration is performed in autoreleased batches.
    class func anyEnumerateUniqueIds(transaction: SDSAnyReadTransaction,
                                     batchSize: UInt,
                                     block: @escaping (String, UnsafeMutablePointer<ObjCBool>) -> Void) {
        switch transaction.readTransaction {
        case .grdbRead(let grdbTransaction):
            grdbEnumerateUniqueIds(transaction: grdbTransaction,
                                   sql: """
                    SELECT \(jobRecordColumn: .uniqueId)
                    FROM \(JobRecordRecord.databaseTableName)
                """,
                batchSize: batchSize,
                block: block)
        }
    }

    // Does not order the results.
    class func anyFetchAll(transaction: SDSAnyReadTransaction) -> [SSKJobRecord] {
        var result = [SSKJobRecord]()
        anyEnumerate(transaction: transaction) { (model, _) in
            result.append(model)
        }
        return result
    }

    // Does not order the results.
    class func anyAllUniqueIds(transaction: SDSAnyReadTransaction) -> [String] {
        var result = [String]()
        anyEnumerateUniqueIds(transaction: transaction) { (uniqueId, _) in
            result.append(uniqueId)
        }
        return result
    }

    class func anyCount(transaction: SDSAnyReadTransaction) -> UInt {
        switch transaction.readTransaction {
        case .grdbRead(let grdbTransaction):
            return JobRecordRecord.ows_fetchCount(grdbTransaction.database)
        }
    }

    // WARNING: Do not use this method for any models which do cleanup
    //          in their anyWillRemove(), anyDidRemove() methods.
    class func anyRemoveAllWithoutInstantation(transaction: SDSAnyWriteTransaction) {
        switch transaction.writeTransaction {
        case .grdbWrite(let grdbTransaction):
            do {
                try JobRecordRecord.deleteAll(grdbTransaction.database)
            } catch {
                owsFailDebug("deleteAll() failed: \(error)")
            }
        }

        if ftsIndexMode != .never {
            FullTextSearchFinder.allModelsWereRemoved(collection: collection(), transaction: transaction)
        }
    }

    class func anyRemoveAllWithInstantation(transaction: SDSAnyWriteTransaction) {
        // To avoid mutationDuringEnumerationException, we need
        // to remove the instances outside the enumeration.
        let uniqueIds = anyAllUniqueIds(transaction: transaction)

        var index: Int = 0
        Batching.loop(batchSize: Batching.kDefaultBatchSize,
                      loopBlock: { stop in
            guard index < uniqueIds.count else {
                stop.pointee = true
                return
            }
            let uniqueId = uniqueIds[index]
            index += 1
            guard let instance = anyFetch(uniqueId: uniqueId, transaction: transaction) else {
                owsFailDebug("Missing instance.")
                return
            }
            instance.anyRemove(transaction: transaction)
        })

        if ftsIndexMode != .never {
            FullTextSearchFinder.allModelsWereRemoved(collection: collection(), transaction: transaction)
        }
    }

    class func anyExists(
        uniqueId: String,
        transaction: SDSAnyReadTransaction
    ) -> Bool {
        assert(!uniqueId.isEmpty)

        switch transaction.readTransaction {
        case .grdbRead(let grdbTransaction):
            let sql = "SELECT EXISTS ( SELECT 1 FROM \(JobRecordRecord.databaseTableName) WHERE \(jobRecordColumn: .uniqueId) = ? )"
            let arguments: StatementArguments = [uniqueId]
            return try! Bool.fetchOne(grdbTransaction.database, sql: sql, arguments: arguments) ?? false
        }
    }
}

// MARK: - Swift Fetch

public extension SSKJobRecord {
    class func grdbFetchCursor(sql: String,
                               arguments: StatementArguments = StatementArguments(),
                               transaction: GRDBReadTransaction) -> SSKJobRecordCursor {
        do {
            let sqlRequest = SQLRequest<Void>(sql: sql, arguments: arguments, cached: true)
            let cursor = try JobRecordRecord.fetchCursor(transaction.database, sqlRequest)
            return SSKJobRecordCursor(transaction: transaction, cursor: cursor)
        } catch {
            Logger.verbose("sql: \(sql)")
            owsFailDebug("Read failed: \(error)")
            return SSKJobRecordCursor(transaction: transaction, cursor: nil)
        }
    }

    class func grdbFetchOne(sql: String,
                            arguments: StatementArguments = StatementArguments(),
                            transaction: GRDBReadTransaction) -> SSKJobRecord? {
        assert(!sql.isEmpty)

        do {
            let sqlRequest = SQLRequest<Void>(sql: sql, arguments: arguments, cached: true)
            guard let record = try JobRecordRecord.fetchOne(transaction.database, sqlRequest) else {
                return nil
            }

            return try SSKJobRecord.fromRecord(record)
        } catch {
            owsFailDebug("error: \(error)")
            return nil
        }
    }
}

// MARK: - SDSSerializer

// The SDSSerializer protocol specifies how to insert and update the
// row that corresponds to this model.
class SSKJobRecordSerializer: SDSSerializer {

    private let model: SSKJobRecord
    public required init(model: SSKJobRecord) {
        self.model = model
    }

    // MARK: - Record

    func asRecord() throws -> SDSRecord {
        let id: Int64? = model.sortId > 0 ? Int64(model.sortId) : model.grdbId?.int64Value

        let recordType: SDSRecordType = .jobRecord
        let uniqueId: String = model.uniqueId

        // Properties
        let failureCount: UInt = model.failureCount
        let label: String = model.label
        let status: SSKJobRecordStatus = model.status
        let attachmentIdMap: Data? = nil
        let contactThreadId: String? = nil
        let envelopeData: Data? = nil
        let invisibleMessage: Data? = nil
        let messageId: String? = nil
        let removeMessageAfterSending: Bool? = nil
        let threadId: String? = nil
        let attachmentId: String? = nil
        let isMediaMessage: Bool? = nil
        let serverDeliveryTimestamp: UInt64? = nil
        let exclusiveProcessIdentifier: String? = model.exclusiveProcessIdentifier
        let isHighPriority: Bool? = nil
        let receiptCredentailRequest: Data? = nil
        let receiptCredentailRequestContext: Data? = nil
        let priorSubscriptionLevel: UInt? = nil
        let subscriberID: Data? = nil
        let targetSubscriptionLevel: UInt? = nil
        let boostPaymentIntentID: String? = nil
        let isBoost: Bool? = nil
        let receiptCredentialPresentation: Data? = nil
        let amount: Data? = nil
        let currencyCode: String? = nil
        let unsavedMessagesToSend: Data? = nil
        let messageText: String? = nil
        let paymentIntentClientSecret: String? = nil
        let paymentMethodId: String? = nil
        let replacementAdminUuid: String? = nil
        let waitForMessageProcessing: Bool? = nil
        let isCompleteContactSync: Bool? = nil

        return JobRecordRecord(delegate: model, id: id, recordType: recordType, uniqueId: uniqueId, failureCount: failureCount, label: label, status: status, attachmentIdMap: attachmentIdMap, contactThreadId: contactThreadId, envelopeData: envelopeData, invisibleMessage: invisibleMessage, messageId: messageId, removeMessageAfterSending: removeMessageAfterSending, threadId: threadId, attachmentId: attachmentId, isMediaMessage: isMediaMessage, serverDeliveryTimestamp: serverDeliveryTimestamp, exclusiveProcessIdentifier: exclusiveProcessIdentifier, isHighPriority: isHighPriority, receiptCredentailRequest: receiptCredentailRequest, receiptCredentailRequestContext: receiptCredentailRequestContext, priorSubscriptionLevel: priorSubscriptionLevel, subscriberID: subscriberID, targetSubscriptionLevel: targetSubscriptionLevel, boostPaymentIntentID: boostPaymentIntentID, isBoost: isBoost, receiptCredentialPresentation: receiptCredentialPresentation, amount: amount, currencyCode: currencyCode, unsavedMessagesToSend: unsavedMessagesToSend, messageText: messageText, paymentIntentClientSecret: paymentIntentClientSecret, paymentMethodId: paymentMethodId, replacementAdminUuid: replacementAdminUuid, waitForMessageProcessing: waitForMessageProcessing, isCompleteContactSync: isCompleteContactSync)
    }
}

// MARK: - Deep Copy

#if TESTABLE_BUILD
@objc
public extension SSKJobRecord {
    // We're not using this method at the moment,
    // but we might use it for validation of
    // other deep copy methods.
    func deepCopyUsingRecord() throws -> SSKJobRecord {
        guard let record = try asRecord() as? JobRecordRecord else {
            throw OWSAssertionError("Could not convert to record.")
        }
        return try SSKJobRecord.fromRecord(record)
    }
}
#endif
