//
//  Copyright (c) 2020 Open Whisper Systems. All rights reserved.
//

#import "GroupsV2MessageProcessor.h"
#import "AppContext.h"
#import "AppReadiness.h"
#import "NSArray+OWS.h"
#import "NotificationsProtocol.h"
#import "OWSBackgroundTask.h"
#import "OWSBlockingManager.h"
#import "OWSMessageManager.h"
#import "OWSQueues.h"
#import "OWSWebSocket.h"
#import "SSKEnvironment.h"
#import "TSAccountManager.h"
#import "TSErrorMessage.h"
#import <Reachability/Reachability.h>
#import <SignalCoreKit/Threading.h>
#import <SignalServiceKit/SignalServiceKit-Swift.h>

NS_ASSUME_NONNULL_BEGIN

@interface GroupsV2MessageProcessor ()

+ (nullable SSKProtoGroupContextV2 *)groupContextV2ForEnvelope:(nullable SSKProtoEnvelope *)envelope
                                                 plaintextData:(nullable NSData *)plaintextData;

@end

#pragma mark -

@implementation IncomingGroupsV2MessageJob

+ (NSString *)collection
{
    return @"IncomingGroupsV2MessageJob";
}

- (instancetype)initWithEnvelopeData:(NSData *)envelopeData
                       plaintextData:(NSData *_Nullable)plaintextData
                     wasReceivedByUD:(BOOL)wasReceivedByUD
{
    OWSAssertDebug(envelopeData);

    self = [super init];
    if (!self) {
        return self;
    }

    _envelopeData = envelopeData;
    _plaintextData = plaintextData;
    _wasReceivedByUD = wasReceivedByUD;
    _createdAt = [NSDate new];

    return self;
}

// --- CODE GENERATION MARKER

// This snippet is generated by /Scripts/sds_codegen/sds_generate.py. Do not manually edit it, instead run
// `sds_codegen.sh`.

// clang-format off

- (instancetype)initWithGrdbId:(int64_t)grdbId
                      uniqueId:(NSString *)uniqueId
                       createdAt:(NSDate *)createdAt
                    envelopeData:(NSData *)envelopeData
                   plaintextData:(nullable NSData *)plaintextData
                 wasReceivedByUD:(BOOL)wasReceivedByUD
{
    self = [super initWithGrdbId:grdbId
                        uniqueId:uniqueId];

    if (!self) {
        return self;
    }

    _createdAt = createdAt;
    _envelopeData = envelopeData;
    _plaintextData = plaintextData;
    _wasReceivedByUD = wasReceivedByUD;

    return self;
}

// clang-format on

// --- CODE GENERATION MARKER

- (nullable instancetype)initWithCoder:(NSCoder *)coder
{
    return [super initWithCoder:coder];
}

- (nullable SSKProtoEnvelope *)envelope
{
    NSError *error;
    SSKProtoEnvelope *_Nullable result = [SSKProtoEnvelope parseData:self.envelopeData error:&error];

    if (error) {
        OWSFailDebug(@"paring SSKProtoEnvelope failed with error: %@", error);
        return nil;
    }

    return result;
}

@end

#pragma mark -

@interface IncomingGroupsV2MessageJobInfo : NSObject

@property (nonatomic) IncomingGroupsV2MessageJob *job;
@property (nonatomic, nullable) SSKProtoEnvelope *envelope;
@property (nonatomic, nullable) SSKProtoGroupContextV2 *groupContext;
@property (nonatomic, nullable) GroupV2ContextInfo *_Nullable groupContextInfo;

@end

#pragma mark -

@implementation IncomingGroupsV2MessageJobInfo

@end

#pragma mark - Queue Processing

@interface IncomingGroupsV2MessageQueue : NSObject

@property (nonatomic, readonly) GRDBGroupsV2MessageJobFinder *finder;
@property (nonatomic) BOOL isDrainingQueue;
@property (atomic) BOOL isAppInBackground;
@property (nonatomic, readonly) Reachability *reachability;

@end

#pragma mark -

typedef void (^BatchCompletionBlock)(NSArray<IncomingGroupsV2MessageJob *> *, SDSAnyWriteTransaction *transaction);

@implementation IncomingGroupsV2MessageQueue

- (instancetype)init
{
    OWSSingletonAssert();

    self = [super init];
    if (!self) {
        return self;
    }

    _finder = [GRDBGroupsV2MessageJobFinder new];
    _isDrainingQueue = NO;
    _reachability = [Reachability reachabilityForInternetConnection];

    [[NSNotificationCenter defaultCenter] addObserver:self
                                             selector:@selector(applicationWillEnterForeground:)
                                                 name:OWSApplicationWillEnterForegroundNotification
                                               object:nil];
    [[NSNotificationCenter defaultCenter] addObserver:self
                                             selector:@selector(applicationDidEnterBackground:)
                                                 name:OWSApplicationDidEnterBackgroundNotification
                                               object:nil];
    [[NSNotificationCenter defaultCenter] addObserver:self
                                             selector:@selector(registrationStateDidChange:)
                                                 name:RegistrationStateDidChangeNotification
                                               object:nil];
    [[NSNotificationCenter defaultCenter] addObserver:self
                                             selector:@selector(socketStateDidChange:)
                                                 name:kNSNotification_OWSWebSocketStateDidChange
                                               object:nil];
    [[NSNotificationCenter defaultCenter] addObserver:self
                                             selector:@selector(reachabilityChanged:)
                                                 name:kReachabilityChangedNotification
                                               object:nil];

    // Start processing.
    [self drainQueueWhenMainAppIsReady];

    return self;
}

#pragma mark - Dependencies

- (OWSMessageManager *)messageManager
{
    OWSAssertDebug(SSKEnvironment.shared.messageManager);

    return SSKEnvironment.shared.messageManager;
}

- (TSAccountManager *)tsAccountManager
{
    OWSAssertDebug(SSKEnvironment.shared.tsAccountManager);

    return SSKEnvironment.shared.tsAccountManager;
}

- (SDSDatabaseStorage *)databaseStorage
{
    return SDSDatabaseStorage.shared;
}

- (id<GroupsV2>)groupsV2
{
    return SSKEnvironment.shared.groupsV2;
}

- (OWSBlockingManager *)blockingManager
{
    return SSKEnvironment.shared.blockingManager;
}

#pragma mark - Notifications

- (void)applicationWillEnterForeground:(NSNotification *)notification
{
    self.isAppInBackground = NO;
}

- (void)applicationDidEnterBackground:(NSNotification *)notification
{
    self.isAppInBackground = YES;
}

- (void)registrationStateDidChange:(NSNotification *)notification
{
    OWSAssertIsOnMainThread();

    [self drainQueueWhenMainAppIsReady];
}

- (void)socketStateDidChange:(NSNotification *)notification
{
    OWSAssertIsOnMainThread();

    [self drainQueueWhenMainAppIsReady];
}

- (void)reachabilityChanged:(NSNotification *)notification
{
    OWSAssertIsOnMainThread();

    [self drainQueueWhenMainAppIsReady];
}

#pragma mark - instance methods

- (dispatch_queue_t)serialQueue
{
    static dispatch_queue_t queue = nil;
    static dispatch_once_t onceToken;
    dispatch_once(&onceToken, ^{
        queue = dispatch_queue_create("org.whispersystems.message.groupv2", DISPATCH_QUEUE_SERIAL);
    });
    return queue;
}

- (void)enqueueEnvelopeData:(NSData *)envelopeData
              plaintextData:(NSData *_Nullable)plaintextData
            wasReceivedByUD:(BOOL)wasReceivedByUD
                transaction:(SDSAnyWriteTransaction *)transaction
{
    OWSAssertDebug(envelopeData);
    OWSAssertDebug(transaction);

    if (!SSKFeatureFlags.incomingGroupsV2) {
        // Discard envelope.
        return;
    }

    // We need to persist the decrypted envelope data ASAP to prevent data loss.
    [self.finder addJobWithEnvelopeData:envelopeData
                          plaintextData:plaintextData
                        wasReceivedByUD:wasReceivedByUD
                            transaction:transaction];
}

//} else if (!self.reachability.isReachable) {

- (void)drainQueueWhenMainAppIsReady
{
    // TODO: We'll need to reconcile the "isMainApp" checks
    // in this class with the "observe message processing"
    // changes.
    if (!CurrentAppContext().isMainApp) {
        return;
    }
    [AppReadiness runNowOrWhenAppDidBecomeReady:^{
        [self drainQueue];
    }];
}

- (void)drainQueue
{
    OWSAssertDebugUnlessRunningTests(AppReadiness.isAppReady);

    // Don't process incoming messages in app extensions.
    if (!CurrentAppContext().isMainApp) {
        OWSFailDebug(@"Not main app.");
        return;
    }
    if (!AppReadiness.isAppReady) {
        OWSFailDebug(@"App is not ready.");
        return;
    }
    if (!self.tsAccountManager.isRegisteredAndReady) {
        return;
    }

    dispatch_async(self.serialQueue, ^{
        if (self.isDrainingQueue) {
            return;
        }
        self.isDrainingQueue = YES;

        [self drainQueueWorkStep];
    });
}

- (void)drainQueueWorkStep
{
    AssertOnDispatchQueue(self.serialQueue);

    if (SSKFeatureFlags.suppressBackgroundActivity) {
        // Don't process queues.
        return;
    }

    // We want a value that is just high enough to yield perf benefits.
    const NSUInteger kIncomingMessageBatchSize = 32;
    // If the app is in the background, use batch size of 1.
    // This reduces the cost of being interrupted and rolled back if
    // app is suspended.
    NSUInteger batchSize = self.isAppInBackground ? 1 : kIncomingMessageBatchSize;

    __block NSArray<IncomingGroupsV2MessageJob *> *batchJobs;
    [self.databaseStorage readWithBlock:^(SDSAnyReadTransaction *transaction) {
        batchJobs = [self.finder nextJobsWithBatchSize:batchSize transaction:transaction];
    }];
    OWSAssertDebug(batchJobs);
    if (batchJobs.count < 1) {
        self.isDrainingQueue = NO;
        OWSLogVerbose(@"Queue is drained");
        return;
    }

    __block OWSBackgroundTask *_Nullable backgroundTask =
        [OWSBackgroundTask backgroundTaskWithLabelStr:__PRETTY_FUNCTION__];

    [self.databaseStorage writeWithBlock:^(SDSAnyWriteTransaction *outerTransaction) {
        [self processJobs:batchJobs
              transaction:outerTransaction
               completion:^(NSArray<IncomingGroupsV2MessageJob *> *processedJobs,
                   SDSAnyWriteTransaction *completionTransaction) {
                   // NOTE: completionTransaction is the same transaction as outerTransaction
                   //       in the "sync" case but a different transaction in the "async" case.
                   [self.finder removeJobsWithUniqueIds:processedJobs.uniqueIds transaction:completionTransaction];

                   NSUInteger jobCount = [self.finder jobCountWithTransaction:completionTransaction];

                   OWSLogVerbose(@"completed %lu/%lu jobs. %lu jobs left.",
                       (unsigned long)processedJobs.count,
                       (unsigned long)batchJobs.count,
                       (unsigned long)jobCount);

                   [completionTransaction addAsyncCompletion:^{
                       OWSAssertDebug(backgroundTask);
                       backgroundTask = nil;

                       // Wait a bit in hopes of increasing the batch size.
                       // This delay won't affect the first message to arrive when this queue is idle,
                       // so by definition we're receiving more than one message and can benefit from
                       // batching.
                       dispatch_after(
                           dispatch_time(DISPATCH_TIME_NOW, (int64_t)(0.5f * NSEC_PER_SEC)), self.serialQueue, ^{
                               [self drainQueueWorkStep];
                           });
                   }];
               }];
    }];
}

- (IncomingGroupsV2MessageJobInfo *)jobInfoForJob:(IncomingGroupsV2MessageJob *)job
                                      transaction:(SDSAnyReadTransaction *)transaction
{
    IncomingGroupsV2MessageJobInfo *jobInfo = [IncomingGroupsV2MessageJobInfo new];
    jobInfo.job = job;
    jobInfo.envelope = job.envelope;
    if (jobInfo.envelope == nil) {
        OWSFailDebug(@"Missing envelope.");
        return jobInfo;
    }
    jobInfo.groupContext = [GroupsV2MessageProcessor groupContextV2ForEnvelope:jobInfo.envelope
                                                                 plaintextData:job.plaintextData];
    if (jobInfo.groupContext == nil) {
        OWSFailDebug(@"Missing group context.");
        return jobInfo;
    }
    NSError *_Nullable error;
    jobInfo.groupContextInfo = [self.groupsV2 groupV2ContextInfoForMasterKeyData:jobInfo.groupContext.masterKey
                                                                           error:&error];
    if (error != nil || jobInfo.groupContextInfo == nil) {
        OWSFailDebug(@"Invalid group context.");
        return jobInfo;
    }

    return jobInfo;
}

- (BOOL)canJobBeDiscarded:(IncomingGroupsV2MessageJobInfo *)jobInfo
    ignoreIfNotLocalMember:(BOOL)ignoreIfNotLocalMember
               transaction:(SDSAnyReadTransaction *)transaction
{
    // We want to discard asap to avoid problems with batching.
    if (jobInfo.envelope == nil || jobInfo.groupContext == nil || jobInfo.groupContextInfo == nil) {
        OWSFailDebug(@"Invalid job.");
        return YES;
    }
    SignalServiceAddress *_Nullable sourceAddress = jobInfo.envelope.sourceAddress;
    if (sourceAddress == nil || !sourceAddress.isValid) {
        OWSFailDebug(@"Invalid source address.");
        return YES;
    }
    if ([self.blockingManager isAddressBlocked:sourceAddress] ||
        [self.blockingManager isGroupIdBlocked:jobInfo.groupContextInfo.groupId]) {
        OWSLogInfo(@"Discarding blocked envelope.");
        return YES;
    }
    if (!jobInfo.groupContext.hasRevision) {
        OWSFailDebug(@"Invalid groupContext.");
        return YES;
    }
    if (ignoreIfNotLocalMember) {
        NSData *groupId = jobInfo.groupContextInfo.groupId;
        TSGroupThread *_Nullable groupThread = [TSGroupThread fetchWithGroupId:groupId transaction:transaction];
        if (groupThread == nil) {
            return YES;
        }
        if (!groupThread.isLocalUserInGroup) {
            // This could happen due to:
            //
            // * A bug.
            // * A race between message sending and leaving a group.
            //   We already know that we've left the group, but the
            //   sender didn't at the time they sent.
            // * A race between message sending and a group update.
            //   We already know that we've been kicked out of the group,
            //   but the sender didn't at the time they sent.
            return YES;
        }
    }
    return NO;
}

// Like non-v2 group messages, we want to do batch processing
// wherever possible for perf reasons (to reduce view updates).
// We should be able to mostly do that. However, there will be
// some edge cases where we'll need to interact with the service
// before we can process the message. Those messages should be
// processed alone in a batch of their own.
//
// Therefore, when trying to process we try to take either:
//
// * The first N messages that can be processed "locally".
// * The first message that has to be processed "remotely"
- (BOOL)canJobBeProcessedInLocalBatch:(IncomingGroupsV2MessageJobInfo *)jobInfo
                          transaction:(SDSAnyReadTransaction *)transaction
{
    if ([self canJobBeDiscarded:jobInfo ignoreIfNotLocalMember:NO transaction:transaction]) {
        return YES;
    }

    NSData *groupId = jobInfo.groupContextInfo.groupId;
    TSGroupThread *_Nullable groupThread = [TSGroupThread fetchWithGroupId:groupId transaction:transaction];
    if (groupThread == nil) {
        return NO;
    }
    uint32_t messageRevision = jobInfo.groupContext.revision;
    uint32_t modelRevision = groupThread.groupModel.groupV2Revision;
    if (messageRevision <= modelRevision) {
        return YES;
    }
    // GroupsV2 TODO: Try to apply any embedded change if only
    //                missing a single revision.
    return NO;
}

// NOTE: This method might do its work synchronously (in the "local" case)
//       or asynchronously (in the "remote" case).  It may only process
//       a subset of the jobs.
- (void)processJobs:(NSArray<IncomingGroupsV2MessageJob *> *)jobs
        transaction:(SDSAnyWriteTransaction *)transaction
         completion:(BatchCompletionBlock)completion
{
    OWSAssertDebug(jobs.count > 0);
    OWSAssertDebug(transaction != nil);

    // 1. Gather info for each job.
    // 2. Decide whether we'll process 1 "remote" job or N "local" jobs.
    //
    // Remote jobs require interaction with the service, namely fetching latest
    // group state.
    BOOL isLocalBatch = YES;
    NSMutableArray<IncomingGroupsV2MessageJobInfo *> *jobInfos = [NSMutableArray new];
    for (IncomingGroupsV2MessageJob *job in jobs) {
        IncomingGroupsV2MessageJobInfo *jobInfo = [self jobInfoForJob:job transaction:transaction];
        BOOL canJobBeProcessedInLocalBatch = [self canJobBeProcessedInLocalBatch:jobInfo transaction:transaction];
        if (!canJobBeProcessedInLocalBatch) {
            if (jobInfos.count > 0) {
                // Can't add "remote" job to "local" batch, abort and process jobs
                // already added to batch.
                break;
            }
            // Remote batches should only contain a single job.
            isLocalBatch = NO;
            [jobInfos addObject:jobInfo];
            break;
        }
        [jobInfos addObject:jobInfo];
    }

    if (isLocalBatch) {
        NSArray<IncomingGroupsV2MessageJob *> *processedJobs = [self performLocalProcessingSync:jobInfos
                                                                                    transaction:transaction];
        completion(processedJobs, transaction);
    } else {
        OWSAssertDebug(jobInfos.count == 1);
        [self performRemoteProcessingAsync:jobInfos.firstObject completion:completion];
    }
}

- (NSArray<IncomingGroupsV2MessageJob *> *)performLocalProcessingSync:
                                               (NSArray<IncomingGroupsV2MessageJobInfo *> *)jobInfos
                                                          transaction:(SDSAnyWriteTransaction *)transaction
{
    OWSAssertDebug(jobInfos.count > 0);
    OWSAssertDebug(transaction != nil);

    void (^reportFailure)(SDSAnyWriteTransaction *transaction) = ^(SDSAnyWriteTransaction *transaction) {
        // TODO: Add analytics.
        ThreadlessErrorMessage *errorMessage = [ThreadlessErrorMessage corruptedMessageInUnknownThread];
        [SSKEnvironment.shared.notificationsManager notifyUserForThreadlessErrorMessage:errorMessage
                                                                            transaction:transaction];
    };

    NSMutableArray<IncomingGroupsV2MessageJob *> *processedJobs = [NSMutableArray new];
    for (IncomingGroupsV2MessageJobInfo *jobInfo in jobInfos) {
        if ([self canJobBeDiscarded:jobInfo ignoreIfNotLocalMember:YES transaction:transaction]) {
            // Do nothing.
            OWSLogVerbose(@"Discarding job.");
        } else {
            @try {
                [self.messageManager throws_processEnvelope:jobInfo.envelope
                                              plaintextData:jobInfo.job.plaintextData
                                            wasReceivedByUD:jobInfo.job.wasReceivedByUD
                                                transaction:transaction];
            } @catch (NSException *exception) {
                OWSFailDebug(@"Received an invalid envelope: %@", exception.debugDescription);
                reportFailure(transaction);
            }
        }
        [processedJobs addObject:jobInfo.job];

        if (self.isAppInBackground) {
            // If the app is in the background, stop processing this batch.
            //
            // Since this check is done after processing jobs, we'll continue
            // to process jobs in batches of 1.  This reduces the cost of
            // being interrupted and rolled back if app is suspended.
            break;
        }
    }
    return processedJobs;
}

// Fetch group state from service and apply.
//
// * Try to fetch and apply incremental "changes".
// * Failover to fetching and applying latest state.
// * We need to distinguish between retryable (network) errors
//   and non-retryable errors.
// * In the case of networking errors, we should do exponential
//   backoff.
// * If reachability changes, we should retry network errors
//   immediately.
//
// GroupsV2 TODO: Ensure comment above is implemented.
- (void)performRemoteProcessingAsync:(IncomingGroupsV2MessageJobInfo *)jobInfo
                          completion:(BatchCompletionBlock)completion
{
    [[self.groupsV2 fetchAndApplyGroupV2UpdatesFromServiceObjcWithGroupId:jobInfo.groupContextInfo.groupId
                                                    groupSecretParamsData:jobInfo.groupContextInfo.groupSecretParamsData
                                                             upToRevision:jobInfo.groupContext.revision]
            .thenInBackground(^{
                [self.databaseStorage writeWithBlock:^(SDSAnyWriteTransaction *transaction) {
                    NSArray<IncomingGroupsV2MessageJob *> *processedJobs =
                        [self performLocalProcessingSync:@[ jobInfo ] transaction:transaction];
                    completion(processedJobs, transaction);
                }];
            })
            .catchInBackground(^(NSError *error) {
                [self.databaseStorage writeWithBlock:^(SDSAnyWriteTransaction *transaction) {
                    completion(@[], transaction);
                }];
            }) retainUntilComplete];
}

@end

#pragma mark - GroupsV2MessageProcessor

@interface GroupsV2MessageProcessor ()

@property (nonatomic, readonly) IncomingGroupsV2MessageQueue *processingQueue;

@end

#pragma mark -

@implementation GroupsV2MessageProcessor

- (instancetype)init
{
    OWSSingletonAssert();

    self = [super init];
    if (!self) {
        return self;
    }

    _processingQueue = [IncomingGroupsV2MessageQueue new];

    [self.processingQueue drainQueueWhenMainAppIsReady];

    return self;
}

#pragma mark - instance methods

- (void)enqueueEnvelopeData:(NSData *)envelopeData
              plaintextData:(NSData *_Nullable)plaintextData
            wasReceivedByUD:(BOOL)wasReceivedByUD
                transaction:(SDSAnyWriteTransaction *)transaction
{
    if (envelopeData.length < 1) {
        OWSFailDebug(@"Empty envelope.");
        return;
    }
    OWSAssert(transaction);

    // We need to persist the decrypted envelope data ASAP to prevent data loss.
    [self.processingQueue enqueueEnvelopeData:envelopeData
                                plaintextData:plaintextData
                              wasReceivedByUD:wasReceivedByUD
                                  transaction:transaction];

    // The new envelope won't be visible to the finder until this transaction commits,
    // so drainQueue in the transaction completion.
    [transaction addAsyncCompletionWithQueue:dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0)
                                       block:^{
                                           [self.processingQueue drainQueueWhenMainAppIsReady];
                                       }];
}

+ (BOOL)isGroupsV2Message:(nullable SSKProtoEnvelope *)envelope plaintextData:(nullable NSData *)plaintextData
{
    return [self groupContextV2ForEnvelope:envelope plaintextData:plaintextData] != nil;
}

+ (nullable SSKProtoGroupContextV2 *)groupContextV2ForEnvelope:(nullable SSKProtoEnvelope *)envelope
                                                 plaintextData:(nullable NSData *)plaintextData
{
    if (envelope == nil) {
        return nil;
    }
    if (plaintextData.length < 1) {
        return nil;
    }
    if (envelope.content == nil) {
        return nil;
    }

    NSError *_Nullable error;
    SSKProtoContent *_Nullable contentProto = [SSKProtoContent parseData:plaintextData error:&error];
    if (error != nil || contentProto == nil) {
        OWSFailDebug(@"could not parse proto: %@", error);
        return nil;
    }

    if (contentProto.dataMessage.groupV2 != nil) {
        return contentProto.dataMessage.groupV2;
    } else if (contentProto.syncMessage.sent.message.groupV2 != nil) {
        return contentProto.syncMessage.sent.message.groupV2;
    } else {
        return nil;
    }
}

@end

NS_ASSUME_NONNULL_END
