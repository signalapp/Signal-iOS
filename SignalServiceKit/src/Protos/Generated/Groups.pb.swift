//
// Copyright 2019 Signal Messenger, LLC
// SPDX-License-Identifier: AGPL-3.0-only
//

// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: Groups.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

//
// Copyright 2019 Signal Messenger, LLC
// SPDX-License-Identifier: AGPL-3.0-only

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

struct GroupsProtos_AvatarUploadAttributes {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var key: String = String()

  var credential: String = String()

  var acl: String = String()

  var algorithm: String = String()

  var date: String = String()

  var policy: String = String()

  var signature: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct GroupsProtos_Member {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The UuidCiphertext
  var userID: Data = Data()

  var role: GroupsProtos_Member.Role = .unknown

  /// The ProfileKeyCiphertext
  var profileKey: Data = Data()

  /// ProfileKeyCredentialPresentation
  var presentation: Data = Data()

  /// The Group.revision this member joined at
  var joinedAtRevision: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum Role: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case unknown // = 0

    /// Normal member
    case `default` // = 1

    /// Group admin
    case administrator // = 2
    case UNRECOGNIZED(Int)

    init() {
      self = .unknown
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknown
      case 1: self = .default
      case 2: self = .administrator
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .unknown: return 0
      case .default: return 1
      case .administrator: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  init() {}
}

#if swift(>=4.2)

extension GroupsProtos_Member.Role: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [GroupsProtos_Member.Role] = [
    .unknown,
    .default,
    .administrator,
  ]
}

#endif  // swift(>=4.2)

struct GroupsProtos_PendingMember {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The “invited” member
  var member: GroupsProtos_Member {
    get {return _member ?? GroupsProtos_Member()}
    set {_member = newValue}
  }
  /// Returns true if `member` has been explicitly set.
  var hasMember: Bool {return self._member != nil}
  /// Clears the value of `member`. Subsequent reads from it will return its default value.
  mutating func clearMember() {self._member = nil}

  /// The UID who invited this member
  var addedByUserID: Data = Data()

  /// The time the invitation occurred
  var timestamp: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _member: GroupsProtos_Member? = nil
}

struct GroupsProtos_RequestingMember {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var userID: Data = Data()

  var profileKey: Data = Data()

  var presentation: Data = Data()

  var timestamp: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct GroupsProtos_BannedMember {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var userID: Data = Data()

  var bannedAtTimestamp: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct GroupsProtos_AccessControl {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Who can modify the group title, avatar, disappearing messages timer
  var attributes: GroupsProtos_AccessControl.AccessRequired = .unknown

  /// Who can add people to the group
  var members: GroupsProtos_AccessControl.AccessRequired = .unknown

  var addFromInviteLink: GroupsProtos_AccessControl.AccessRequired = .unknown

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum AccessRequired: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case unknown // = 0
    case any // = 1

    /// Any group member can make the modification
    case member // = 2

    /// Only administrators can make the modification
    case administrator // = 3
    case unsatisfiable // = 4
    case UNRECOGNIZED(Int)

    init() {
      self = .unknown
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknown
      case 1: self = .any
      case 2: self = .member
      case 3: self = .administrator
      case 4: self = .unsatisfiable
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .unknown: return 0
      case .any: return 1
      case .member: return 2
      case .administrator: return 3
      case .unsatisfiable: return 4
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  init() {}
}

#if swift(>=4.2)

extension GroupsProtos_AccessControl.AccessRequired: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [GroupsProtos_AccessControl.AccessRequired] = [
    .unknown,
    .any,
    .member,
    .administrator,
    .unsatisfiable,
  ]
}

#endif  // swift(>=4.2)

struct GroupsProtos_Group {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// GroupPublicParams
  var publicKey: Data = Data()

  /// Encrypted title
  var title: Data = Data()

  /// Pointer to encrypted avatar (‘key’ from AvatarUploadAttributes)
  var avatar: String = String()

  /// Encrypted timer
  var disappearingMessagesTimer: Data = Data()

  var accessControl: GroupsProtos_AccessControl {
    get {return _accessControl ?? GroupsProtos_AccessControl()}
    set {_accessControl = newValue}
  }
  /// Returns true if `accessControl` has been explicitly set.
  var hasAccessControl: Bool {return self._accessControl != nil}
  /// Clears the value of `accessControl`. Subsequent reads from it will return its default value.
  mutating func clearAccessControl() {self._accessControl = nil}

  /// Current group revision number
  var revision: UInt32 = 0

  var members: [GroupsProtos_Member] = []

  var pendingMembers: [GroupsProtos_PendingMember] = []

  var requestingMembers: [GroupsProtos_RequestingMember] = []

  var inviteLinkPassword: Data = Data()

  var descriptionBytes: Data = Data()

  var announcementsOnly: Bool = false

  /// next: 14
  var bannedMembers: [GroupsProtos_BannedMember] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _accessControl: GroupsProtos_AccessControl? = nil
}

struct GroupsProtos_GroupChange {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The serialized actions
  var actions: Data = Data()

  /// Server’s signature over serialized actions
  var serverSignature: Data = Data()

  var changeEpoch: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct Actions {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Who made the change
    var sourceUuid: Data {
      get {return _storage._sourceUuid}
      set {_uniqueStorage()._sourceUuid = newValue}
    }

    /// The change revision number
    var revision: UInt32 {
      get {return _storage._revision}
      set {_uniqueStorage()._revision = newValue}
    }

    /// Members added
    var addMembers: [GroupsProtos_GroupChange.Actions.AddMemberAction] {
      get {return _storage._addMembers}
      set {_uniqueStorage()._addMembers = newValue}
    }

    /// Members deleted
    var deleteMembers: [GroupsProtos_GroupChange.Actions.DeleteMemberAction] {
      get {return _storage._deleteMembers}
      set {_uniqueStorage()._deleteMembers = newValue}
    }

    /// Modified member roles
    var modifyMemberRoles: [GroupsProtos_GroupChange.Actions.ModifyMemberRoleAction] {
      get {return _storage._modifyMemberRoles}
      set {_uniqueStorage()._modifyMemberRoles = newValue}
    }

    /// Modified member profile keys
    var modifyMemberProfileKeys: [GroupsProtos_GroupChange.Actions.ModifyMemberProfileKeyAction] {
      get {return _storage._modifyMemberProfileKeys}
      set {_uniqueStorage()._modifyMemberProfileKeys = newValue}
    }

    /// Pending members added
    var addPendingMembers: [GroupsProtos_GroupChange.Actions.AddPendingMemberAction] {
      get {return _storage._addPendingMembers}
      set {_uniqueStorage()._addPendingMembers = newValue}
    }

    /// Pending members deleted
    var deletePendingMembers: [GroupsProtos_GroupChange.Actions.DeletePendingMemberAction] {
      get {return _storage._deletePendingMembers}
      set {_uniqueStorage()._deletePendingMembers = newValue}
    }

    /// Pending invitations accepted
    var promotePendingMembers: [GroupsProtos_GroupChange.Actions.PromotePendingMemberAction] {
      get {return _storage._promotePendingMembers}
      set {_uniqueStorage()._promotePendingMembers = newValue}
    }

    /// Changed title
    var modifyTitle: GroupsProtos_GroupChange.Actions.ModifyTitleAction {
      get {return _storage._modifyTitle ?? GroupsProtos_GroupChange.Actions.ModifyTitleAction()}
      set {_uniqueStorage()._modifyTitle = newValue}
    }
    /// Returns true if `modifyTitle` has been explicitly set.
    var hasModifyTitle: Bool {return _storage._modifyTitle != nil}
    /// Clears the value of `modifyTitle`. Subsequent reads from it will return its default value.
    mutating func clearModifyTitle() {_uniqueStorage()._modifyTitle = nil}

    /// Changed avatar
    var modifyAvatar: GroupsProtos_GroupChange.Actions.ModifyAvatarAction {
      get {return _storage._modifyAvatar ?? GroupsProtos_GroupChange.Actions.ModifyAvatarAction()}
      set {_uniqueStorage()._modifyAvatar = newValue}
    }
    /// Returns true if `modifyAvatar` has been explicitly set.
    var hasModifyAvatar: Bool {return _storage._modifyAvatar != nil}
    /// Clears the value of `modifyAvatar`. Subsequent reads from it will return its default value.
    mutating func clearModifyAvatar() {_uniqueStorage()._modifyAvatar = nil}

    /// Changed timer
    var modifyDisappearingMessagesTimer: GroupsProtos_GroupChange.Actions.ModifyDisappearingMessagesTimerAction {
      get {return _storage._modifyDisappearingMessagesTimer ?? GroupsProtos_GroupChange.Actions.ModifyDisappearingMessagesTimerAction()}
      set {_uniqueStorage()._modifyDisappearingMessagesTimer = newValue}
    }
    /// Returns true if `modifyDisappearingMessagesTimer` has been explicitly set.
    var hasModifyDisappearingMessagesTimer: Bool {return _storage._modifyDisappearingMessagesTimer != nil}
    /// Clears the value of `modifyDisappearingMessagesTimer`. Subsequent reads from it will return its default value.
    mutating func clearModifyDisappearingMessagesTimer() {_uniqueStorage()._modifyDisappearingMessagesTimer = nil}

    /// Changed attributes access control
    var modifyAttributesAccess: GroupsProtos_GroupChange.Actions.ModifyAttributesAccessControlAction {
      get {return _storage._modifyAttributesAccess ?? GroupsProtos_GroupChange.Actions.ModifyAttributesAccessControlAction()}
      set {_uniqueStorage()._modifyAttributesAccess = newValue}
    }
    /// Returns true if `modifyAttributesAccess` has been explicitly set.
    var hasModifyAttributesAccess: Bool {return _storage._modifyAttributesAccess != nil}
    /// Clears the value of `modifyAttributesAccess`. Subsequent reads from it will return its default value.
    mutating func clearModifyAttributesAccess() {_uniqueStorage()._modifyAttributesAccess = nil}

    /// Changed membership access control
    var modifyMemberAccess: GroupsProtos_GroupChange.Actions.ModifyMembersAccessControlAction {
      get {return _storage._modifyMemberAccess ?? GroupsProtos_GroupChange.Actions.ModifyMembersAccessControlAction()}
      set {_uniqueStorage()._modifyMemberAccess = newValue}
    }
    /// Returns true if `modifyMemberAccess` has been explicitly set.
    var hasModifyMemberAccess: Bool {return _storage._modifyMemberAccess != nil}
    /// Clears the value of `modifyMemberAccess`. Subsequent reads from it will return its default value.
    mutating func clearModifyMemberAccess() {_uniqueStorage()._modifyMemberAccess = nil}

    /// change epoch = 1
    var modifyAddFromInviteLinkAccess: GroupsProtos_GroupChange.Actions.ModifyAddFromInviteLinkAccessControlAction {
      get {return _storage._modifyAddFromInviteLinkAccess ?? GroupsProtos_GroupChange.Actions.ModifyAddFromInviteLinkAccessControlAction()}
      set {_uniqueStorage()._modifyAddFromInviteLinkAccess = newValue}
    }
    /// Returns true if `modifyAddFromInviteLinkAccess` has been explicitly set.
    var hasModifyAddFromInviteLinkAccess: Bool {return _storage._modifyAddFromInviteLinkAccess != nil}
    /// Clears the value of `modifyAddFromInviteLinkAccess`. Subsequent reads from it will return its default value.
    mutating func clearModifyAddFromInviteLinkAccess() {_uniqueStorage()._modifyAddFromInviteLinkAccess = nil}

    /// change epoch = 1
    var addRequestingMembers: [GroupsProtos_GroupChange.Actions.AddRequestingMemberAction] {
      get {return _storage._addRequestingMembers}
      set {_uniqueStorage()._addRequestingMembers = newValue}
    }

    /// change epoch = 1
    var deleteRequestingMembers: [GroupsProtos_GroupChange.Actions.DeleteRequestingMemberAction] {
      get {return _storage._deleteRequestingMembers}
      set {_uniqueStorage()._deleteRequestingMembers = newValue}
    }

    /// change epoch = 1
    var promoteRequestingMembers: [GroupsProtos_GroupChange.Actions.PromoteRequestingMemberAction] {
      get {return _storage._promoteRequestingMembers}
      set {_uniqueStorage()._promoteRequestingMembers = newValue}
    }

    /// change epoch = 1
    var modifyInviteLinkPassword: GroupsProtos_GroupChange.Actions.ModifyInviteLinkPasswordAction {
      get {return _storage._modifyInviteLinkPassword ?? GroupsProtos_GroupChange.Actions.ModifyInviteLinkPasswordAction()}
      set {_uniqueStorage()._modifyInviteLinkPassword = newValue}
    }
    /// Returns true if `modifyInviteLinkPassword` has been explicitly set.
    var hasModifyInviteLinkPassword: Bool {return _storage._modifyInviteLinkPassword != nil}
    /// Clears the value of `modifyInviteLinkPassword`. Subsequent reads from it will return its default value.
    mutating func clearModifyInviteLinkPassword() {_uniqueStorage()._modifyInviteLinkPassword = nil}

    /// change epoch = 2
    var modifyDescription: GroupsProtos_GroupChange.Actions.ModifyDescriptionAction {
      get {return _storage._modifyDescription ?? GroupsProtos_GroupChange.Actions.ModifyDescriptionAction()}
      set {_uniqueStorage()._modifyDescription = newValue}
    }
    /// Returns true if `modifyDescription` has been explicitly set.
    var hasModifyDescription: Bool {return _storage._modifyDescription != nil}
    /// Clears the value of `modifyDescription`. Subsequent reads from it will return its default value.
    mutating func clearModifyDescription() {_uniqueStorage()._modifyDescription = nil}

    /// change epoch = 3
    var modifyAnnouncementsOnly: GroupsProtos_GroupChange.Actions.ModifyAnnouncementsOnlyAction {
      get {return _storage._modifyAnnouncementsOnly ?? GroupsProtos_GroupChange.Actions.ModifyAnnouncementsOnlyAction()}
      set {_uniqueStorage()._modifyAnnouncementsOnly = newValue}
    }
    /// Returns true if `modifyAnnouncementsOnly` has been explicitly set.
    var hasModifyAnnouncementsOnly: Bool {return _storage._modifyAnnouncementsOnly != nil}
    /// Clears the value of `modifyAnnouncementsOnly`. Subsequent reads from it will return its default value.
    mutating func clearModifyAnnouncementsOnly() {_uniqueStorage()._modifyAnnouncementsOnly = nil}

    /// change epoch = 4
    var addBannedMembers: [GroupsProtos_GroupChange.Actions.AddBannedMemberAction] {
      get {return _storage._addBannedMembers}
      set {_uniqueStorage()._addBannedMembers = newValue}
    }

    /// change epoch = 4
    var deleteBannedMembers: [GroupsProtos_GroupChange.Actions.DeleteBannedMemberAction] {
      get {return _storage._deleteBannedMembers}
      set {_uniqueStorage()._deleteBannedMembers = newValue}
    }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    struct AddMemberAction {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var added: GroupsProtos_Member {
        get {return _added ?? GroupsProtos_Member()}
        set {_added = newValue}
      }
      /// Returns true if `added` has been explicitly set.
      var hasAdded: Bool {return self._added != nil}
      /// Clears the value of `added`. Subsequent reads from it will return its default value.
      mutating func clearAdded() {self._added = nil}

      var joinFromInviteLink: Bool = false

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}

      fileprivate var _added: GroupsProtos_Member? = nil
    }

    struct DeleteMemberAction {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var deletedUserID: Data = Data()

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}
    }

    struct ModifyMemberRoleAction {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var userID: Data = Data()

      var role: GroupsProtos_Member.Role = .unknown

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}
    }

    struct ModifyMemberProfileKeyAction {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var presentation: Data = Data()

      var userID: Data = Data()

      var profileKey: Data = Data()

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}
    }

    struct AddPendingMemberAction {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var added: GroupsProtos_PendingMember {
        get {return _added ?? GroupsProtos_PendingMember()}
        set {_added = newValue}
      }
      /// Returns true if `added` has been explicitly set.
      var hasAdded: Bool {return self._added != nil}
      /// Clears the value of `added`. Subsequent reads from it will return its default value.
      mutating func clearAdded() {self._added = nil}

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}

      fileprivate var _added: GroupsProtos_PendingMember? = nil
    }

    struct DeletePendingMemberAction {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var deletedUserID: Data = Data()

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}
    }

    struct PromotePendingMemberAction {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var presentation: Data = Data()

      var userID: Data = Data()

      var profileKey: Data = Data()

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}
    }

    struct AddRequestingMemberAction {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var added: GroupsProtos_RequestingMember {
        get {return _added ?? GroupsProtos_RequestingMember()}
        set {_added = newValue}
      }
      /// Returns true if `added` has been explicitly set.
      var hasAdded: Bool {return self._added != nil}
      /// Clears the value of `added`. Subsequent reads from it will return its default value.
      mutating func clearAdded() {self._added = nil}

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}

      fileprivate var _added: GroupsProtos_RequestingMember? = nil
    }

    struct DeleteRequestingMemberAction {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var deletedUserID: Data = Data()

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}
    }

    struct PromoteRequestingMemberAction {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var userID: Data = Data()

      var role: GroupsProtos_Member.Role = .unknown

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}
    }

    struct AddBannedMemberAction {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var added: GroupsProtos_BannedMember {
        get {return _added ?? GroupsProtos_BannedMember()}
        set {_added = newValue}
      }
      /// Returns true if `added` has been explicitly set.
      var hasAdded: Bool {return self._added != nil}
      /// Clears the value of `added`. Subsequent reads from it will return its default value.
      mutating func clearAdded() {self._added = nil}

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}

      fileprivate var _added: GroupsProtos_BannedMember? = nil
    }

    struct DeleteBannedMemberAction {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var deletedUserID: Data = Data()

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}
    }

    struct ModifyTitleAction {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var title: Data = Data()

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}
    }

    struct ModifyAvatarAction {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var avatar: String = String()

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}
    }

    struct ModifyDisappearingMessagesTimerAction {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var timer: Data = Data()

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}
    }

    struct ModifyAttributesAccessControlAction {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var attributesAccess: GroupsProtos_AccessControl.AccessRequired = .unknown

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}
    }

    struct ModifyAvatarAccessControlAction {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var avatarAccess: GroupsProtos_AccessControl.AccessRequired = .unknown

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}
    }

    struct ModifyMembersAccessControlAction {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var membersAccess: GroupsProtos_AccessControl.AccessRequired = .unknown

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}
    }

    struct ModifyAddFromInviteLinkAccessControlAction {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var addFromInviteLinkAccess: GroupsProtos_AccessControl.AccessRequired = .unknown

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}
    }

    struct ModifyInviteLinkPasswordAction {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var inviteLinkPassword: Data = Data()

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}
    }

    struct ModifyDescriptionAction {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var descriptionBytes: Data = Data()

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}
    }

    struct ModifyAnnouncementsOnlyAction {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var announcementsOnly: Bool = false

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}
    }

    init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  init() {}
}

struct GroupsProtos_GroupChanges {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var groupChanges: [Data] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct GroupChangeState {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var groupChange: GroupsProtos_GroupChange {
      get {return _storage._groupChange ?? GroupsProtos_GroupChange()}
      set {_uniqueStorage()._groupChange = newValue}
    }
    /// Returns true if `groupChange` has been explicitly set.
    var hasGroupChange: Bool {return _storage._groupChange != nil}
    /// Clears the value of `groupChange`. Subsequent reads from it will return its default value.
    mutating func clearGroupChange() {_uniqueStorage()._groupChange = nil}

    var groupState: GroupsProtos_Group {
      get {return _storage._groupState ?? GroupsProtos_Group()}
      set {_uniqueStorage()._groupState = newValue}
    }
    /// Returns true if `groupState` has been explicitly set.
    var hasGroupState: Bool {return _storage._groupState != nil}
    /// Clears the value of `groupState`. Subsequent reads from it will return its default value.
    mutating func clearGroupState() {_uniqueStorage()._groupState = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  init() {}
}

struct GroupsProtos_GroupAttributeBlob {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var content: GroupsProtos_GroupAttributeBlob.OneOf_Content? = nil

  var title: String {
    get {
      if case .title(let v)? = content {return v}
      return String()
    }
    set {content = .title(newValue)}
  }

  var avatar: Data {
    get {
      if case .avatar(let v)? = content {return v}
      return Data()
    }
    set {content = .avatar(newValue)}
  }

  var disappearingMessagesDuration: UInt32 {
    get {
      if case .disappearingMessagesDuration(let v)? = content {return v}
      return 0
    }
    set {content = .disappearingMessagesDuration(newValue)}
  }

  var descriptionText: String {
    get {
      if case .descriptionText(let v)? = content {return v}
      return String()
    }
    set {content = .descriptionText(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Content: Equatable {
    case title(String)
    case avatar(Data)
    case disappearingMessagesDuration(UInt32)
    case descriptionText(String)

  #if !swift(>=4.1)
    static func ==(lhs: GroupsProtos_GroupAttributeBlob.OneOf_Content, rhs: GroupsProtos_GroupAttributeBlob.OneOf_Content) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.title, .title): return {
        guard case .title(let l) = lhs, case .title(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.avatar, .avatar): return {
        guard case .avatar(let l) = lhs, case .avatar(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.disappearingMessagesDuration, .disappearingMessagesDuration): return {
        guard case .disappearingMessagesDuration(let l) = lhs, case .disappearingMessagesDuration(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.descriptionText, .descriptionText): return {
        guard case .descriptionText(let l) = lhs, case .descriptionText(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}
}

struct GroupsProtos_GroupInviteLink {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var contents: GroupsProtos_GroupInviteLink.OneOf_Contents? = nil

  /// I have renamed this field to work around a limitation
  /// in our code generation.
  var contentsV1: GroupsProtos_GroupInviteLink.GroupInviteLinkContentsV1 {
    get {
      if case .contentsV1(let v)? = contents {return v}
      return GroupsProtos_GroupInviteLink.GroupInviteLinkContentsV1()
    }
    set {contents = .contentsV1(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Contents: Equatable {
    /// I have renamed this field to work around a limitation
    /// in our code generation.
    case contentsV1(GroupsProtos_GroupInviteLink.GroupInviteLinkContentsV1)

  #if !swift(>=4.1)
    static func ==(lhs: GroupsProtos_GroupInviteLink.OneOf_Contents, rhs: GroupsProtos_GroupInviteLink.OneOf_Contents) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.contentsV1, .contentsV1): return {
        guard case .contentsV1(let l) = lhs, case .contentsV1(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      }
    }
  #endif
  }

  struct GroupInviteLinkContentsV1 {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var groupMasterKey: Data = Data()

    var inviteLinkPassword: Data = Data()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  init() {}
}

struct GroupsProtos_GroupJoinInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var publicKey: Data = Data()

  var title: Data = Data()

  var avatar: String = String()

  var memberCount: UInt32 = 0

  var addFromInviteLink: GroupsProtos_AccessControl.AccessRequired = .unknown

  var revision: UInt32 = 0

  var pendingAdminApproval: Bool = false

  var descriptionBytes: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct GroupsProtos_GroupExternalCredential {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var token: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

#if swift(>=5.5) && canImport(_Concurrency)
extension GroupsProtos_AvatarUploadAttributes: @unchecked Sendable {}
extension GroupsProtos_Member: @unchecked Sendable {}
extension GroupsProtos_Member.Role: @unchecked Sendable {}
extension GroupsProtos_PendingMember: @unchecked Sendable {}
extension GroupsProtos_RequestingMember: @unchecked Sendable {}
extension GroupsProtos_BannedMember: @unchecked Sendable {}
extension GroupsProtos_AccessControl: @unchecked Sendable {}
extension GroupsProtos_AccessControl.AccessRequired: @unchecked Sendable {}
extension GroupsProtos_Group: @unchecked Sendable {}
extension GroupsProtos_GroupChange: @unchecked Sendable {}
extension GroupsProtos_GroupChange.Actions: @unchecked Sendable {}
extension GroupsProtos_GroupChange.Actions.AddMemberAction: @unchecked Sendable {}
extension GroupsProtos_GroupChange.Actions.DeleteMemberAction: @unchecked Sendable {}
extension GroupsProtos_GroupChange.Actions.ModifyMemberRoleAction: @unchecked Sendable {}
extension GroupsProtos_GroupChange.Actions.ModifyMemberProfileKeyAction: @unchecked Sendable {}
extension GroupsProtos_GroupChange.Actions.AddPendingMemberAction: @unchecked Sendable {}
extension GroupsProtos_GroupChange.Actions.DeletePendingMemberAction: @unchecked Sendable {}
extension GroupsProtos_GroupChange.Actions.PromotePendingMemberAction: @unchecked Sendable {}
extension GroupsProtos_GroupChange.Actions.AddRequestingMemberAction: @unchecked Sendable {}
extension GroupsProtos_GroupChange.Actions.DeleteRequestingMemberAction: @unchecked Sendable {}
extension GroupsProtos_GroupChange.Actions.PromoteRequestingMemberAction: @unchecked Sendable {}
extension GroupsProtos_GroupChange.Actions.AddBannedMemberAction: @unchecked Sendable {}
extension GroupsProtos_GroupChange.Actions.DeleteBannedMemberAction: @unchecked Sendable {}
extension GroupsProtos_GroupChange.Actions.ModifyTitleAction: @unchecked Sendable {}
extension GroupsProtos_GroupChange.Actions.ModifyAvatarAction: @unchecked Sendable {}
extension GroupsProtos_GroupChange.Actions.ModifyDisappearingMessagesTimerAction: @unchecked Sendable {}
extension GroupsProtos_GroupChange.Actions.ModifyAttributesAccessControlAction: @unchecked Sendable {}
extension GroupsProtos_GroupChange.Actions.ModifyAvatarAccessControlAction: @unchecked Sendable {}
extension GroupsProtos_GroupChange.Actions.ModifyMembersAccessControlAction: @unchecked Sendable {}
extension GroupsProtos_GroupChange.Actions.ModifyAddFromInviteLinkAccessControlAction: @unchecked Sendable {}
extension GroupsProtos_GroupChange.Actions.ModifyInviteLinkPasswordAction: @unchecked Sendable {}
extension GroupsProtos_GroupChange.Actions.ModifyDescriptionAction: @unchecked Sendable {}
extension GroupsProtos_GroupChange.Actions.ModifyAnnouncementsOnlyAction: @unchecked Sendable {}
extension GroupsProtos_GroupChanges: @unchecked Sendable {}
extension GroupsProtos_GroupChanges.GroupChangeState: @unchecked Sendable {}
extension GroupsProtos_GroupAttributeBlob: @unchecked Sendable {}
extension GroupsProtos_GroupAttributeBlob.OneOf_Content: @unchecked Sendable {}
extension GroupsProtos_GroupInviteLink: @unchecked Sendable {}
extension GroupsProtos_GroupInviteLink.OneOf_Contents: @unchecked Sendable {}
extension GroupsProtos_GroupInviteLink.GroupInviteLinkContentsV1: @unchecked Sendable {}
extension GroupsProtos_GroupJoinInfo: @unchecked Sendable {}
extension GroupsProtos_GroupExternalCredential: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "GroupsProtos"

extension GroupsProtos_AvatarUploadAttributes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AvatarUploadAttributes"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "key"),
    2: .same(proto: "credential"),
    3: .same(proto: "acl"),
    4: .same(proto: "algorithm"),
    5: .same(proto: "date"),
    6: .same(proto: "policy"),
    7: .same(proto: "signature"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.key) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.credential) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.acl) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.algorithm) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.date) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.policy) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.signature) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.key.isEmpty {
      try visitor.visitSingularStringField(value: self.key, fieldNumber: 1)
    }
    if !self.credential.isEmpty {
      try visitor.visitSingularStringField(value: self.credential, fieldNumber: 2)
    }
    if !self.acl.isEmpty {
      try visitor.visitSingularStringField(value: self.acl, fieldNumber: 3)
    }
    if !self.algorithm.isEmpty {
      try visitor.visitSingularStringField(value: self.algorithm, fieldNumber: 4)
    }
    if !self.date.isEmpty {
      try visitor.visitSingularStringField(value: self.date, fieldNumber: 5)
    }
    if !self.policy.isEmpty {
      try visitor.visitSingularStringField(value: self.policy, fieldNumber: 6)
    }
    if !self.signature.isEmpty {
      try visitor.visitSingularStringField(value: self.signature, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: GroupsProtos_AvatarUploadAttributes, rhs: GroupsProtos_AvatarUploadAttributes) -> Bool {
    if lhs.key != rhs.key {return false}
    if lhs.credential != rhs.credential {return false}
    if lhs.acl != rhs.acl {return false}
    if lhs.algorithm != rhs.algorithm {return false}
    if lhs.date != rhs.date {return false}
    if lhs.policy != rhs.policy {return false}
    if lhs.signature != rhs.signature {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GroupsProtos_Member: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Member"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "userId"),
    2: .same(proto: "role"),
    3: .same(proto: "profileKey"),
    4: .same(proto: "presentation"),
    5: .same(proto: "joinedAtRevision"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.userID) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.role) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.profileKey) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self.presentation) }()
      case 5: try { try decoder.decodeSingularUInt32Field(value: &self.joinedAtRevision) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.userID.isEmpty {
      try visitor.visitSingularBytesField(value: self.userID, fieldNumber: 1)
    }
    if self.role != .unknown {
      try visitor.visitSingularEnumField(value: self.role, fieldNumber: 2)
    }
    if !self.profileKey.isEmpty {
      try visitor.visitSingularBytesField(value: self.profileKey, fieldNumber: 3)
    }
    if !self.presentation.isEmpty {
      try visitor.visitSingularBytesField(value: self.presentation, fieldNumber: 4)
    }
    if self.joinedAtRevision != 0 {
      try visitor.visitSingularUInt32Field(value: self.joinedAtRevision, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: GroupsProtos_Member, rhs: GroupsProtos_Member) -> Bool {
    if lhs.userID != rhs.userID {return false}
    if lhs.role != rhs.role {return false}
    if lhs.profileKey != rhs.profileKey {return false}
    if lhs.presentation != rhs.presentation {return false}
    if lhs.joinedAtRevision != rhs.joinedAtRevision {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GroupsProtos_Member.Role: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN"),
    1: .same(proto: "DEFAULT"),
    2: .same(proto: "ADMINISTRATOR"),
  ]
}

extension GroupsProtos_PendingMember: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PendingMember"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "member"),
    2: .same(proto: "addedByUserId"),
    3: .same(proto: "timestamp"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._member) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.addedByUserID) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.timestamp) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._member {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.addedByUserID.isEmpty {
      try visitor.visitSingularBytesField(value: self.addedByUserID, fieldNumber: 2)
    }
    if self.timestamp != 0 {
      try visitor.visitSingularUInt64Field(value: self.timestamp, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: GroupsProtos_PendingMember, rhs: GroupsProtos_PendingMember) -> Bool {
    if lhs._member != rhs._member {return false}
    if lhs.addedByUserID != rhs.addedByUserID {return false}
    if lhs.timestamp != rhs.timestamp {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GroupsProtos_RequestingMember: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RequestingMember"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "userId"),
    2: .same(proto: "profileKey"),
    3: .same(proto: "presentation"),
    4: .same(proto: "timestamp"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.userID) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.profileKey) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.presentation) }()
      case 4: try { try decoder.decodeSingularUInt64Field(value: &self.timestamp) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.userID.isEmpty {
      try visitor.visitSingularBytesField(value: self.userID, fieldNumber: 1)
    }
    if !self.profileKey.isEmpty {
      try visitor.visitSingularBytesField(value: self.profileKey, fieldNumber: 2)
    }
    if !self.presentation.isEmpty {
      try visitor.visitSingularBytesField(value: self.presentation, fieldNumber: 3)
    }
    if self.timestamp != 0 {
      try visitor.visitSingularUInt64Field(value: self.timestamp, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: GroupsProtos_RequestingMember, rhs: GroupsProtos_RequestingMember) -> Bool {
    if lhs.userID != rhs.userID {return false}
    if lhs.profileKey != rhs.profileKey {return false}
    if lhs.presentation != rhs.presentation {return false}
    if lhs.timestamp != rhs.timestamp {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GroupsProtos_BannedMember: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BannedMember"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "userId"),
    2: .same(proto: "bannedAtTimestamp"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.userID) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.bannedAtTimestamp) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.userID.isEmpty {
      try visitor.visitSingularBytesField(value: self.userID, fieldNumber: 1)
    }
    if self.bannedAtTimestamp != 0 {
      try visitor.visitSingularUInt64Field(value: self.bannedAtTimestamp, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: GroupsProtos_BannedMember, rhs: GroupsProtos_BannedMember) -> Bool {
    if lhs.userID != rhs.userID {return false}
    if lhs.bannedAtTimestamp != rhs.bannedAtTimestamp {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GroupsProtos_AccessControl: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AccessControl"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "attributes"),
    2: .same(proto: "members"),
    3: .same(proto: "addFromInviteLink"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.attributes) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.members) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.addFromInviteLink) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.attributes != .unknown {
      try visitor.visitSingularEnumField(value: self.attributes, fieldNumber: 1)
    }
    if self.members != .unknown {
      try visitor.visitSingularEnumField(value: self.members, fieldNumber: 2)
    }
    if self.addFromInviteLink != .unknown {
      try visitor.visitSingularEnumField(value: self.addFromInviteLink, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: GroupsProtos_AccessControl, rhs: GroupsProtos_AccessControl) -> Bool {
    if lhs.attributes != rhs.attributes {return false}
    if lhs.members != rhs.members {return false}
    if lhs.addFromInviteLink != rhs.addFromInviteLink {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GroupsProtos_AccessControl.AccessRequired: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN"),
    1: .same(proto: "ANY"),
    2: .same(proto: "MEMBER"),
    3: .same(proto: "ADMINISTRATOR"),
    4: .same(proto: "UNSATISFIABLE"),
  ]
}

extension GroupsProtos_Group: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Group"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "publicKey"),
    2: .same(proto: "title"),
    3: .same(proto: "avatar"),
    4: .same(proto: "disappearingMessagesTimer"),
    5: .same(proto: "accessControl"),
    6: .same(proto: "revision"),
    7: .same(proto: "members"),
    8: .same(proto: "pendingMembers"),
    9: .same(proto: "requestingMembers"),
    10: .same(proto: "inviteLinkPassword"),
    11: .same(proto: "descriptionBytes"),
    12: .same(proto: "announcementsOnly"),
    13: .same(proto: "bannedMembers"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.publicKey) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.title) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.avatar) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self.disappearingMessagesTimer) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._accessControl) }()
      case 6: try { try decoder.decodeSingularUInt32Field(value: &self.revision) }()
      case 7: try { try decoder.decodeRepeatedMessageField(value: &self.members) }()
      case 8: try { try decoder.decodeRepeatedMessageField(value: &self.pendingMembers) }()
      case 9: try { try decoder.decodeRepeatedMessageField(value: &self.requestingMembers) }()
      case 10: try { try decoder.decodeSingularBytesField(value: &self.inviteLinkPassword) }()
      case 11: try { try decoder.decodeSingularBytesField(value: &self.descriptionBytes) }()
      case 12: try { try decoder.decodeSingularBoolField(value: &self.announcementsOnly) }()
      case 13: try { try decoder.decodeRepeatedMessageField(value: &self.bannedMembers) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.publicKey.isEmpty {
      try visitor.visitSingularBytesField(value: self.publicKey, fieldNumber: 1)
    }
    if !self.title.isEmpty {
      try visitor.visitSingularBytesField(value: self.title, fieldNumber: 2)
    }
    if !self.avatar.isEmpty {
      try visitor.visitSingularStringField(value: self.avatar, fieldNumber: 3)
    }
    if !self.disappearingMessagesTimer.isEmpty {
      try visitor.visitSingularBytesField(value: self.disappearingMessagesTimer, fieldNumber: 4)
    }
    try { if let v = self._accessControl {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    if self.revision != 0 {
      try visitor.visitSingularUInt32Field(value: self.revision, fieldNumber: 6)
    }
    if !self.members.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.members, fieldNumber: 7)
    }
    if !self.pendingMembers.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.pendingMembers, fieldNumber: 8)
    }
    if !self.requestingMembers.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.requestingMembers, fieldNumber: 9)
    }
    if !self.inviteLinkPassword.isEmpty {
      try visitor.visitSingularBytesField(value: self.inviteLinkPassword, fieldNumber: 10)
    }
    if !self.descriptionBytes.isEmpty {
      try visitor.visitSingularBytesField(value: self.descriptionBytes, fieldNumber: 11)
    }
    if self.announcementsOnly != false {
      try visitor.visitSingularBoolField(value: self.announcementsOnly, fieldNumber: 12)
    }
    if !self.bannedMembers.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.bannedMembers, fieldNumber: 13)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: GroupsProtos_Group, rhs: GroupsProtos_Group) -> Bool {
    if lhs.publicKey != rhs.publicKey {return false}
    if lhs.title != rhs.title {return false}
    if lhs.avatar != rhs.avatar {return false}
    if lhs.disappearingMessagesTimer != rhs.disappearingMessagesTimer {return false}
    if lhs._accessControl != rhs._accessControl {return false}
    if lhs.revision != rhs.revision {return false}
    if lhs.members != rhs.members {return false}
    if lhs.pendingMembers != rhs.pendingMembers {return false}
    if lhs.requestingMembers != rhs.requestingMembers {return false}
    if lhs.inviteLinkPassword != rhs.inviteLinkPassword {return false}
    if lhs.descriptionBytes != rhs.descriptionBytes {return false}
    if lhs.announcementsOnly != rhs.announcementsOnly {return false}
    if lhs.bannedMembers != rhs.bannedMembers {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GroupsProtos_GroupChange: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GroupChange"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "actions"),
    2: .same(proto: "serverSignature"),
    3: .same(proto: "changeEpoch"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.actions) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.serverSignature) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.changeEpoch) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.actions.isEmpty {
      try visitor.visitSingularBytesField(value: self.actions, fieldNumber: 1)
    }
    if !self.serverSignature.isEmpty {
      try visitor.visitSingularBytesField(value: self.serverSignature, fieldNumber: 2)
    }
    if self.changeEpoch != 0 {
      try visitor.visitSingularUInt32Field(value: self.changeEpoch, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: GroupsProtos_GroupChange, rhs: GroupsProtos_GroupChange) -> Bool {
    if lhs.actions != rhs.actions {return false}
    if lhs.serverSignature != rhs.serverSignature {return false}
    if lhs.changeEpoch != rhs.changeEpoch {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GroupsProtos_GroupChange.Actions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = GroupsProtos_GroupChange.protoMessageName + ".Actions"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "sourceUuid"),
    2: .same(proto: "revision"),
    3: .same(proto: "addMembers"),
    4: .same(proto: "deleteMembers"),
    5: .same(proto: "modifyMemberRoles"),
    6: .same(proto: "modifyMemberProfileKeys"),
    7: .same(proto: "addPendingMembers"),
    8: .same(proto: "deletePendingMembers"),
    9: .same(proto: "promotePendingMembers"),
    10: .same(proto: "modifyTitle"),
    11: .same(proto: "modifyAvatar"),
    12: .same(proto: "modifyDisappearingMessagesTimer"),
    13: .same(proto: "modifyAttributesAccess"),
    14: .same(proto: "modifyMemberAccess"),
    15: .same(proto: "modifyAddFromInviteLinkAccess"),
    16: .same(proto: "addRequestingMembers"),
    17: .same(proto: "deleteRequestingMembers"),
    18: .same(proto: "promoteRequestingMembers"),
    19: .same(proto: "modifyInviteLinkPassword"),
    20: .same(proto: "modifyDescription"),
    21: .same(proto: "modifyAnnouncementsOnly"),
    22: .same(proto: "addBannedMembers"),
    23: .same(proto: "deleteBannedMembers"),
  ]

  fileprivate class _StorageClass {
    var _sourceUuid: Data = Data()
    var _revision: UInt32 = 0
    var _addMembers: [GroupsProtos_GroupChange.Actions.AddMemberAction] = []
    var _deleteMembers: [GroupsProtos_GroupChange.Actions.DeleteMemberAction] = []
    var _modifyMemberRoles: [GroupsProtos_GroupChange.Actions.ModifyMemberRoleAction] = []
    var _modifyMemberProfileKeys: [GroupsProtos_GroupChange.Actions.ModifyMemberProfileKeyAction] = []
    var _addPendingMembers: [GroupsProtos_GroupChange.Actions.AddPendingMemberAction] = []
    var _deletePendingMembers: [GroupsProtos_GroupChange.Actions.DeletePendingMemberAction] = []
    var _promotePendingMembers: [GroupsProtos_GroupChange.Actions.PromotePendingMemberAction] = []
    var _modifyTitle: GroupsProtos_GroupChange.Actions.ModifyTitleAction? = nil
    var _modifyAvatar: GroupsProtos_GroupChange.Actions.ModifyAvatarAction? = nil
    var _modifyDisappearingMessagesTimer: GroupsProtos_GroupChange.Actions.ModifyDisappearingMessagesTimerAction? = nil
    var _modifyAttributesAccess: GroupsProtos_GroupChange.Actions.ModifyAttributesAccessControlAction? = nil
    var _modifyMemberAccess: GroupsProtos_GroupChange.Actions.ModifyMembersAccessControlAction? = nil
    var _modifyAddFromInviteLinkAccess: GroupsProtos_GroupChange.Actions.ModifyAddFromInviteLinkAccessControlAction? = nil
    var _addRequestingMembers: [GroupsProtos_GroupChange.Actions.AddRequestingMemberAction] = []
    var _deleteRequestingMembers: [GroupsProtos_GroupChange.Actions.DeleteRequestingMemberAction] = []
    var _promoteRequestingMembers: [GroupsProtos_GroupChange.Actions.PromoteRequestingMemberAction] = []
    var _modifyInviteLinkPassword: GroupsProtos_GroupChange.Actions.ModifyInviteLinkPasswordAction? = nil
    var _modifyDescription: GroupsProtos_GroupChange.Actions.ModifyDescriptionAction? = nil
    var _modifyAnnouncementsOnly: GroupsProtos_GroupChange.Actions.ModifyAnnouncementsOnlyAction? = nil
    var _addBannedMembers: [GroupsProtos_GroupChange.Actions.AddBannedMemberAction] = []
    var _deleteBannedMembers: [GroupsProtos_GroupChange.Actions.DeleteBannedMemberAction] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _sourceUuid = source._sourceUuid
      _revision = source._revision
      _addMembers = source._addMembers
      _deleteMembers = source._deleteMembers
      _modifyMemberRoles = source._modifyMemberRoles
      _modifyMemberProfileKeys = source._modifyMemberProfileKeys
      _addPendingMembers = source._addPendingMembers
      _deletePendingMembers = source._deletePendingMembers
      _promotePendingMembers = source._promotePendingMembers
      _modifyTitle = source._modifyTitle
      _modifyAvatar = source._modifyAvatar
      _modifyDisappearingMessagesTimer = source._modifyDisappearingMessagesTimer
      _modifyAttributesAccess = source._modifyAttributesAccess
      _modifyMemberAccess = source._modifyMemberAccess
      _modifyAddFromInviteLinkAccess = source._modifyAddFromInviteLinkAccess
      _addRequestingMembers = source._addRequestingMembers
      _deleteRequestingMembers = source._deleteRequestingMembers
      _promoteRequestingMembers = source._promoteRequestingMembers
      _modifyInviteLinkPassword = source._modifyInviteLinkPassword
      _modifyDescription = source._modifyDescription
      _modifyAnnouncementsOnly = source._modifyAnnouncementsOnly
      _addBannedMembers = source._addBannedMembers
      _deleteBannedMembers = source._deleteBannedMembers
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularBytesField(value: &_storage._sourceUuid) }()
        case 2: try { try decoder.decodeSingularUInt32Field(value: &_storage._revision) }()
        case 3: try { try decoder.decodeRepeatedMessageField(value: &_storage._addMembers) }()
        case 4: try { try decoder.decodeRepeatedMessageField(value: &_storage._deleteMembers) }()
        case 5: try { try decoder.decodeRepeatedMessageField(value: &_storage._modifyMemberRoles) }()
        case 6: try { try decoder.decodeRepeatedMessageField(value: &_storage._modifyMemberProfileKeys) }()
        case 7: try { try decoder.decodeRepeatedMessageField(value: &_storage._addPendingMembers) }()
        case 8: try { try decoder.decodeRepeatedMessageField(value: &_storage._deletePendingMembers) }()
        case 9: try { try decoder.decodeRepeatedMessageField(value: &_storage._promotePendingMembers) }()
        case 10: try { try decoder.decodeSingularMessageField(value: &_storage._modifyTitle) }()
        case 11: try { try decoder.decodeSingularMessageField(value: &_storage._modifyAvatar) }()
        case 12: try { try decoder.decodeSingularMessageField(value: &_storage._modifyDisappearingMessagesTimer) }()
        case 13: try { try decoder.decodeSingularMessageField(value: &_storage._modifyAttributesAccess) }()
        case 14: try { try decoder.decodeSingularMessageField(value: &_storage._modifyMemberAccess) }()
        case 15: try { try decoder.decodeSingularMessageField(value: &_storage._modifyAddFromInviteLinkAccess) }()
        case 16: try { try decoder.decodeRepeatedMessageField(value: &_storage._addRequestingMembers) }()
        case 17: try { try decoder.decodeRepeatedMessageField(value: &_storage._deleteRequestingMembers) }()
        case 18: try { try decoder.decodeRepeatedMessageField(value: &_storage._promoteRequestingMembers) }()
        case 19: try { try decoder.decodeSingularMessageField(value: &_storage._modifyInviteLinkPassword) }()
        case 20: try { try decoder.decodeSingularMessageField(value: &_storage._modifyDescription) }()
        case 21: try { try decoder.decodeSingularMessageField(value: &_storage._modifyAnnouncementsOnly) }()
        case 22: try { try decoder.decodeRepeatedMessageField(value: &_storage._addBannedMembers) }()
        case 23: try { try decoder.decodeRepeatedMessageField(value: &_storage._deleteBannedMembers) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._sourceUuid.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._sourceUuid, fieldNumber: 1)
      }
      if _storage._revision != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._revision, fieldNumber: 2)
      }
      if !_storage._addMembers.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._addMembers, fieldNumber: 3)
      }
      if !_storage._deleteMembers.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._deleteMembers, fieldNumber: 4)
      }
      if !_storage._modifyMemberRoles.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._modifyMemberRoles, fieldNumber: 5)
      }
      if !_storage._modifyMemberProfileKeys.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._modifyMemberProfileKeys, fieldNumber: 6)
      }
      if !_storage._addPendingMembers.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._addPendingMembers, fieldNumber: 7)
      }
      if !_storage._deletePendingMembers.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._deletePendingMembers, fieldNumber: 8)
      }
      if !_storage._promotePendingMembers.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._promotePendingMembers, fieldNumber: 9)
      }
      try { if let v = _storage._modifyTitle {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      } }()
      try { if let v = _storage._modifyAvatar {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      } }()
      try { if let v = _storage._modifyDisappearingMessagesTimer {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      } }()
      try { if let v = _storage._modifyAttributesAccess {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
      } }()
      try { if let v = _storage._modifyMemberAccess {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
      } }()
      try { if let v = _storage._modifyAddFromInviteLinkAccess {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
      } }()
      if !_storage._addRequestingMembers.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._addRequestingMembers, fieldNumber: 16)
      }
      if !_storage._deleteRequestingMembers.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._deleteRequestingMembers, fieldNumber: 17)
      }
      if !_storage._promoteRequestingMembers.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._promoteRequestingMembers, fieldNumber: 18)
      }
      try { if let v = _storage._modifyInviteLinkPassword {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 19)
      } }()
      try { if let v = _storage._modifyDescription {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 20)
      } }()
      try { if let v = _storage._modifyAnnouncementsOnly {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 21)
      } }()
      if !_storage._addBannedMembers.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._addBannedMembers, fieldNumber: 22)
      }
      if !_storage._deleteBannedMembers.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._deleteBannedMembers, fieldNumber: 23)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: GroupsProtos_GroupChange.Actions, rhs: GroupsProtos_GroupChange.Actions) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._sourceUuid != rhs_storage._sourceUuid {return false}
        if _storage._revision != rhs_storage._revision {return false}
        if _storage._addMembers != rhs_storage._addMembers {return false}
        if _storage._deleteMembers != rhs_storage._deleteMembers {return false}
        if _storage._modifyMemberRoles != rhs_storage._modifyMemberRoles {return false}
        if _storage._modifyMemberProfileKeys != rhs_storage._modifyMemberProfileKeys {return false}
        if _storage._addPendingMembers != rhs_storage._addPendingMembers {return false}
        if _storage._deletePendingMembers != rhs_storage._deletePendingMembers {return false}
        if _storage._promotePendingMembers != rhs_storage._promotePendingMembers {return false}
        if _storage._modifyTitle != rhs_storage._modifyTitle {return false}
        if _storage._modifyAvatar != rhs_storage._modifyAvatar {return false}
        if _storage._modifyDisappearingMessagesTimer != rhs_storage._modifyDisappearingMessagesTimer {return false}
        if _storage._modifyAttributesAccess != rhs_storage._modifyAttributesAccess {return false}
        if _storage._modifyMemberAccess != rhs_storage._modifyMemberAccess {return false}
        if _storage._modifyAddFromInviteLinkAccess != rhs_storage._modifyAddFromInviteLinkAccess {return false}
        if _storage._addRequestingMembers != rhs_storage._addRequestingMembers {return false}
        if _storage._deleteRequestingMembers != rhs_storage._deleteRequestingMembers {return false}
        if _storage._promoteRequestingMembers != rhs_storage._promoteRequestingMembers {return false}
        if _storage._modifyInviteLinkPassword != rhs_storage._modifyInviteLinkPassword {return false}
        if _storage._modifyDescription != rhs_storage._modifyDescription {return false}
        if _storage._modifyAnnouncementsOnly != rhs_storage._modifyAnnouncementsOnly {return false}
        if _storage._addBannedMembers != rhs_storage._addBannedMembers {return false}
        if _storage._deleteBannedMembers != rhs_storage._deleteBannedMembers {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GroupsProtos_GroupChange.Actions.AddMemberAction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = GroupsProtos_GroupChange.Actions.protoMessageName + ".AddMemberAction"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "added"),
    2: .same(proto: "joinFromInviteLink"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._added) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.joinFromInviteLink) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._added {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.joinFromInviteLink != false {
      try visitor.visitSingularBoolField(value: self.joinFromInviteLink, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: GroupsProtos_GroupChange.Actions.AddMemberAction, rhs: GroupsProtos_GroupChange.Actions.AddMemberAction) -> Bool {
    if lhs._added != rhs._added {return false}
    if lhs.joinFromInviteLink != rhs.joinFromInviteLink {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GroupsProtos_GroupChange.Actions.DeleteMemberAction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = GroupsProtos_GroupChange.Actions.protoMessageName + ".DeleteMemberAction"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "deletedUserId"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.deletedUserID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.deletedUserID.isEmpty {
      try visitor.visitSingularBytesField(value: self.deletedUserID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: GroupsProtos_GroupChange.Actions.DeleteMemberAction, rhs: GroupsProtos_GroupChange.Actions.DeleteMemberAction) -> Bool {
    if lhs.deletedUserID != rhs.deletedUserID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GroupsProtos_GroupChange.Actions.ModifyMemberRoleAction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = GroupsProtos_GroupChange.Actions.protoMessageName + ".ModifyMemberRoleAction"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "userId"),
    2: .same(proto: "role"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.userID) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.role) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.userID.isEmpty {
      try visitor.visitSingularBytesField(value: self.userID, fieldNumber: 1)
    }
    if self.role != .unknown {
      try visitor.visitSingularEnumField(value: self.role, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: GroupsProtos_GroupChange.Actions.ModifyMemberRoleAction, rhs: GroupsProtos_GroupChange.Actions.ModifyMemberRoleAction) -> Bool {
    if lhs.userID != rhs.userID {return false}
    if lhs.role != rhs.role {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GroupsProtos_GroupChange.Actions.ModifyMemberProfileKeyAction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = GroupsProtos_GroupChange.Actions.protoMessageName + ".ModifyMemberProfileKeyAction"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "presentation"),
    2: .standard(proto: "user_id"),
    3: .standard(proto: "profile_key"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.presentation) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.userID) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.profileKey) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.presentation.isEmpty {
      try visitor.visitSingularBytesField(value: self.presentation, fieldNumber: 1)
    }
    if !self.userID.isEmpty {
      try visitor.visitSingularBytesField(value: self.userID, fieldNumber: 2)
    }
    if !self.profileKey.isEmpty {
      try visitor.visitSingularBytesField(value: self.profileKey, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: GroupsProtos_GroupChange.Actions.ModifyMemberProfileKeyAction, rhs: GroupsProtos_GroupChange.Actions.ModifyMemberProfileKeyAction) -> Bool {
    if lhs.presentation != rhs.presentation {return false}
    if lhs.userID != rhs.userID {return false}
    if lhs.profileKey != rhs.profileKey {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GroupsProtos_GroupChange.Actions.AddPendingMemberAction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = GroupsProtos_GroupChange.Actions.protoMessageName + ".AddPendingMemberAction"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "added"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._added) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._added {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: GroupsProtos_GroupChange.Actions.AddPendingMemberAction, rhs: GroupsProtos_GroupChange.Actions.AddPendingMemberAction) -> Bool {
    if lhs._added != rhs._added {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GroupsProtos_GroupChange.Actions.DeletePendingMemberAction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = GroupsProtos_GroupChange.Actions.protoMessageName + ".DeletePendingMemberAction"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "deletedUserId"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.deletedUserID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.deletedUserID.isEmpty {
      try visitor.visitSingularBytesField(value: self.deletedUserID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: GroupsProtos_GroupChange.Actions.DeletePendingMemberAction, rhs: GroupsProtos_GroupChange.Actions.DeletePendingMemberAction) -> Bool {
    if lhs.deletedUserID != rhs.deletedUserID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GroupsProtos_GroupChange.Actions.PromotePendingMemberAction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = GroupsProtos_GroupChange.Actions.protoMessageName + ".PromotePendingMemberAction"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "presentation"),
    2: .standard(proto: "user_id"),
    3: .standard(proto: "profile_key"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.presentation) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.userID) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.profileKey) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.presentation.isEmpty {
      try visitor.visitSingularBytesField(value: self.presentation, fieldNumber: 1)
    }
    if !self.userID.isEmpty {
      try visitor.visitSingularBytesField(value: self.userID, fieldNumber: 2)
    }
    if !self.profileKey.isEmpty {
      try visitor.visitSingularBytesField(value: self.profileKey, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: GroupsProtos_GroupChange.Actions.PromotePendingMemberAction, rhs: GroupsProtos_GroupChange.Actions.PromotePendingMemberAction) -> Bool {
    if lhs.presentation != rhs.presentation {return false}
    if lhs.userID != rhs.userID {return false}
    if lhs.profileKey != rhs.profileKey {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GroupsProtos_GroupChange.Actions.AddRequestingMemberAction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = GroupsProtos_GroupChange.Actions.protoMessageName + ".AddRequestingMemberAction"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "added"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._added) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._added {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: GroupsProtos_GroupChange.Actions.AddRequestingMemberAction, rhs: GroupsProtos_GroupChange.Actions.AddRequestingMemberAction) -> Bool {
    if lhs._added != rhs._added {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GroupsProtos_GroupChange.Actions.DeleteRequestingMemberAction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = GroupsProtos_GroupChange.Actions.protoMessageName + ".DeleteRequestingMemberAction"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "deletedUserId"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.deletedUserID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.deletedUserID.isEmpty {
      try visitor.visitSingularBytesField(value: self.deletedUserID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: GroupsProtos_GroupChange.Actions.DeleteRequestingMemberAction, rhs: GroupsProtos_GroupChange.Actions.DeleteRequestingMemberAction) -> Bool {
    if lhs.deletedUserID != rhs.deletedUserID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GroupsProtos_GroupChange.Actions.PromoteRequestingMemberAction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = GroupsProtos_GroupChange.Actions.protoMessageName + ".PromoteRequestingMemberAction"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "userId"),
    2: .same(proto: "role"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.userID) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.role) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.userID.isEmpty {
      try visitor.visitSingularBytesField(value: self.userID, fieldNumber: 1)
    }
    if self.role != .unknown {
      try visitor.visitSingularEnumField(value: self.role, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: GroupsProtos_GroupChange.Actions.PromoteRequestingMemberAction, rhs: GroupsProtos_GroupChange.Actions.PromoteRequestingMemberAction) -> Bool {
    if lhs.userID != rhs.userID {return false}
    if lhs.role != rhs.role {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GroupsProtos_GroupChange.Actions.AddBannedMemberAction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = GroupsProtos_GroupChange.Actions.protoMessageName + ".AddBannedMemberAction"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "added"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._added) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._added {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: GroupsProtos_GroupChange.Actions.AddBannedMemberAction, rhs: GroupsProtos_GroupChange.Actions.AddBannedMemberAction) -> Bool {
    if lhs._added != rhs._added {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GroupsProtos_GroupChange.Actions.DeleteBannedMemberAction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = GroupsProtos_GroupChange.Actions.protoMessageName + ".DeleteBannedMemberAction"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "deletedUserId"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.deletedUserID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.deletedUserID.isEmpty {
      try visitor.visitSingularBytesField(value: self.deletedUserID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: GroupsProtos_GroupChange.Actions.DeleteBannedMemberAction, rhs: GroupsProtos_GroupChange.Actions.DeleteBannedMemberAction) -> Bool {
    if lhs.deletedUserID != rhs.deletedUserID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GroupsProtos_GroupChange.Actions.ModifyTitleAction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = GroupsProtos_GroupChange.Actions.protoMessageName + ".ModifyTitleAction"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "title"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.title) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.title.isEmpty {
      try visitor.visitSingularBytesField(value: self.title, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: GroupsProtos_GroupChange.Actions.ModifyTitleAction, rhs: GroupsProtos_GroupChange.Actions.ModifyTitleAction) -> Bool {
    if lhs.title != rhs.title {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GroupsProtos_GroupChange.Actions.ModifyAvatarAction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = GroupsProtos_GroupChange.Actions.protoMessageName + ".ModifyAvatarAction"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "avatar"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.avatar) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.avatar.isEmpty {
      try visitor.visitSingularStringField(value: self.avatar, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: GroupsProtos_GroupChange.Actions.ModifyAvatarAction, rhs: GroupsProtos_GroupChange.Actions.ModifyAvatarAction) -> Bool {
    if lhs.avatar != rhs.avatar {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GroupsProtos_GroupChange.Actions.ModifyDisappearingMessagesTimerAction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = GroupsProtos_GroupChange.Actions.protoMessageName + ".ModifyDisappearingMessagesTimerAction"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "timer"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.timer) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.timer.isEmpty {
      try visitor.visitSingularBytesField(value: self.timer, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: GroupsProtos_GroupChange.Actions.ModifyDisappearingMessagesTimerAction, rhs: GroupsProtos_GroupChange.Actions.ModifyDisappearingMessagesTimerAction) -> Bool {
    if lhs.timer != rhs.timer {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GroupsProtos_GroupChange.Actions.ModifyAttributesAccessControlAction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = GroupsProtos_GroupChange.Actions.protoMessageName + ".ModifyAttributesAccessControlAction"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "attributesAccess"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.attributesAccess) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.attributesAccess != .unknown {
      try visitor.visitSingularEnumField(value: self.attributesAccess, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: GroupsProtos_GroupChange.Actions.ModifyAttributesAccessControlAction, rhs: GroupsProtos_GroupChange.Actions.ModifyAttributesAccessControlAction) -> Bool {
    if lhs.attributesAccess != rhs.attributesAccess {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GroupsProtos_GroupChange.Actions.ModifyAvatarAccessControlAction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = GroupsProtos_GroupChange.Actions.protoMessageName + ".ModifyAvatarAccessControlAction"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "avatarAccess"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.avatarAccess) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.avatarAccess != .unknown {
      try visitor.visitSingularEnumField(value: self.avatarAccess, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: GroupsProtos_GroupChange.Actions.ModifyAvatarAccessControlAction, rhs: GroupsProtos_GroupChange.Actions.ModifyAvatarAccessControlAction) -> Bool {
    if lhs.avatarAccess != rhs.avatarAccess {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GroupsProtos_GroupChange.Actions.ModifyMembersAccessControlAction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = GroupsProtos_GroupChange.Actions.protoMessageName + ".ModifyMembersAccessControlAction"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "membersAccess"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.membersAccess) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.membersAccess != .unknown {
      try visitor.visitSingularEnumField(value: self.membersAccess, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: GroupsProtos_GroupChange.Actions.ModifyMembersAccessControlAction, rhs: GroupsProtos_GroupChange.Actions.ModifyMembersAccessControlAction) -> Bool {
    if lhs.membersAccess != rhs.membersAccess {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GroupsProtos_GroupChange.Actions.ModifyAddFromInviteLinkAccessControlAction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = GroupsProtos_GroupChange.Actions.protoMessageName + ".ModifyAddFromInviteLinkAccessControlAction"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "addFromInviteLinkAccess"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.addFromInviteLinkAccess) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.addFromInviteLinkAccess != .unknown {
      try visitor.visitSingularEnumField(value: self.addFromInviteLinkAccess, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: GroupsProtos_GroupChange.Actions.ModifyAddFromInviteLinkAccessControlAction, rhs: GroupsProtos_GroupChange.Actions.ModifyAddFromInviteLinkAccessControlAction) -> Bool {
    if lhs.addFromInviteLinkAccess != rhs.addFromInviteLinkAccess {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GroupsProtos_GroupChange.Actions.ModifyInviteLinkPasswordAction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = GroupsProtos_GroupChange.Actions.protoMessageName + ".ModifyInviteLinkPasswordAction"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "inviteLinkPassword"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.inviteLinkPassword) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.inviteLinkPassword.isEmpty {
      try visitor.visitSingularBytesField(value: self.inviteLinkPassword, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: GroupsProtos_GroupChange.Actions.ModifyInviteLinkPasswordAction, rhs: GroupsProtos_GroupChange.Actions.ModifyInviteLinkPasswordAction) -> Bool {
    if lhs.inviteLinkPassword != rhs.inviteLinkPassword {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GroupsProtos_GroupChange.Actions.ModifyDescriptionAction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = GroupsProtos_GroupChange.Actions.protoMessageName + ".ModifyDescriptionAction"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "descriptionBytes"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.descriptionBytes) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.descriptionBytes.isEmpty {
      try visitor.visitSingularBytesField(value: self.descriptionBytes, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: GroupsProtos_GroupChange.Actions.ModifyDescriptionAction, rhs: GroupsProtos_GroupChange.Actions.ModifyDescriptionAction) -> Bool {
    if lhs.descriptionBytes != rhs.descriptionBytes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GroupsProtos_GroupChange.Actions.ModifyAnnouncementsOnlyAction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = GroupsProtos_GroupChange.Actions.protoMessageName + ".ModifyAnnouncementsOnlyAction"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "announcementsOnly"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.announcementsOnly) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.announcementsOnly != false {
      try visitor.visitSingularBoolField(value: self.announcementsOnly, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: GroupsProtos_GroupChange.Actions.ModifyAnnouncementsOnlyAction, rhs: GroupsProtos_GroupChange.Actions.ModifyAnnouncementsOnlyAction) -> Bool {
    if lhs.announcementsOnly != rhs.announcementsOnly {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GroupsProtos_GroupChanges: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GroupChanges"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "groupChanges"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedBytesField(value: &self.groupChanges) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.groupChanges.isEmpty {
      try visitor.visitRepeatedBytesField(value: self.groupChanges, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: GroupsProtos_GroupChanges, rhs: GroupsProtos_GroupChanges) -> Bool {
    if lhs.groupChanges != rhs.groupChanges {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GroupsProtos_GroupChanges.GroupChangeState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = GroupsProtos_GroupChanges.protoMessageName + ".GroupChangeState"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "groupChange"),
    2: .same(proto: "groupState"),
  ]

  fileprivate class _StorageClass {
    var _groupChange: GroupsProtos_GroupChange? = nil
    var _groupState: GroupsProtos_Group? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _groupChange = source._groupChange
      _groupState = source._groupState
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._groupChange) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._groupState) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._groupChange {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._groupState {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: GroupsProtos_GroupChanges.GroupChangeState, rhs: GroupsProtos_GroupChanges.GroupChangeState) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._groupChange != rhs_storage._groupChange {return false}
        if _storage._groupState != rhs_storage._groupState {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GroupsProtos_GroupAttributeBlob: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GroupAttributeBlob"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "title"),
    2: .same(proto: "avatar"),
    3: .same(proto: "disappearingMessagesDuration"),
    4: .same(proto: "descriptionText"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.content != nil {try decoder.handleConflictingOneOf()}
          self.content = .title(v)
        }
      }()
      case 2: try {
        var v: Data?
        try decoder.decodeSingularBytesField(value: &v)
        if let v = v {
          if self.content != nil {try decoder.handleConflictingOneOf()}
          self.content = .avatar(v)
        }
      }()
      case 3: try {
        var v: UInt32?
        try decoder.decodeSingularUInt32Field(value: &v)
        if let v = v {
          if self.content != nil {try decoder.handleConflictingOneOf()}
          self.content = .disappearingMessagesDuration(v)
        }
      }()
      case 4: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.content != nil {try decoder.handleConflictingOneOf()}
          self.content = .descriptionText(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.content {
    case .title?: try {
      guard case .title(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }()
    case .avatar?: try {
      guard case .avatar(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularBytesField(value: v, fieldNumber: 2)
    }()
    case .disappearingMessagesDuration?: try {
      guard case .disappearingMessagesDuration(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 3)
    }()
    case .descriptionText?: try {
      guard case .descriptionText(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 4)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: GroupsProtos_GroupAttributeBlob, rhs: GroupsProtos_GroupAttributeBlob) -> Bool {
    if lhs.content != rhs.content {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GroupsProtos_GroupInviteLink: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GroupInviteLink"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "contentsV1"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: GroupsProtos_GroupInviteLink.GroupInviteLinkContentsV1?
        var hadOneofValue = false
        if let current = self.contents {
          hadOneofValue = true
          if case .contentsV1(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.contents = .contentsV1(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if case .contentsV1(let v)? = self.contents {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: GroupsProtos_GroupInviteLink, rhs: GroupsProtos_GroupInviteLink) -> Bool {
    if lhs.contents != rhs.contents {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GroupsProtos_GroupInviteLink.GroupInviteLinkContentsV1: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = GroupsProtos_GroupInviteLink.protoMessageName + ".GroupInviteLinkContentsV1"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "groupMasterKey"),
    2: .same(proto: "inviteLinkPassword"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.groupMasterKey) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.inviteLinkPassword) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.groupMasterKey.isEmpty {
      try visitor.visitSingularBytesField(value: self.groupMasterKey, fieldNumber: 1)
    }
    if !self.inviteLinkPassword.isEmpty {
      try visitor.visitSingularBytesField(value: self.inviteLinkPassword, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: GroupsProtos_GroupInviteLink.GroupInviteLinkContentsV1, rhs: GroupsProtos_GroupInviteLink.GroupInviteLinkContentsV1) -> Bool {
    if lhs.groupMasterKey != rhs.groupMasterKey {return false}
    if lhs.inviteLinkPassword != rhs.inviteLinkPassword {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GroupsProtos_GroupJoinInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GroupJoinInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "publicKey"),
    2: .same(proto: "title"),
    3: .same(proto: "avatar"),
    4: .same(proto: "memberCount"),
    5: .same(proto: "addFromInviteLink"),
    6: .same(proto: "revision"),
    7: .same(proto: "pendingAdminApproval"),
    8: .same(proto: "descriptionBytes"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.publicKey) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.title) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.avatar) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self.memberCount) }()
      case 5: try { try decoder.decodeSingularEnumField(value: &self.addFromInviteLink) }()
      case 6: try { try decoder.decodeSingularUInt32Field(value: &self.revision) }()
      case 7: try { try decoder.decodeSingularBoolField(value: &self.pendingAdminApproval) }()
      case 8: try { try decoder.decodeSingularBytesField(value: &self.descriptionBytes) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.publicKey.isEmpty {
      try visitor.visitSingularBytesField(value: self.publicKey, fieldNumber: 1)
    }
    if !self.title.isEmpty {
      try visitor.visitSingularBytesField(value: self.title, fieldNumber: 2)
    }
    if !self.avatar.isEmpty {
      try visitor.visitSingularStringField(value: self.avatar, fieldNumber: 3)
    }
    if self.memberCount != 0 {
      try visitor.visitSingularUInt32Field(value: self.memberCount, fieldNumber: 4)
    }
    if self.addFromInviteLink != .unknown {
      try visitor.visitSingularEnumField(value: self.addFromInviteLink, fieldNumber: 5)
    }
    if self.revision != 0 {
      try visitor.visitSingularUInt32Field(value: self.revision, fieldNumber: 6)
    }
    if self.pendingAdminApproval != false {
      try visitor.visitSingularBoolField(value: self.pendingAdminApproval, fieldNumber: 7)
    }
    if !self.descriptionBytes.isEmpty {
      try visitor.visitSingularBytesField(value: self.descriptionBytes, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: GroupsProtos_GroupJoinInfo, rhs: GroupsProtos_GroupJoinInfo) -> Bool {
    if lhs.publicKey != rhs.publicKey {return false}
    if lhs.title != rhs.title {return false}
    if lhs.avatar != rhs.avatar {return false}
    if lhs.memberCount != rhs.memberCount {return false}
    if lhs.addFromInviteLink != rhs.addFromInviteLink {return false}
    if lhs.revision != rhs.revision {return false}
    if lhs.pendingAdminApproval != rhs.pendingAdminApproval {return false}
    if lhs.descriptionBytes != rhs.descriptionBytes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GroupsProtos_GroupExternalCredential: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GroupExternalCredential"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "token"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.token) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.token.isEmpty {
      try visitor.visitSingularStringField(value: self.token, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: GroupsProtos_GroupExternalCredential, rhs: GroupsProtos_GroupExternalCredential) -> Bool {
    if lhs.token != rhs.token {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
