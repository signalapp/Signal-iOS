//
//  Copyright (c) 2022 Open Whisper Systems. All rights reserved.
//

//
//  Copyright (c) 2019 Open Whisper Systems. All rights reserved.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

struct StorageServiceProtos_StorageItem {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// @required
  var key: Data = Data()

  /// @required
  var value: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct StorageServiceProtos_StorageItems {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Corresponds to the requested
  var items: [StorageServiceProtos_StorageItem] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct StorageServiceProtos_StorageManifest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// @required
  var version: UInt64 = 0

  /// @required
  var value: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct StorageServiceProtos_ReadOperation {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var readKey: [Data] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct StorageServiceProtos_WriteOperation {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var manifest: StorageServiceProtos_StorageManifest {
    get {return _manifest ?? StorageServiceProtos_StorageManifest()}
    set {_manifest = newValue}
  }
  /// Returns true if `manifest` has been explicitly set.
  var hasManifest: Bool {return self._manifest != nil}
  /// Clears the value of `manifest`. Subsequent reads from it will return its default value.
  mutating func clearManifest() {self._manifest = nil}

  var insertItem: [StorageServiceProtos_StorageItem] = []

  var deleteKey: [Data] = []

  var deleteAll: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _manifest: StorageServiceProtos_StorageManifest? = nil
}

struct StorageServiceProtos_ManifestRecord {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// @required
  var version: UInt64 = 0

  var sourceDevice: UInt32 = 0

  var keys: [StorageServiceProtos_ManifestRecord.Key] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct Key {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// @required
    var data: Data = Data()

    /// @required
    var type: StorageServiceProtos_ManifestRecord.Key.TypeEnum = .unknown

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum TypeEnum: SwiftProtobuf.Enum {
      typealias RawValue = Int
      case unknown // = 0
      case contact // = 1
      case groupv1 // = 2
      case groupv2 // = 3
      case account // = 4
      case storyDistributionList // = 5
      case UNRECOGNIZED(Int)

      init() {
        self = .unknown
      }

      init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .unknown
        case 1: self = .contact
        case 2: self = .groupv1
        case 3: self = .groupv2
        case 4: self = .account
        case 5: self = .storyDistributionList
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      var rawValue: Int {
        switch self {
        case .unknown: return 0
        case .contact: return 1
        case .groupv1: return 2
        case .groupv2: return 3
        case .account: return 4
        case .storyDistributionList: return 5
        case .UNRECOGNIZED(let i): return i
        }
      }

    }

    init() {}
  }

  init() {}
}

#if swift(>=4.2)

extension StorageServiceProtos_ManifestRecord.Key.TypeEnum: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [StorageServiceProtos_ManifestRecord.Key.TypeEnum] = [
    .unknown,
    .contact,
    .groupv1,
    .groupv2,
    .account,
    .storyDistributionList,
  ]
}

#endif  // swift(>=4.2)

struct StorageServiceProtos_StorageRecord {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var record: StorageServiceProtos_StorageRecord.OneOf_Record? = nil

  var contact: StorageServiceProtos_ContactRecord {
    get {
      if case .contact(let v)? = record {return v}
      return StorageServiceProtos_ContactRecord()
    }
    set {record = .contact(newValue)}
  }

  var groupV1: StorageServiceProtos_GroupV1Record {
    get {
      if case .groupV1(let v)? = record {return v}
      return StorageServiceProtos_GroupV1Record()
    }
    set {record = .groupV1(newValue)}
  }

  var groupV2: StorageServiceProtos_GroupV2Record {
    get {
      if case .groupV2(let v)? = record {return v}
      return StorageServiceProtos_GroupV2Record()
    }
    set {record = .groupV2(newValue)}
  }

  var account: StorageServiceProtos_AccountRecord {
    get {
      if case .account(let v)? = record {return v}
      return StorageServiceProtos_AccountRecord()
    }
    set {record = .account(newValue)}
  }

  var storyDistributionList: StorageServiceProtos_StoryDistributionListRecord {
    get {
      if case .storyDistributionList(let v)? = record {return v}
      return StorageServiceProtos_StoryDistributionListRecord()
    }
    set {record = .storyDistributionList(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Record: Equatable {
    case contact(StorageServiceProtos_ContactRecord)
    case groupV1(StorageServiceProtos_GroupV1Record)
    case groupV2(StorageServiceProtos_GroupV2Record)
    case account(StorageServiceProtos_AccountRecord)
    case storyDistributionList(StorageServiceProtos_StoryDistributionListRecord)

  #if !swift(>=4.1)
    static func ==(lhs: StorageServiceProtos_StorageRecord.OneOf_Record, rhs: StorageServiceProtos_StorageRecord.OneOf_Record) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.contact, .contact): return {
        guard case .contact(let l) = lhs, case .contact(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.groupV1, .groupV1): return {
        guard case .groupV1(let l) = lhs, case .groupV1(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.groupV2, .groupV2): return {
        guard case .groupV2(let l) = lhs, case .groupV2(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.account, .account): return {
        guard case .account(let l) = lhs, case .account(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.storyDistributionList, .storyDistributionList): return {
        guard case .storyDistributionList(let l) = lhs, case .storyDistributionList(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}
}

struct StorageServiceProtos_ContactRecord {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// @trustedMapping
  var serviceUuid: String = String()

  var serviceE164: String = String()

  var profileKey: Data = Data()

  var identityKey: Data = Data()

  var identityState: StorageServiceProtos_ContactRecord.IdentityState = .default

  var givenName: String = String()

  var familyName: String = String()

  var username: String = String()

  var blocked: Bool = false

  var whitelisted: Bool = false

  var archived: Bool = false

  var markedUnread: Bool = false

  var mutedUntilTimestamp: UInt64 = 0

  var hideStory: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum IdentityState: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case `default` // = 0
    case verified // = 1
    case unverified // = 2
    case UNRECOGNIZED(Int)

    init() {
      self = .default
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .default
      case 1: self = .verified
      case 2: self = .unverified
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .default: return 0
      case .verified: return 1
      case .unverified: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  init() {}
}

#if swift(>=4.2)

extension StorageServiceProtos_ContactRecord.IdentityState: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [StorageServiceProtos_ContactRecord.IdentityState] = [
    .default,
    .verified,
    .unverified,
  ]
}

#endif  // swift(>=4.2)

struct StorageServiceProtos_GroupV1Record {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// @required
  var id: Data = Data()

  var blocked: Bool = false

  var whitelisted: Bool = false

  var archived: Bool = false

  var markedUnread: Bool = false

  var mutedUntilTimestamp: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct StorageServiceProtos_GroupV2Record {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// @required
  var masterKey: Data = Data()

  var blocked: Bool = false

  var whitelisted: Bool = false

  var archived: Bool = false

  var markedUnread: Bool = false

  var mutedUntilTimestamp: UInt64 = 0

  ///bool dontNotifyForMentionsIfMuted = 7;
  var hideStory: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct StorageServiceProtos_AccountRecord {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var profileKey: Data {
    get {return _storage._profileKey}
    set {_uniqueStorage()._profileKey = newValue}
  }

  var givenName: String {
    get {return _storage._givenName}
    set {_uniqueStorage()._givenName = newValue}
  }

  var familyName: String {
    get {return _storage._familyName}
    set {_uniqueStorage()._familyName = newValue}
  }

  var avatarURL: String {
    get {return _storage._avatarURL}
    set {_uniqueStorage()._avatarURL = newValue}
  }

  var noteToSelfArchived: Bool {
    get {return _storage._noteToSelfArchived}
    set {_uniqueStorage()._noteToSelfArchived = newValue}
  }

  var readReceipts: Bool {
    get {return _storage._readReceipts}
    set {_uniqueStorage()._readReceipts = newValue}
  }

  var sealedSenderIndicators: Bool {
    get {return _storage._sealedSenderIndicators}
    set {_uniqueStorage()._sealedSenderIndicators = newValue}
  }

  var typingIndicators: Bool {
    get {return _storage._typingIndicators}
    set {_uniqueStorage()._typingIndicators = newValue}
  }

  /// Legacy link previews flag
  var proxiedLinkPreviews: Bool {
    get {return _storage._proxiedLinkPreviews}
    set {_uniqueStorage()._proxiedLinkPreviews = newValue}
  }

  var noteToSelfMarkedUnread: Bool {
    get {return _storage._noteToSelfMarkedUnread}
    set {_uniqueStorage()._noteToSelfMarkedUnread = newValue}
  }

  var linkPreviews: Bool {
    get {return _storage._linkPreviews}
    set {_uniqueStorage()._linkPreviews = newValue}
  }

  var phoneNumberSharingMode: StorageServiceProtos_AccountRecord.PhoneNumberSharingMode {
    get {return _storage._phoneNumberSharingMode}
    set {_uniqueStorage()._phoneNumberSharingMode = newValue}
  }

  var notDiscoverableByPhoneNumber: Bool {
    get {return _storage._notDiscoverableByPhoneNumber}
    set {_uniqueStorage()._notDiscoverableByPhoneNumber = newValue}
  }

  var pinnedConversations: [StorageServiceProtos_AccountRecord.PinnedConversation] {
    get {return _storage._pinnedConversations}
    set {_uniqueStorage()._pinnedConversations = newValue}
  }

  var preferContactAvatars: Bool {
    get {return _storage._preferContactAvatars}
    set {_uniqueStorage()._preferContactAvatars = newValue}
  }

  var payments: StorageServiceProtos_AccountRecord.Payments {
    get {return _storage._payments ?? StorageServiceProtos_AccountRecord.Payments()}
    set {_uniqueStorage()._payments = newValue}
  }
  /// Returns true if `payments` has been explicitly set.
  var hasPayments: Bool {return _storage._payments != nil}
  /// Clears the value of `payments`. Subsequent reads from it will return its default value.
  mutating func clearPayments() {_uniqueStorage()._payments = nil}

  var universalExpireTimer: UInt32 {
    get {return _storage._universalExpireTimer}
    set {_uniqueStorage()._universalExpireTimer = newValue}
  }

  var e164: String {
    get {return _storage._e164}
    set {_uniqueStorage()._e164 = newValue}
  }

  var preferredReactionEmoji: [String] {
    get {return _storage._preferredReactionEmoji}
    set {_uniqueStorage()._preferredReactionEmoji = newValue}
  }

  var subscriberID: Data {
    get {return _storage._subscriberID}
    set {_uniqueStorage()._subscriberID = newValue}
  }

  var subscriberCurrencyCode: String {
    get {return _storage._subscriberCurrencyCode}
    set {_uniqueStorage()._subscriberCurrencyCode = newValue}
  }

  var displayBadgesOnProfile: Bool {
    get {return _storage._displayBadgesOnProfile}
    set {_uniqueStorage()._displayBadgesOnProfile = newValue}
  }

  var subscriptionManuallyCancelled: Bool {
    get {return _storage._subscriptionManuallyCancelled}
    set {_uniqueStorage()._subscriptionManuallyCancelled = newValue}
  }

  var keepMutedChatsArchived: Bool {
    get {return _storage._keepMutedChatsArchived}
    set {_uniqueStorage()._keepMutedChatsArchived = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum PhoneNumberSharingMode: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case everybody // = 0
    case contactsOnly // = 1
    case nobody // = 2
    case UNRECOGNIZED(Int)

    init() {
      self = .everybody
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .everybody
      case 1: self = .contactsOnly
      case 2: self = .nobody
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .everybody: return 0
      case .contactsOnly: return 1
      case .nobody: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  struct PinnedConversation {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var identifier: StorageServiceProtos_AccountRecord.PinnedConversation.OneOf_Identifier? = nil

    var contact: StorageServiceProtos_AccountRecord.PinnedConversation.Contact {
      get {
        if case .contact(let v)? = identifier {return v}
        return StorageServiceProtos_AccountRecord.PinnedConversation.Contact()
      }
      set {identifier = .contact(newValue)}
    }

    var legacyGroupID: Data {
      get {
        if case .legacyGroupID(let v)? = identifier {return v}
        return Data()
      }
      set {identifier = .legacyGroupID(newValue)}
    }

    var groupMasterKey: Data {
      get {
        if case .groupMasterKey(let v)? = identifier {return v}
        return Data()
      }
      set {identifier = .groupMasterKey(newValue)}
    }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum OneOf_Identifier: Equatable {
      case contact(StorageServiceProtos_AccountRecord.PinnedConversation.Contact)
      case legacyGroupID(Data)
      case groupMasterKey(Data)

    #if !swift(>=4.1)
      static func ==(lhs: StorageServiceProtos_AccountRecord.PinnedConversation.OneOf_Identifier, rhs: StorageServiceProtos_AccountRecord.PinnedConversation.OneOf_Identifier) -> Bool {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch (lhs, rhs) {
        case (.contact, .contact): return {
          guard case .contact(let l) = lhs, case .contact(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        case (.legacyGroupID, .legacyGroupID): return {
          guard case .legacyGroupID(let l) = lhs, case .legacyGroupID(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        case (.groupMasterKey, .groupMasterKey): return {
          guard case .groupMasterKey(let l) = lhs, case .groupMasterKey(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        default: return false
        }
      }
    #endif
    }

    struct Contact {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var uuid: String = String()

      var e164: String = String()

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}
    }

    init() {}
  }

  struct Payments {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var enabled: Bool = false

    var paymentsEntropy: Data = Data()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

#if swift(>=4.2)

extension StorageServiceProtos_AccountRecord.PhoneNumberSharingMode: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [StorageServiceProtos_AccountRecord.PhoneNumberSharingMode] = [
    .everybody,
    .contactsOnly,
    .nobody,
  ]
}

#endif  // swift(>=4.2)

struct StorageServiceProtos_StoryDistributionListRecord {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var identifier: Data = Data()

  var name: String = String()

  var recipientUuids: [String] = []

  var deletedAtTimestamp: UInt64 = 0

  var allowsReplies: Bool = false

  var isBlockList: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

#if swift(>=5.5) && canImport(_Concurrency)
extension StorageServiceProtos_StorageItem: @unchecked Sendable {}
extension StorageServiceProtos_StorageItems: @unchecked Sendable {}
extension StorageServiceProtos_StorageManifest: @unchecked Sendable {}
extension StorageServiceProtos_ReadOperation: @unchecked Sendable {}
extension StorageServiceProtos_WriteOperation: @unchecked Sendable {}
extension StorageServiceProtos_ManifestRecord: @unchecked Sendable {}
extension StorageServiceProtos_ManifestRecord.Key: @unchecked Sendable {}
extension StorageServiceProtos_ManifestRecord.Key.TypeEnum: @unchecked Sendable {}
extension StorageServiceProtos_StorageRecord: @unchecked Sendable {}
extension StorageServiceProtos_StorageRecord.OneOf_Record: @unchecked Sendable {}
extension StorageServiceProtos_ContactRecord: @unchecked Sendable {}
extension StorageServiceProtos_ContactRecord.IdentityState: @unchecked Sendable {}
extension StorageServiceProtos_GroupV1Record: @unchecked Sendable {}
extension StorageServiceProtos_GroupV2Record: @unchecked Sendable {}
extension StorageServiceProtos_AccountRecord: @unchecked Sendable {}
extension StorageServiceProtos_AccountRecord.PhoneNumberSharingMode: @unchecked Sendable {}
extension StorageServiceProtos_AccountRecord.PinnedConversation: @unchecked Sendable {}
extension StorageServiceProtos_AccountRecord.PinnedConversation.OneOf_Identifier: @unchecked Sendable {}
extension StorageServiceProtos_AccountRecord.PinnedConversation.Contact: @unchecked Sendable {}
extension StorageServiceProtos_AccountRecord.Payments: @unchecked Sendable {}
extension StorageServiceProtos_StoryDistributionListRecord: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "StorageServiceProtos"

extension StorageServiceProtos_StorageItem: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".StorageItem"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "key"),
    2: .same(proto: "value"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.key) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.value) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.key.isEmpty {
      try visitor.visitSingularBytesField(value: self.key, fieldNumber: 1)
    }
    if !self.value.isEmpty {
      try visitor.visitSingularBytesField(value: self.value, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: StorageServiceProtos_StorageItem, rhs: StorageServiceProtos_StorageItem) -> Bool {
    if lhs.key != rhs.key {return false}
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension StorageServiceProtos_StorageItems: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".StorageItems"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "items"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.items) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.items.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.items, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: StorageServiceProtos_StorageItems, rhs: StorageServiceProtos_StorageItems) -> Bool {
    if lhs.items != rhs.items {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension StorageServiceProtos_StorageManifest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".StorageManifest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "version"),
    2: .same(proto: "value"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.version) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.value) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.version != 0 {
      try visitor.visitSingularUInt64Field(value: self.version, fieldNumber: 1)
    }
    if !self.value.isEmpty {
      try visitor.visitSingularBytesField(value: self.value, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: StorageServiceProtos_StorageManifest, rhs: StorageServiceProtos_StorageManifest) -> Bool {
    if lhs.version != rhs.version {return false}
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension StorageServiceProtos_ReadOperation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ReadOperation"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "readKey"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedBytesField(value: &self.readKey) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.readKey.isEmpty {
      try visitor.visitRepeatedBytesField(value: self.readKey, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: StorageServiceProtos_ReadOperation, rhs: StorageServiceProtos_ReadOperation) -> Bool {
    if lhs.readKey != rhs.readKey {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension StorageServiceProtos_WriteOperation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".WriteOperation"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "manifest"),
    2: .same(proto: "insertItem"),
    3: .same(proto: "deleteKey"),
    4: .same(proto: "deleteAll"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._manifest) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.insertItem) }()
      case 3: try { try decoder.decodeRepeatedBytesField(value: &self.deleteKey) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.deleteAll) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._manifest {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.insertItem.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.insertItem, fieldNumber: 2)
    }
    if !self.deleteKey.isEmpty {
      try visitor.visitRepeatedBytesField(value: self.deleteKey, fieldNumber: 3)
    }
    if self.deleteAll != false {
      try visitor.visitSingularBoolField(value: self.deleteAll, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: StorageServiceProtos_WriteOperation, rhs: StorageServiceProtos_WriteOperation) -> Bool {
    if lhs._manifest != rhs._manifest {return false}
    if lhs.insertItem != rhs.insertItem {return false}
    if lhs.deleteKey != rhs.deleteKey {return false}
    if lhs.deleteAll != rhs.deleteAll {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension StorageServiceProtos_ManifestRecord: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ManifestRecord"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "version"),
    3: .same(proto: "sourceDevice"),
    2: .same(proto: "keys"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.version) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.keys) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.sourceDevice) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.version != 0 {
      try visitor.visitSingularUInt64Field(value: self.version, fieldNumber: 1)
    }
    if !self.keys.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.keys, fieldNumber: 2)
    }
    if self.sourceDevice != 0 {
      try visitor.visitSingularUInt32Field(value: self.sourceDevice, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: StorageServiceProtos_ManifestRecord, rhs: StorageServiceProtos_ManifestRecord) -> Bool {
    if lhs.version != rhs.version {return false}
    if lhs.sourceDevice != rhs.sourceDevice {return false}
    if lhs.keys != rhs.keys {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension StorageServiceProtos_ManifestRecord.Key: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = StorageServiceProtos_ManifestRecord.protoMessageName + ".Key"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "data"),
    2: .same(proto: "type"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.data) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.data.isEmpty {
      try visitor.visitSingularBytesField(value: self.data, fieldNumber: 1)
    }
    if self.type != .unknown {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: StorageServiceProtos_ManifestRecord.Key, rhs: StorageServiceProtos_ManifestRecord.Key) -> Bool {
    if lhs.data != rhs.data {return false}
    if lhs.type != rhs.type {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension StorageServiceProtos_ManifestRecord.Key.TypeEnum: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN"),
    1: .same(proto: "CONTACT"),
    2: .same(proto: "GROUPV1"),
    3: .same(proto: "GROUPV2"),
    4: .same(proto: "ACCOUNT"),
    5: .same(proto: "STORY_DISTRIBUTION_LIST"),
  ]
}

extension StorageServiceProtos_StorageRecord: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".StorageRecord"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "contact"),
    2: .same(proto: "groupV1"),
    3: .same(proto: "groupV2"),
    4: .same(proto: "account"),
    5: .same(proto: "storyDistributionList"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: StorageServiceProtos_ContactRecord?
        var hadOneofValue = false
        if let current = self.record {
          hadOneofValue = true
          if case .contact(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.record = .contact(v)
        }
      }()
      case 2: try {
        var v: StorageServiceProtos_GroupV1Record?
        var hadOneofValue = false
        if let current = self.record {
          hadOneofValue = true
          if case .groupV1(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.record = .groupV1(v)
        }
      }()
      case 3: try {
        var v: StorageServiceProtos_GroupV2Record?
        var hadOneofValue = false
        if let current = self.record {
          hadOneofValue = true
          if case .groupV2(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.record = .groupV2(v)
        }
      }()
      case 4: try {
        var v: StorageServiceProtos_AccountRecord?
        var hadOneofValue = false
        if let current = self.record {
          hadOneofValue = true
          if case .account(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.record = .account(v)
        }
      }()
      case 5: try {
        var v: StorageServiceProtos_StoryDistributionListRecord?
        var hadOneofValue = false
        if let current = self.record {
          hadOneofValue = true
          if case .storyDistributionList(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.record = .storyDistributionList(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.record {
    case .contact?: try {
      guard case .contact(let v)? = self.record else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .groupV1?: try {
      guard case .groupV1(let v)? = self.record else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .groupV2?: try {
      guard case .groupV2(let v)? = self.record else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .account?: try {
      guard case .account(let v)? = self.record else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .storyDistributionList?: try {
      guard case .storyDistributionList(let v)? = self.record else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: StorageServiceProtos_StorageRecord, rhs: StorageServiceProtos_StorageRecord) -> Bool {
    if lhs.record != rhs.record {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension StorageServiceProtos_ContactRecord: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ContactRecord"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "serviceUuid"),
    2: .same(proto: "serviceE164"),
    3: .same(proto: "profileKey"),
    4: .same(proto: "identityKey"),
    5: .same(proto: "identityState"),
    6: .same(proto: "givenName"),
    7: .same(proto: "familyName"),
    8: .same(proto: "username"),
    9: .same(proto: "blocked"),
    10: .same(proto: "whitelisted"),
    11: .same(proto: "archived"),
    12: .same(proto: "markedUnread"),
    13: .same(proto: "mutedUntilTimestamp"),
    14: .same(proto: "hideStory"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.serviceUuid) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.serviceE164) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.profileKey) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self.identityKey) }()
      case 5: try { try decoder.decodeSingularEnumField(value: &self.identityState) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.givenName) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.familyName) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.username) }()
      case 9: try { try decoder.decodeSingularBoolField(value: &self.blocked) }()
      case 10: try { try decoder.decodeSingularBoolField(value: &self.whitelisted) }()
      case 11: try { try decoder.decodeSingularBoolField(value: &self.archived) }()
      case 12: try { try decoder.decodeSingularBoolField(value: &self.markedUnread) }()
      case 13: try { try decoder.decodeSingularUInt64Field(value: &self.mutedUntilTimestamp) }()
      case 14: try { try decoder.decodeSingularBoolField(value: &self.hideStory) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.serviceUuid.isEmpty {
      try visitor.visitSingularStringField(value: self.serviceUuid, fieldNumber: 1)
    }
    if !self.serviceE164.isEmpty {
      try visitor.visitSingularStringField(value: self.serviceE164, fieldNumber: 2)
    }
    if !self.profileKey.isEmpty {
      try visitor.visitSingularBytesField(value: self.profileKey, fieldNumber: 3)
    }
    if !self.identityKey.isEmpty {
      try visitor.visitSingularBytesField(value: self.identityKey, fieldNumber: 4)
    }
    if self.identityState != .default {
      try visitor.visitSingularEnumField(value: self.identityState, fieldNumber: 5)
    }
    if !self.givenName.isEmpty {
      try visitor.visitSingularStringField(value: self.givenName, fieldNumber: 6)
    }
    if !self.familyName.isEmpty {
      try visitor.visitSingularStringField(value: self.familyName, fieldNumber: 7)
    }
    if !self.username.isEmpty {
      try visitor.visitSingularStringField(value: self.username, fieldNumber: 8)
    }
    if self.blocked != false {
      try visitor.visitSingularBoolField(value: self.blocked, fieldNumber: 9)
    }
    if self.whitelisted != false {
      try visitor.visitSingularBoolField(value: self.whitelisted, fieldNumber: 10)
    }
    if self.archived != false {
      try visitor.visitSingularBoolField(value: self.archived, fieldNumber: 11)
    }
    if self.markedUnread != false {
      try visitor.visitSingularBoolField(value: self.markedUnread, fieldNumber: 12)
    }
    if self.mutedUntilTimestamp != 0 {
      try visitor.visitSingularUInt64Field(value: self.mutedUntilTimestamp, fieldNumber: 13)
    }
    if self.hideStory != false {
      try visitor.visitSingularBoolField(value: self.hideStory, fieldNumber: 14)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: StorageServiceProtos_ContactRecord, rhs: StorageServiceProtos_ContactRecord) -> Bool {
    if lhs.serviceUuid != rhs.serviceUuid {return false}
    if lhs.serviceE164 != rhs.serviceE164 {return false}
    if lhs.profileKey != rhs.profileKey {return false}
    if lhs.identityKey != rhs.identityKey {return false}
    if lhs.identityState != rhs.identityState {return false}
    if lhs.givenName != rhs.givenName {return false}
    if lhs.familyName != rhs.familyName {return false}
    if lhs.username != rhs.username {return false}
    if lhs.blocked != rhs.blocked {return false}
    if lhs.whitelisted != rhs.whitelisted {return false}
    if lhs.archived != rhs.archived {return false}
    if lhs.markedUnread != rhs.markedUnread {return false}
    if lhs.mutedUntilTimestamp != rhs.mutedUntilTimestamp {return false}
    if lhs.hideStory != rhs.hideStory {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension StorageServiceProtos_ContactRecord.IdentityState: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "DEFAULT"),
    1: .same(proto: "VERIFIED"),
    2: .same(proto: "UNVERIFIED"),
  ]
}

extension StorageServiceProtos_GroupV1Record: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GroupV1Record"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "blocked"),
    3: .same(proto: "whitelisted"),
    4: .same(proto: "archived"),
    5: .same(proto: "markedUnread"),
    6: .same(proto: "mutedUntilTimestamp"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.blocked) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.whitelisted) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.archived) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.markedUnread) }()
      case 6: try { try decoder.decodeSingularUInt64Field(value: &self.mutedUntilTimestamp) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularBytesField(value: self.id, fieldNumber: 1)
    }
    if self.blocked != false {
      try visitor.visitSingularBoolField(value: self.blocked, fieldNumber: 2)
    }
    if self.whitelisted != false {
      try visitor.visitSingularBoolField(value: self.whitelisted, fieldNumber: 3)
    }
    if self.archived != false {
      try visitor.visitSingularBoolField(value: self.archived, fieldNumber: 4)
    }
    if self.markedUnread != false {
      try visitor.visitSingularBoolField(value: self.markedUnread, fieldNumber: 5)
    }
    if self.mutedUntilTimestamp != 0 {
      try visitor.visitSingularUInt64Field(value: self.mutedUntilTimestamp, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: StorageServiceProtos_GroupV1Record, rhs: StorageServiceProtos_GroupV1Record) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.blocked != rhs.blocked {return false}
    if lhs.whitelisted != rhs.whitelisted {return false}
    if lhs.archived != rhs.archived {return false}
    if lhs.markedUnread != rhs.markedUnread {return false}
    if lhs.mutedUntilTimestamp != rhs.mutedUntilTimestamp {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension StorageServiceProtos_GroupV2Record: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GroupV2Record"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "masterKey"),
    2: .same(proto: "blocked"),
    3: .same(proto: "whitelisted"),
    4: .same(proto: "archived"),
    5: .same(proto: "markedUnread"),
    6: .same(proto: "mutedUntilTimestamp"),
    8: .same(proto: "hideStory"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.masterKey) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.blocked) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.whitelisted) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.archived) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.markedUnread) }()
      case 6: try { try decoder.decodeSingularUInt64Field(value: &self.mutedUntilTimestamp) }()
      case 8: try { try decoder.decodeSingularBoolField(value: &self.hideStory) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.masterKey.isEmpty {
      try visitor.visitSingularBytesField(value: self.masterKey, fieldNumber: 1)
    }
    if self.blocked != false {
      try visitor.visitSingularBoolField(value: self.blocked, fieldNumber: 2)
    }
    if self.whitelisted != false {
      try visitor.visitSingularBoolField(value: self.whitelisted, fieldNumber: 3)
    }
    if self.archived != false {
      try visitor.visitSingularBoolField(value: self.archived, fieldNumber: 4)
    }
    if self.markedUnread != false {
      try visitor.visitSingularBoolField(value: self.markedUnread, fieldNumber: 5)
    }
    if self.mutedUntilTimestamp != 0 {
      try visitor.visitSingularUInt64Field(value: self.mutedUntilTimestamp, fieldNumber: 6)
    }
    if self.hideStory != false {
      try visitor.visitSingularBoolField(value: self.hideStory, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: StorageServiceProtos_GroupV2Record, rhs: StorageServiceProtos_GroupV2Record) -> Bool {
    if lhs.masterKey != rhs.masterKey {return false}
    if lhs.blocked != rhs.blocked {return false}
    if lhs.whitelisted != rhs.whitelisted {return false}
    if lhs.archived != rhs.archived {return false}
    if lhs.markedUnread != rhs.markedUnread {return false}
    if lhs.mutedUntilTimestamp != rhs.mutedUntilTimestamp {return false}
    if lhs.hideStory != rhs.hideStory {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension StorageServiceProtos_AccountRecord: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AccountRecord"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "profileKey"),
    2: .same(proto: "givenName"),
    3: .same(proto: "familyName"),
    4: .same(proto: "avatarUrl"),
    5: .same(proto: "noteToSelfArchived"),
    6: .same(proto: "readReceipts"),
    7: .same(proto: "sealedSenderIndicators"),
    8: .same(proto: "typingIndicators"),
    9: .same(proto: "proxiedLinkPreviews"),
    10: .same(proto: "noteToSelfMarkedUnread"),
    11: .same(proto: "linkPreviews"),
    12: .same(proto: "phoneNumberSharingMode"),
    13: .same(proto: "notDiscoverableByPhoneNumber"),
    14: .same(proto: "pinnedConversations"),
    15: .same(proto: "preferContactAvatars"),
    16: .same(proto: "payments"),
    17: .same(proto: "universalExpireTimer"),
    19: .same(proto: "e164"),
    20: .same(proto: "preferredReactionEmoji"),
    21: .same(proto: "subscriberID"),
    22: .same(proto: "subscriberCurrencyCode"),
    23: .same(proto: "displayBadgesOnProfile"),
    24: .same(proto: "subscriptionManuallyCancelled"),
    25: .same(proto: "keepMutedChatsArchived"),
  ]

  fileprivate class _StorageClass {
    var _profileKey: Data = Data()
    var _givenName: String = String()
    var _familyName: String = String()
    var _avatarURL: String = String()
    var _noteToSelfArchived: Bool = false
    var _readReceipts: Bool = false
    var _sealedSenderIndicators: Bool = false
    var _typingIndicators: Bool = false
    var _proxiedLinkPreviews: Bool = false
    var _noteToSelfMarkedUnread: Bool = false
    var _linkPreviews: Bool = false
    var _phoneNumberSharingMode: StorageServiceProtos_AccountRecord.PhoneNumberSharingMode = .everybody
    var _notDiscoverableByPhoneNumber: Bool = false
    var _pinnedConversations: [StorageServiceProtos_AccountRecord.PinnedConversation] = []
    var _preferContactAvatars: Bool = false
    var _payments: StorageServiceProtos_AccountRecord.Payments? = nil
    var _universalExpireTimer: UInt32 = 0
    var _e164: String = String()
    var _preferredReactionEmoji: [String] = []
    var _subscriberID: Data = Data()
    var _subscriberCurrencyCode: String = String()
    var _displayBadgesOnProfile: Bool = false
    var _subscriptionManuallyCancelled: Bool = false
    var _keepMutedChatsArchived: Bool = false

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _profileKey = source._profileKey
      _givenName = source._givenName
      _familyName = source._familyName
      _avatarURL = source._avatarURL
      _noteToSelfArchived = source._noteToSelfArchived
      _readReceipts = source._readReceipts
      _sealedSenderIndicators = source._sealedSenderIndicators
      _typingIndicators = source._typingIndicators
      _proxiedLinkPreviews = source._proxiedLinkPreviews
      _noteToSelfMarkedUnread = source._noteToSelfMarkedUnread
      _linkPreviews = source._linkPreviews
      _phoneNumberSharingMode = source._phoneNumberSharingMode
      _notDiscoverableByPhoneNumber = source._notDiscoverableByPhoneNumber
      _pinnedConversations = source._pinnedConversations
      _preferContactAvatars = source._preferContactAvatars
      _payments = source._payments
      _universalExpireTimer = source._universalExpireTimer
      _e164 = source._e164
      _preferredReactionEmoji = source._preferredReactionEmoji
      _subscriberID = source._subscriberID
      _subscriberCurrencyCode = source._subscriberCurrencyCode
      _displayBadgesOnProfile = source._displayBadgesOnProfile
      _subscriptionManuallyCancelled = source._subscriptionManuallyCancelled
      _keepMutedChatsArchived = source._keepMutedChatsArchived
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularBytesField(value: &_storage._profileKey) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._givenName) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._familyName) }()
        case 4: try { try decoder.decodeSingularStringField(value: &_storage._avatarURL) }()
        case 5: try { try decoder.decodeSingularBoolField(value: &_storage._noteToSelfArchived) }()
        case 6: try { try decoder.decodeSingularBoolField(value: &_storage._readReceipts) }()
        case 7: try { try decoder.decodeSingularBoolField(value: &_storage._sealedSenderIndicators) }()
        case 8: try { try decoder.decodeSingularBoolField(value: &_storage._typingIndicators) }()
        case 9: try { try decoder.decodeSingularBoolField(value: &_storage._proxiedLinkPreviews) }()
        case 10: try { try decoder.decodeSingularBoolField(value: &_storage._noteToSelfMarkedUnread) }()
        case 11: try { try decoder.decodeSingularBoolField(value: &_storage._linkPreviews) }()
        case 12: try { try decoder.decodeSingularEnumField(value: &_storage._phoneNumberSharingMode) }()
        case 13: try { try decoder.decodeSingularBoolField(value: &_storage._notDiscoverableByPhoneNumber) }()
        case 14: try { try decoder.decodeRepeatedMessageField(value: &_storage._pinnedConversations) }()
        case 15: try { try decoder.decodeSingularBoolField(value: &_storage._preferContactAvatars) }()
        case 16: try { try decoder.decodeSingularMessageField(value: &_storage._payments) }()
        case 17: try { try decoder.decodeSingularUInt32Field(value: &_storage._universalExpireTimer) }()
        case 19: try { try decoder.decodeSingularStringField(value: &_storage._e164) }()
        case 20: try { try decoder.decodeRepeatedStringField(value: &_storage._preferredReactionEmoji) }()
        case 21: try { try decoder.decodeSingularBytesField(value: &_storage._subscriberID) }()
        case 22: try { try decoder.decodeSingularStringField(value: &_storage._subscriberCurrencyCode) }()
        case 23: try { try decoder.decodeSingularBoolField(value: &_storage._displayBadgesOnProfile) }()
        case 24: try { try decoder.decodeSingularBoolField(value: &_storage._subscriptionManuallyCancelled) }()
        case 25: try { try decoder.decodeSingularBoolField(value: &_storage._keepMutedChatsArchived) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._profileKey.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._profileKey, fieldNumber: 1)
      }
      if !_storage._givenName.isEmpty {
        try visitor.visitSingularStringField(value: _storage._givenName, fieldNumber: 2)
      }
      if !_storage._familyName.isEmpty {
        try visitor.visitSingularStringField(value: _storage._familyName, fieldNumber: 3)
      }
      if !_storage._avatarURL.isEmpty {
        try visitor.visitSingularStringField(value: _storage._avatarURL, fieldNumber: 4)
      }
      if _storage._noteToSelfArchived != false {
        try visitor.visitSingularBoolField(value: _storage._noteToSelfArchived, fieldNumber: 5)
      }
      if _storage._readReceipts != false {
        try visitor.visitSingularBoolField(value: _storage._readReceipts, fieldNumber: 6)
      }
      if _storage._sealedSenderIndicators != false {
        try visitor.visitSingularBoolField(value: _storage._sealedSenderIndicators, fieldNumber: 7)
      }
      if _storage._typingIndicators != false {
        try visitor.visitSingularBoolField(value: _storage._typingIndicators, fieldNumber: 8)
      }
      if _storage._proxiedLinkPreviews != false {
        try visitor.visitSingularBoolField(value: _storage._proxiedLinkPreviews, fieldNumber: 9)
      }
      if _storage._noteToSelfMarkedUnread != false {
        try visitor.visitSingularBoolField(value: _storage._noteToSelfMarkedUnread, fieldNumber: 10)
      }
      if _storage._linkPreviews != false {
        try visitor.visitSingularBoolField(value: _storage._linkPreviews, fieldNumber: 11)
      }
      if _storage._phoneNumberSharingMode != .everybody {
        try visitor.visitSingularEnumField(value: _storage._phoneNumberSharingMode, fieldNumber: 12)
      }
      if _storage._notDiscoverableByPhoneNumber != false {
        try visitor.visitSingularBoolField(value: _storage._notDiscoverableByPhoneNumber, fieldNumber: 13)
      }
      if !_storage._pinnedConversations.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._pinnedConversations, fieldNumber: 14)
      }
      if _storage._preferContactAvatars != false {
        try visitor.visitSingularBoolField(value: _storage._preferContactAvatars, fieldNumber: 15)
      }
      try { if let v = _storage._payments {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
      } }()
      if _storage._universalExpireTimer != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._universalExpireTimer, fieldNumber: 17)
      }
      if !_storage._e164.isEmpty {
        try visitor.visitSingularStringField(value: _storage._e164, fieldNumber: 19)
      }
      if !_storage._preferredReactionEmoji.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._preferredReactionEmoji, fieldNumber: 20)
      }
      if !_storage._subscriberID.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._subscriberID, fieldNumber: 21)
      }
      if !_storage._subscriberCurrencyCode.isEmpty {
        try visitor.visitSingularStringField(value: _storage._subscriberCurrencyCode, fieldNumber: 22)
      }
      if _storage._displayBadgesOnProfile != false {
        try visitor.visitSingularBoolField(value: _storage._displayBadgesOnProfile, fieldNumber: 23)
      }
      if _storage._subscriptionManuallyCancelled != false {
        try visitor.visitSingularBoolField(value: _storage._subscriptionManuallyCancelled, fieldNumber: 24)
      }
      if _storage._keepMutedChatsArchived != false {
        try visitor.visitSingularBoolField(value: _storage._keepMutedChatsArchived, fieldNumber: 25)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: StorageServiceProtos_AccountRecord, rhs: StorageServiceProtos_AccountRecord) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._profileKey != rhs_storage._profileKey {return false}
        if _storage._givenName != rhs_storage._givenName {return false}
        if _storage._familyName != rhs_storage._familyName {return false}
        if _storage._avatarURL != rhs_storage._avatarURL {return false}
        if _storage._noteToSelfArchived != rhs_storage._noteToSelfArchived {return false}
        if _storage._readReceipts != rhs_storage._readReceipts {return false}
        if _storage._sealedSenderIndicators != rhs_storage._sealedSenderIndicators {return false}
        if _storage._typingIndicators != rhs_storage._typingIndicators {return false}
        if _storage._proxiedLinkPreviews != rhs_storage._proxiedLinkPreviews {return false}
        if _storage._noteToSelfMarkedUnread != rhs_storage._noteToSelfMarkedUnread {return false}
        if _storage._linkPreviews != rhs_storage._linkPreviews {return false}
        if _storage._phoneNumberSharingMode != rhs_storage._phoneNumberSharingMode {return false}
        if _storage._notDiscoverableByPhoneNumber != rhs_storage._notDiscoverableByPhoneNumber {return false}
        if _storage._pinnedConversations != rhs_storage._pinnedConversations {return false}
        if _storage._preferContactAvatars != rhs_storage._preferContactAvatars {return false}
        if _storage._payments != rhs_storage._payments {return false}
        if _storage._universalExpireTimer != rhs_storage._universalExpireTimer {return false}
        if _storage._e164 != rhs_storage._e164 {return false}
        if _storage._preferredReactionEmoji != rhs_storage._preferredReactionEmoji {return false}
        if _storage._subscriberID != rhs_storage._subscriberID {return false}
        if _storage._subscriberCurrencyCode != rhs_storage._subscriberCurrencyCode {return false}
        if _storage._displayBadgesOnProfile != rhs_storage._displayBadgesOnProfile {return false}
        if _storage._subscriptionManuallyCancelled != rhs_storage._subscriptionManuallyCancelled {return false}
        if _storage._keepMutedChatsArchived != rhs_storage._keepMutedChatsArchived {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension StorageServiceProtos_AccountRecord.PhoneNumberSharingMode: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "EVERYBODY"),
    1: .same(proto: "CONTACTS_ONLY"),
    2: .same(proto: "NOBODY"),
  ]
}

extension StorageServiceProtos_AccountRecord.PinnedConversation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = StorageServiceProtos_AccountRecord.protoMessageName + ".PinnedConversation"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "contact"),
    3: .same(proto: "legacyGroupId"),
    4: .same(proto: "groupMasterKey"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: StorageServiceProtos_AccountRecord.PinnedConversation.Contact?
        var hadOneofValue = false
        if let current = self.identifier {
          hadOneofValue = true
          if case .contact(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.identifier = .contact(v)
        }
      }()
      case 3: try {
        var v: Data?
        try decoder.decodeSingularBytesField(value: &v)
        if let v = v {
          if self.identifier != nil {try decoder.handleConflictingOneOf()}
          self.identifier = .legacyGroupID(v)
        }
      }()
      case 4: try {
        var v: Data?
        try decoder.decodeSingularBytesField(value: &v)
        if let v = v {
          if self.identifier != nil {try decoder.handleConflictingOneOf()}
          self.identifier = .groupMasterKey(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.identifier {
    case .contact?: try {
      guard case .contact(let v)? = self.identifier else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .legacyGroupID?: try {
      guard case .legacyGroupID(let v)? = self.identifier else { preconditionFailure() }
      try visitor.visitSingularBytesField(value: v, fieldNumber: 3)
    }()
    case .groupMasterKey?: try {
      guard case .groupMasterKey(let v)? = self.identifier else { preconditionFailure() }
      try visitor.visitSingularBytesField(value: v, fieldNumber: 4)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: StorageServiceProtos_AccountRecord.PinnedConversation, rhs: StorageServiceProtos_AccountRecord.PinnedConversation) -> Bool {
    if lhs.identifier != rhs.identifier {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension StorageServiceProtos_AccountRecord.PinnedConversation.Contact: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = StorageServiceProtos_AccountRecord.PinnedConversation.protoMessageName + ".Contact"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "uuid"),
    2: .same(proto: "e164"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.uuid) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.e164) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.uuid.isEmpty {
      try visitor.visitSingularStringField(value: self.uuid, fieldNumber: 1)
    }
    if !self.e164.isEmpty {
      try visitor.visitSingularStringField(value: self.e164, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: StorageServiceProtos_AccountRecord.PinnedConversation.Contact, rhs: StorageServiceProtos_AccountRecord.PinnedConversation.Contact) -> Bool {
    if lhs.uuid != rhs.uuid {return false}
    if lhs.e164 != rhs.e164 {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension StorageServiceProtos_AccountRecord.Payments: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = StorageServiceProtos_AccountRecord.protoMessageName + ".Payments"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "enabled"),
    2: .same(proto: "paymentsEntropy"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.enabled) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.paymentsEntropy) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.enabled != false {
      try visitor.visitSingularBoolField(value: self.enabled, fieldNumber: 1)
    }
    if !self.paymentsEntropy.isEmpty {
      try visitor.visitSingularBytesField(value: self.paymentsEntropy, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: StorageServiceProtos_AccountRecord.Payments, rhs: StorageServiceProtos_AccountRecord.Payments) -> Bool {
    if lhs.enabled != rhs.enabled {return false}
    if lhs.paymentsEntropy != rhs.paymentsEntropy {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension StorageServiceProtos_StoryDistributionListRecord: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".StoryDistributionListRecord"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "identifier"),
    2: .same(proto: "name"),
    3: .same(proto: "recipientUuids"),
    4: .same(proto: "deletedAtTimestamp"),
    5: .same(proto: "allowsReplies"),
    6: .same(proto: "isBlockList"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.identifier) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.recipientUuids) }()
      case 4: try { try decoder.decodeSingularUInt64Field(value: &self.deletedAtTimestamp) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.allowsReplies) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.isBlockList) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.identifier.isEmpty {
      try visitor.visitSingularBytesField(value: self.identifier, fieldNumber: 1)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    if !self.recipientUuids.isEmpty {
      try visitor.visitRepeatedStringField(value: self.recipientUuids, fieldNumber: 3)
    }
    if self.deletedAtTimestamp != 0 {
      try visitor.visitSingularUInt64Field(value: self.deletedAtTimestamp, fieldNumber: 4)
    }
    if self.allowsReplies != false {
      try visitor.visitSingularBoolField(value: self.allowsReplies, fieldNumber: 5)
    }
    if self.isBlockList != false {
      try visitor.visitSingularBoolField(value: self.isBlockList, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: StorageServiceProtos_StoryDistributionListRecord, rhs: StorageServiceProtos_StoryDistributionListRecord) -> Bool {
    if lhs.identifier != rhs.identifier {return false}
    if lhs.name != rhs.name {return false}
    if lhs.recipientUuids != rhs.recipientUuids {return false}
    if lhs.deletedAtTimestamp != rhs.deletedAtTimestamp {return false}
    if lhs.allowsReplies != rhs.allowsReplies {return false}
    if lhs.isBlockList != rhs.isBlockList {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
